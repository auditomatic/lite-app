var Q=Object.defineProperty;var Y=(C,e,t)=>e in C?Q(C,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):C[e]=t;var v=(C,e,t)=>Y(C,typeof e!="symbol"?e+"":e,t);import{a as r,l as G,d as o,i as M,c as D,P as K,f as F,h as $,p as k}from"./index-t8y6vXaP.js";import{f as B,s as J,a as Z,S as ee,R as te,m as re}from"./utils-vendor-X1Ah6TN4.js";import{s as L,c as b,o as x,b as z,h as ae,r as H,f as N}from"./vue-vendor-BZxY9vkr.js";function pe(){const C=performance.now();r.info(`V4_TRIAL_SWITCH: useV4Trials() composable ENTRY at ${C}`);const e=L([]),t=L(!0),a=L(null);let s=null;const i=b(()=>e.value),n=()=>{const E=performance.now();r.info(`V4_TRIAL_SWITCH: setupLiveQuery() ENTRY at ${E}`),s&&(s.unsubscribe(),s=null);const l=G(async()=>{try{return(await o.trials.orderBy("created").reverse().toArray()).filter(A=>!M(A)).map(A=>Object.freeze({...A,created:A.created instanceof Date?A.created:new Date(A.created),started:A.started?A.started instanceof Date?A.started:new Date(A.started):void 0,completed:A.completed?A.completed instanceof Date?A.completed:new Date(A.completed):void 0}))}catch(u){throw r.error("V4_TRIALS: Failed to load trials:",u),u}});s=B(l).subscribe({next:u=>{e.value=u,t.value=!1,a.value=null,r.info(`V4_TRIALS_DB: Loaded ${u.length} trials from database`)},error:u=>{r.error("V4_TRIALS: Query error:",u),a.value=u instanceof Error?u:new Error("Failed to load trials"),t.value=!1}})},m=b(()=>i.value.filter(E=>E.status==="running")),h=b(()=>i.value.filter(E=>E.status==="draft")),p=b(()=>i.value.filter(E=>E.status==="completed")),d=b(()=>i.value.filter(E=>E.status==="paused")),g=b(()=>i.value.filter(E=>E.status==="failed")),c=b(()=>i.value.length),f=b(()=>{const E={total:i.value.length,byStatus:{draft:0,pending:0,running:0,paused:0,completed:0,cancelled:0,failed:0},totalApiCalls:0,completedApiCalls:0,failedApiCalls:0,averageCompletionRate:0};for(const l of i.value)E.byStatus[l.status]++,l.progress&&(E.totalApiCalls+=l.progress.total,E.completedApiCalls+=l.progress.completed,E.failedApiCalls+=l.progress.failed);return E.totalApiCalls>0&&(E.averageCompletionRate=E.completedApiCalls/E.totalApiCalls*100),E}),S=async()=>{t.value=!0,a.value=null;try{const u=(await o.trials.orderBy("created").reverse().toArray()).filter(T=>!M(T)).map(T=>Object.freeze({...T,created:T.created instanceof Date?T.created:new Date(T.created),started:T.started?T.started instanceof Date?T.started:new Date(T.started):void 0,completed:T.completed?T.completed instanceof Date?T.completed:new Date(T.completed):void 0}));e.value=u,t.value=!1,r.info(`V4_TRIALS: Manual refresh loaded ${u.length} trials`)}catch(E){r.error("V4_TRIALS: Refresh failed:",E),a.value=E instanceof Error?E:new Error("Failed to refresh trials"),t.value=!1}};return x(()=>{const E=performance.now();r.info(`V4_TRIAL_SWITCH: useV4Trials onMounted() ENTRY at ${E}`),r.info("V4_TRIALS: Mounting trials query composable");const l=performance.now();r.info(`V4_TRIAL_SWITCH: useV4Trials calling setupLiveQuery() at ${(l-E).toFixed(1)}ms`),n();const u=performance.now();r.info(`V4_TRIAL_SWITCH: useV4Trials setupLiveQuery() completed in ${(u-l).toFixed(1)}ms`)}),z(()=>{r.info("V4_TRIALS: Unmounting trials query composable"),s&&(s.unsubscribe(),s=null)}),{trials:i,loading:t,error:a,runningTrials:m,draftTrials:h,completedTrials:p,pausedTrials:d,failedTrials:g,totalTrials:c,statistics:f,refresh:S}}function he(C){const e=L(null),t=L(!0),a=L(null);let s=null,i=null;const n=b(()=>(typeof C=="object"&&C!==null?C.value:C)?e.value:null),m=p=>{const d=performance.now();if(r.info(`V4_TRIAL_SWITCH: Single trial query setup for ${p}`),s&&(s.unsubscribe(),s=null),!p){e.value=null,t.value=!1,r.info("V4_TRIAL_SWITCH: Single trial query cleared (no ID)");return}const g=G(async()=>{const c=performance.now();r.info(`V4_TRIAL_SWITCH: Single trial DB query starting at ${(c-d).toFixed(1)}ms`);const f=await o.trials.get(p),S=performance.now();return r.info(`V4_TRIAL_SWITCH: Single trial DB query completed in ${(S-c).toFixed(1)}ms`),f?Object.freeze({...f,created:f.created instanceof Date?f.created:new Date(f.created),started:f.started?f.started instanceof Date?f.started:new Date(f.started):void 0,completed:f.completed?f.completed instanceof Date?f.completed:new Date(f.completed):void 0}):null});s=B(g).subscribe({next:c=>{const f=performance.now();e.value=c,t.value=!1,a.value=null,c&&r.info(`V4_TRIAL_SWITCH: Trial ${c.id} loaded from database in ${(f-d).toFixed(1)}ms`)},error:c=>{r.error("V4_TRIALS: Single trial query error:",c),a.value=c instanceof Error?c:new Error("Failed to load trial"),t.value=!1}})},h=async()=>{const p=typeof C=="object"&&C!==null?C.value:C;if(!p){e.value=null,t.value=!1;return}t.value=!0,a.value=null;try{const d=await o.trials.get(p);d?e.value=Object.freeze({...d,created:d.created instanceof Date?d.created:new Date(d.created),started:d.started?d.started instanceof Date?d.started:new Date(d.started):void 0,completed:d.completed?d.completed instanceof Date?d.completed:new Date(d.completed):void 0}):e.value=null,t.value=!1}catch(d){r.error("V4_TRIALS: Refresh single trial failed:",d),a.value=d instanceof Error?d:new Error("Failed to refresh trial"),t.value=!1}};return typeof C=="object"&&C!==null?x(()=>{r.info("V4_TRIALS: Mounting single trial query with reactive ID"),i=ae(()=>{const p=C.value;r.info("V4_TRIALS: Trial ID changed to:",p),m(p)})}):x(()=>{r.info("V4_TRIALS: Mounting single trial query for static ID:",C),m(C)}),z(()=>{r.info("V4_TRIALS: Unmounting single trial query"),s&&(s.unsubscribe(),s=null),i&&(i(),i=null)}),{trial:n,loading:t,error:a,refresh:h}}class se{constructor(){v(this,"state",H({status:"idle",trialId:null,orchestratorType:null,startedAt:null,pausedAt:null,completedAt:null,tabId:null}));v(this,"currentState",b(()=>({...this.state})));v(this,"status",b(()=>this.state.status));v(this,"trialId",b(()=>this.state.trialId));v(this,"orchestratorType",b(()=>this.state.orchestratorType));v(this,"isExecuting",b(()=>["starting","running","pausing"].includes(this.state.status)));v(this,"isPaused",b(()=>this.state.status==="paused"));v(this,"isIdle",b(()=>this.state.status==="idle"))}async hydrate(){r.info("STATE_MACHINE: Hydrating state from database...");const e=await o.trials.where("status").equals("running").toArray();if(e.length>0){r.info(`STATE_MACHINE: Found ${e.length} running trials, marking as paused (page refreshed)`);for(const t of e)await o.trials.update(t.id,{status:"paused"}),r.info(`STATE_MACHINE: Paused trial ${t.id} (was running, page refreshed)`)}r.info("STATE_MACHINE: State machine starting idle - use resume to continue paused trials")}async startExecution(e,t,a){if(r.info(`STATE_MACHINE: Starting execution - trial=${e}, orchestrator=${t}, tab=${a}`),this.state.status!=="idle"&&this.state.status!=="paused")return{ok:!1,error:new Error(`Cannot start: current status is ${this.state.status}`)};try{return this.state.status="starting",this.state.trialId=e,this.state.orchestratorType=t,this.state.tabId=a,this.state.startedAt=new Date,this.state.pausedAt=null,this.state.completedAt=null,await o.trials.update(e,{status:"running",started:this.state.startedAt}),this.state.status="running",r.info(`STATE_MACHINE: Successfully started execution for trial ${e}`),{ok:!0,value:void 0}}catch(s){return this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,{ok:!1,error:s instanceof Error?s:new Error("Failed to start execution")}}}async pauseExecution(){if(r.info(`STATE_MACHINE: Pausing execution - current status=${this.state.status}`),this.state.status!=="running")return{ok:!1,error:new Error(`Cannot pause: current status is ${this.state.status}`)};if(!this.state.trialId)return{ok:!1,error:new Error("Cannot pause: no active trial")};try{return this.state.status="pausing",this.state.pausedAt=new Date,await o.trials.update(this.state.trialId,{status:"paused"}),this.state.status="paused",r.info(`STATE_MACHINE: Successfully paused execution for trial ${this.state.trialId}`),{ok:!0,value:void 0}}catch(e){return this.state.status="running",this.state.pausedAt=null,{ok:!1,error:e instanceof Error?e:new Error("Failed to pause execution")}}}async resumeExecution(e,t){if(r.info(`STATE_MACHINE: Resuming trial ${e} - current status=${this.state.status}, tab=${t}`),!["idle","paused"].includes(this.state.status))return{ok:!1,error:new Error(`Cannot resume: current status is ${this.state.status}`)};try{const a=await o.trials.get(e);if(!a)return{ok:!1,error:new Error(`Trial ${e} not found`)};if(a.status!=="paused")return{ok:!1,error:new Error(`Cannot resume: trial status is ${a.status}, expected paused`)};const s=a.type==="playground"?"streaming":"regular";return this.state.status="running",this.state.trialId=e,this.state.orchestratorType=s,this.state.tabId=t,this.state.startedAt=a.started||new Date,this.state.pausedAt=null,this.state.completedAt=null,await o.trials.update(e,{status:"running"}),r.info(`STATE_MACHINE: Successfully resumed execution for trial ${e}`),{ok:!0,value:void 0}}catch(a){return this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,this.state.pausedAt=null,{ok:!1,error:a instanceof Error?a:new Error("Failed to resume execution")}}}async cancelExecution(){if(r.info(`STATE_MACHINE: Cancelling execution - current status=${this.state.status}`),!["running","paused","starting"].includes(this.state.status))return{ok:!1,error:new Error(`Cannot cancel: current status is ${this.state.status}`)};if(!this.state.trialId)return{ok:!1,error:new Error("Cannot cancel: no active trial")};try{const e=this.state.trialId;return this.state.status="cancelling",this.state.completedAt=new Date,await o.trials.update(e,{status:"cancelled",completed:this.state.completedAt}),this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,this.state.pausedAt=null,r.info(`STATE_MACHINE: Successfully cancelled execution for trial ${e}`),{ok:!0,value:void 0}}catch(e){return this.state.status=this.state.pausedAt?"paused":"running",this.state.completedAt=null,{ok:!1,error:e instanceof Error?e:new Error("Failed to cancel execution")}}}async completeExecution(){if(r.info(`STATE_MACHINE: Completing execution - current status=${this.state.status}`),this.state.status!=="running")return{ok:!1,error:new Error(`Cannot complete: current status is ${this.state.status}`)};if(!this.state.trialId)return{ok:!1,error:new Error("Cannot complete: no active trial")};try{const e=this.state.trialId;return this.state.status="completed",this.state.completedAt=new Date,await o.trials.update(e,{status:"completed",completed:this.state.completedAt}),this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,this.state.pausedAt=null,r.info(`STATE_MACHINE: Successfully completed execution for trial ${e}`),{ok:!0,value:void 0}}catch(e){return this.state.status="running",this.state.completedAt=null,{ok:!1,error:e instanceof Error?e:new Error("Failed to complete execution")}}}canStart(){return this.state.status==="idle"||this.state.status==="paused"}canPause(){return this.state.status==="running"}canResume(){return this.state.status==="paused"&&this.state.orchestratorType!==null}canCancel(){return["running","paused","starting"].includes(this.state.status)}isOwnedByTab(e){return this.state.tabId===e}}const _=new se;class ie{constructor(){v(this,"state",H({tabId:D("tab"),role:"observer",isInitialized:!1,lastHeartbeat:new Date}));v(this,"broadcastChannel",null);v(this,"lockReleaseFunction",null);v(this,"heartbeatInterval",null);v(this,"tabId",b(()=>this.state.tabId));v(this,"role",b(()=>this.state.role));v(this,"isLeader",b(()=>this.state.role==="leader"));v(this,"isObserver",b(()=>this.state.role==="observer"));v(this,"isInitialized",b(()=>this.state.isInitialized))}async initialize(){if(this.state.isInitialized){r.info(`COORDINATION: Tab ${this.state.tabId} already initialized as ${this.state.role}`);return}r.info(`COORDINATION: Initializing tab ${this.state.tabId}`);try{this.broadcastChannel=new BroadcastChannel("auditomatic-coordination"),this.broadcastChannel.onmessage=e=>{this.handleCoordinationMessage(e.data)},await this.attemptLeadershipAcquisition(),this.startHeartbeat(),this.state.isInitialized=!0,r.info(`COORDINATION: Tab ${this.state.tabId} initialized as ${this.state.role}`)}catch(e){throw r.error(`COORDINATION: Failed to initialize tab ${this.state.tabId}:`,e),e}}async attemptLeadershipAcquisition(){if(!("locks"in navigator)){r.info(`COORDINATION: Web Locks not available, tab ${this.state.tabId} becomes leader`),this.state.role="leader";return}try{r.info(`COORDINATION: Tab ${this.state.tabId} attempting to acquire leadership lock`),navigator.locks.request("auditomatic-leader",{mode:"exclusive",ifAvailable:!0},e=>{if(e)return r.info(`COORDINATION: Tab ${this.state.tabId} acquired leadership lock`),this.state.role="leader",new Promise(t=>{this.lockReleaseFunction=t});r.info(`COORDINATION: Tab ${this.state.tabId} could not acquire lock - observer mode`),this.state.role="observer"}),await new Promise(e=>setTimeout(e,50))}catch(e){r.error(`COORDINATION: Leadership acquisition failed for tab ${this.state.tabId}:`,e),this.state.role="observer"}}startHeartbeat(){this.heartbeatInterval=setInterval(()=>{this.state.lastHeartbeat=new Date,this.broadcast({type:"heartbeat",tabId:this.state.tabId,timestamp:this.state.lastHeartbeat})},1e4)}broadcast(e){this.broadcastChannel&&(r.info(`COORDINATION: Broadcasting ${e.type} from tab ${this.state.tabId}`),this.broadcastChannel.postMessage(e))}handleCoordinationMessage(e){if(e.tabId!==this.state.tabId)switch(r.info(`COORDINATION: Tab ${this.state.tabId} received ${e.type} from ${e.tabId}`),e.type){case"execution:started":this.state.role==="observer"&&e.trialId&&r.info(`COORDINATION: Observer tab syncing to started execution: ${e.trialId}`);break;case"execution:paused":this.state.role==="observer"&&e.trialId&&r.info(`COORDINATION: Observer tab syncing to paused execution: ${e.trialId}`);break;case"execution:resumed":this.state.role==="observer"&&e.trialId&&r.info(`COORDINATION: Observer tab syncing to resumed execution: ${e.trialId}`);break;case"execution:cancelled":case"execution:completed":this.state.role==="observer"&&e.trialId&&r.info(`COORDINATION: Observer tab syncing to ended execution: ${e.trialId}`);break;case"heartbeat":r.info(`COORDINATION: Heartbeat from ${e.tabId}`);break}}canExecuteActions(){return this.state.role==="leader"}validateLeadership(e){return this.state.role!=="leader"?{ok:!1,error:new Error(`Cannot ${e}: only leader tab can execute actions`)}:{ok:!0,value:void 0}}async startExecution(e,t){const a=this.validateLeadership("start execution");if(!a.ok)return a;r.info(`COORDINATION: Leader starting execution - trial=${e}, orchestrator=${t}`);const s=await _.startExecution(e,t,this.state.tabId);return s.ok&&this.broadcast({type:"execution:started",tabId:this.state.tabId,timestamp:new Date,trialId:e,orchestratorType:t}),s}async pauseExecution(){const e=this.validateLeadership("pause execution");if(!e.ok)return e;r.info("COORDINATION: Leader pausing execution");const t=await _.pauseExecution();return t.ok&&this.broadcast({type:"execution:paused",tabId:this.state.tabId,timestamp:new Date,trialId:_.trialId.value||void 0}),t}async resumeExecution(e){const t=this.validateLeadership("resume execution");if(!t.ok)return t;r.info(`COORDINATION: Leader resuming execution for trial ${e}`);const a=await _.resumeExecution(e,this.state.tabId);return a.ok&&this.broadcast({type:"execution:resumed",tabId:this.state.tabId,timestamp:new Date,trialId:e}),a}async cancelExecution(){const e=this.validateLeadership("cancel execution");if(!e.ok)return e;r.info("COORDINATION: Leader cancelling execution");const t=_.trialId.value,a=await _.cancelExecution();return a.ok&&this.broadcast({type:"execution:cancelled",tabId:this.state.tabId,timestamp:new Date,trialId:t||void 0}),a}async completeExecution(){const e=this.validateLeadership("complete execution");if(!e.ok)return e;r.info("COORDINATION: Leader completing execution");const t=_.trialId.value,a=await _.completeExecution();return a.ok&&this.broadcast({type:"execution:completed",tabId:this.state.tabId,timestamp:new Date,trialId:t||void 0}),a}destroy(){r.info(`COORDINATION: Destroying tab ${this.state.tabId}`),this.heartbeatInterval&&(clearInterval(this.heartbeatInterval),this.heartbeatInterval=null),this.lockReleaseFunction&&(this.lockReleaseFunction(),this.lockReleaseFunction=null),this.broadcastChannel&&(this.broadcastChannel.close(),this.broadcastChannel=null),this.state.isInitialized=!1,r.info(`COORDINATION: Tab ${this.state.tabId} cleanup complete`)}}const w=new ie;class ne{async updateTrial(e){r.info(`ATOMIC_OPS: Updating trial ${e.trialId} - status=${e.status}`);try{const t={};return e.status!==void 0&&(t.status=e.status),e.started!==void 0&&(t.started=e.started),e.completed!==void 0&&(t.completed=e.completed),e.progress!==void 0&&(t.progress=e.progress),await o.trials.update(e.trialId,t),r.info(`ATOMIC_OPS: Successfully updated trial ${e.trialId}`),{ok:!0,value:void 0}}catch(t){return r.error(`ATOMIC_OPS: Failed to update trial ${e.trialId}:`,t),{ok:!1,error:t instanceof Error?t:new Error("Failed to update trial")}}}async resetRunningCallsToPending(e){r.info(`ATOMIC_OPS: Resetting running calls to pending for trial ${e}`);try{const t=await o.apiCalls.where("trialId").equals(e).and(a=>a.status==="running").toArray();return t.length===0?r.info(`ATOMIC_OPS: No running calls found for trial ${e}`):(await o.transaction("rw",o.apiCalls,async()=>{for(const a of t)await o.apiCalls.update(a.id,{status:"pending",started:void 0,response:void 0,result:void 0})}),r.info(`ATOMIC_OPS: Reset ${t.length} running calls to pending for trial ${e}`)),r.info("V4_TRIAL_DEBUG_PAUSE: Recalculating trial progress after call status changes"),await this.recalculateTrialProgress(e),{ok:!0,value:t.length}}catch(t){return r.error(`ATOMIC_OPS: Failed to reset running calls for trial ${e}:`,t),{ok:!1,error:t instanceof Error?t:new Error("Failed to reset running calls")}}}async getTrialCallCounts(e){r.info(`ATOMIC_OPS: Getting call counts for trial ${e}`);try{const t=await o.transaction("r",o.apiCalls,async()=>{const a=await o.apiCalls.where("trialId").equals(e).toArray();return{total:a.length,completed:a.filter(s=>s.status==="completed").length,failed:a.filter(s=>s.status==="failed").length,cancelled:a.filter(s=>s.status==="cancelled").length,pending:a.filter(s=>s.status==="pending").length,running:a.filter(s=>s.status==="running").length}});return r.info(`TRANSACTION_FIX: Trial ${e} call counts (consistent snapshot):`,t),{ok:!0,value:t}}catch(t){return r.error(`ATOMIC_OPS: Failed to get call counts for trial ${e}:`,t),{ok:!1,error:t instanceof Error?t:new Error("Failed to get call counts")}}}async updateApiCallsBatch(e){if(e.length===0)return{ok:!0,value:void 0};r.info(`ATOMIC_OPS: Updating batch of ${e.length} API calls`);try{return await o.transaction("rw",o.apiCalls,async()=>{for(const t of e){const a={status:t.status};t.started!==void 0&&(a.started=t.started),t.completed!==void 0&&(a.completed=t.completed),t.response!==void 0&&(a.response=t.response),t.error!==void 0&&(a.error=t.error),await o.apiCalls.update(t.callId,a)}}),r.info(`ATOMIC_OPS: Successfully updated batch of ${e.length} API calls`),{ok:!0,value:void 0}}catch(t){return r.error("ATOMIC_OPS: Failed to update API calls batch:",t),{ok:!1,error:t instanceof Error?t:new Error("Failed to update API calls batch")}}}async reconcileTrialState(e){r.info(`ATOMIC_OPS: Reconciling state for trial ${e}`);try{const t=await o.trials.get(e);if(!t)return{ok:!1,error:new Error(`Trial ${e} not found`)};const a=await this.getTrialCallCounts(e);if(!a.ok)return a;const s=a.value;let i=t.status;if(s.running>0?i="running":s.pending>0?i="paused":s.completed===s.total&&s.total>0||s.failed>0&&s.completed+s.failed===s.total?i="completed":s.cancelled>0&&(i="cancelled"),i!==t.status){r.info(`ATOMIC_OPS: Reconciling trial ${e} status: ${t.status} â†’ ${i}`);const n=await this.updateTrial({trialId:e,status:i,progress:s,...i==="completed"&&{completed:new Date}});if(!n.ok)return n}else r.info(`ATOMIC_OPS: Trial ${e} status is consistent: ${i}`);return{ok:!0,value:i}}catch(t){return r.error(`ATOMIC_OPS: Failed to reconcile trial ${e} state:`,t),{ok:!1,error:t instanceof Error?t:new Error("Failed to reconcile trial state")}}}async performCleanupOperations(e){r.info(`ATOMIC_OPS: Performing cleanup operations for trial ${e}`);try{const t=await this.resetRunningCallsToPending(e);if(!t.ok)return t;const a=await this.reconcileTrialState(e);if(!a.ok)return a;const s={resetCount:t.value,reconciledStatus:a.value};return r.info(`ATOMIC_OPS: Cleanup complete for trial ${e}:`,s),{ok:!0,value:s}}catch(t){return r.error(`ATOMIC_OPS: Failed cleanup operations for trial ${e}:`,t),{ok:!1,error:t instanceof Error?t:new Error("Failed cleanup operations")}}}async recalculateTrialProgress(e){var t;try{const a=await o.trials.get(e);if(!a){r.info(`V4_TRIAL_DEBUG_PAUSE: Trial ${e} not found, cannot recalculate progress`);return}const s=await o.apiCalls.where("trialId").equals(e).toArray();let i=0,n=0,m=0,h=0,p=0;for(const c of s)switch(c.status){case"completed":i++;break;case"failed":n++,((t=c.result)==null?void 0:t.errorType)==="network_error_no_response"&&p++;break;case"cancelled":m++;break;case"running":h++;break}const d=a.progress.total-i-n-m-h,g={total:a.progress.total,completed:i,failed:n,cancelled:m,pending:d,running:h,networkErrors:p};r.info(`V4_TRIAL_DEBUG_PAUSE: Recalculated progress for trial ${e} - completed: ${i}, failed: ${n}, running: ${h}, pending: ${d}`),await o.trials.update(e,{progress:g}),r.info("V4_TRIAL_DEBUG_PAUSE: Trial progress updated successfully")}catch(a){r.error(`V4_TRIAL_DEBUG_PAUSE: Failed to recalculate progress for trial ${e}:`,a)}}async performSystemCleanup(){r.info("ATOMIC_OPS: Performing system-wide cleanup");try{let e=0,t=0;const a=await o.trials.where("status").equals("running").toArray();r.info(`ATOMIC_OPS: Found ${a.length} active trials for cleanup`);for(const i of a){const n=await this.performCleanupOperations(i.id);if(n.ok)e+=n.value.resetCount,t++;else{const m=n;r.warn(`ATOMIC_OPS: Failed to cleanup trial ${i.id}:`,m.error.message)}}const s={trialsProcessed:t,callsReset:e};return r.info("ATOMIC_OPS: System cleanup complete:",s),{ok:!0,value:s}}catch(e){return r.error("ATOMIC_OPS: System cleanup failed:",e),{ok:!1,error:e instanceof Error?e:new Error("System cleanup failed")}}}}const oe=new ne;class le{constructor(){v(this,"playgroundService",null);v(this,"initialized",!1);v(this,"orchestrators",new Map);v(this,"activeStreams",new Map);v(this,"execution",b(()=>{const e=_.status.value;let t="idle";return e==="running"||e==="starting"||e==="pausing"?t="executing":e==="paused"?t="paused":t="idle",{status:t,currentTrialId:_.trialId.value,startedAt:_.currentState.value.startedAt}}));v(this,"progress",b(()=>({trials:new Map,activeApiCall:null,lastUpdated:new Date})));v(this,"queue",b(()=>({global:{pending:0,executing:0,capacity:0,utilization:0},providers:new Map})));v(this,"tabRole",b(()=>w.role.value));v(this,"isLeader",b(()=>w.isLeader.value));v(this,"canExecute",b(()=>w.isLeader.value&&_.canStart()))}async initialize(){const e=performance.now();if(r.info(`V4_TRIAL_SWITCH: V4ExecutionControl initialize() ENTRY at ${e}`),r.info(`V4_SINGLETON_DEBUG: Current initialized flag: ${this.initialized}`),r.info(`V4_SINGLETON_DEBUG: Active streams count: ${this.activeStreams.size}`),this.initialized){r.info("V4_SINGLETON_DEBUG: V4ExecutionControl already initialized, returning early - singleton working correctly!");return}try{r.info("V4_EXECUTION_CONTROL: Initializing with V4 coordination + V3 execution bridge");const t=performance.now();r.info(`V4_TRIAL_SWITCH: Starting multiTabCoordinator.initialize() at ${(t-e).toFixed(1)}ms`),await w.initialize();const a=performance.now();r.info(`V4_TRIAL_SWITCH: multiTabCoordinator.initialize() completed in ${(a-t).toFixed(1)}ms`),r.info("V4_EXECUTION_CONTROL: Performing system cleanup with V4 atomic operations");const s=performance.now();r.info(`V4_TRIAL_SWITCH: Starting atomicOperations.performSystemCleanup() at ${(s-e).toFixed(1)}ms`);const i=await oe.performSystemCleanup(),n=performance.now();if(r.info(`V4_TRIAL_SWITCH: atomicOperations.performSystemCleanup() completed in ${(n-s).toFixed(1)}ms`),i.ok)r.info("V4_EXECUTION_CONTROL: System cleanup completed:",i.value);else{const d=i;r.warn("V4_EXECUTION_CONTROL: System cleanup failed:",d.error)}const m=performance.now();r.info(`V4_TRIAL_SWITCH: Creating PlaygroundExecutionService at ${(m-e).toFixed(1)}ms`),this.playgroundService=new K(async d=>{const g=await this.startTrialWithStreaming(d);return g.ok?{ok:!0,value:g.value.progress$}:g});const h=performance.now();r.info(`V4_TRIAL_SWITCH: PlaygroundExecutionService created in ${(h-m).toFixed(1)}ms`),this.initialized=!0;const p=performance.now();r.info(`V4_TRIAL_SWITCH: V4ExecutionControl initialization TOTAL: ${(p-e).toFixed(1)}ms`),r.info("V4_EXECUTION_CONTROL: Initialization complete")}catch(t){const a=performance.now();throw r.error(`V4_TRIAL_SWITCH: V4ExecutionControl initialization FAILED in ${(a-e).toFixed(1)}ms:`,t),t}}cleanup(){r.info("V4_SINGLETON_DEBUG: cleanup() called - this will reset initialized flag and destroy singleton!"),r.info(`V4_SINGLETON_DEBUG: Current active streams: ${this.activeStreams.size}`),r.info(`V4_SINGLETON_DEBUG: Current orchestrators: ${this.orchestrators.size}`);try{this.activeStreams.forEach((e,t)=>{r.info(`V4_SINGLETON_DEBUG: Cleaning up streams for trial ${t}`),e.subscription.unsubscribe()}),this.activeStreams.clear(),this.orchestrators.forEach((e,t)=>{r.info(`V4_SINGLETON_DEBUG: Cleaning up orchestrator for trial ${t}`)}),this.orchestrators.clear(),w.destroy(),this.playgroundService=null,this.initialized=!1,r.info("V4_SINGLETON_DEBUG: Cleanup complete - singleton destroyed, will reinitialize on next call")}catch(e){r.error("V4_EXECUTION_CONTROL: Cleanup error:",e)}}async startTrial(e){var t;this.initialized||await this.initialize(),r.info(`V4_EXECUTION_CONTROL: Starting trial ${e} with V4+V3 bridge`);try{if(F(e)){const m=await(((t=this.playgroundService)==null?void 0:t.executePlaygroundCall("",{}))||Promise.resolve({ok:!1,error:new Error("Playground service not available")}));return m.ok?{ok:!0,value:void 0}:{ok:!1,error:m.error}}let s=this.orchestrators.get(e);s||(r.info("V4_EXECUTION_CONTROL: Creating fresh V3 orchestrator for trial:",e),s=$(),this.orchestrators.set(e,s));const n=await s.startTrialAtomic(e);return n.ok?(r.info(`V4_EXECUTION_CONTROL: Successfully started trial ${e} via bridge`),{ok:!0,value:void 0}):{ok:!1,error:n.error}}catch(a){return r.error(`V4_EXECUTION_CONTROL: Failed to start trial ${e}:`,a),{ok:!1,error:a instanceof Error?a:new Error("Failed to start trial")}}}async startTrialWithStreaming(e){this.initialized||await this.initialize(),r.info(`V4_EXECUTION_CONTROL: Starting streaming trial ${e}`),this.cleanupStreams(e);try{if(F(e))return r.info("V4_EXECUTION_CONTROL: Playground trial detected, using specialized handling"),{ok:!1,error:new Error("Playground streaming not yet implemented in V4")};if(!this.canExecute.value)return r.info("V4_EXECUTION_CONTROL: Cannot start - not leader or invalid state"),{ok:!1,error:new Error("Cannot start trial - not leader or invalid state")};r.info("V4_EXECUTION_CONTROL: Updating state machine to running");const a=w.tabId.value,s=await _.startExecution(e,"streaming",a);if(!s.ok)return r.info("V4_EXECUTION_CONTROL: State machine update failed:",s.error),{ok:!1,error:s.error};let i=this.orchestrators.get(e);i||(r.info("V4_EXECUTION_CONTROL: Creating fresh V3 orchestrator for trial:",e),i=$(),this.orchestrators.set(e,i)),r.info("V4_EXECUTION_CONTROL: Calling V3 orchestrator startTrialAtomicWithStreaming");const n=await i.startTrialAtomicWithStreaming(e);if(!n.ok)return{ok:!1,error:n.error};r.info("V4_EXECUTION_CONTROL: Creating hot observables without accumulation"),r.info(`V4_EXECUTION_CONTROL: Creating hot observables for trial ${e}`);const m=n.value.progress$.pipe(J(),Z({bufferSize:1,refCount:!0})),h=new ee,p=new te(1),d=n.value.calls$.pipe(re(c=>(r.info(`V4_EXECUTION_CONTROL: Batch of ${c.length} calls from pipeline`),c.map(f=>f.call&&f.providerId?f.call:f)))).subscribe({next:c=>{r.info(`V4_EXECUTION_CONTROL: Forwarding ${c.length} calls to subject`),p.next(c)},error:c=>{r.info("V4_TRIAL_ERROR: Error in calls stream:",c),p.error(c)},complete:()=>{r.info(`V4_TRIAL_COMPLETE: Original calls stream completed for trial ${e}`)}});h.add(d);const g=p;return r.info("V4_TRIAL_REF_TEST: callsSubject === sharedCalls$?",p===g),h.add(m.subscribe({next:c=>{r.info(`V4_TRIAL_DEBUG_COMPLETION: Progress update for trial ${e}: ${c.type}`),(c.type==="completed"||c.type==="error")&&(r.info(`V4_TRIAL_DEBUG_COMPLETION: Trial ${e} ${c.type}, scheduling cleanup in 1000ms`),r.info(`V4_TRIAL_DEBUG_COMPLETION: Current execution state: ${_.status.value}`),r.info("V4_TRIAL_DEBUG_COMPLETION: Updating V4 coordination layer to completed/cancelled state"),c.type==="completed"?(r.info("V4_TRIAL_DEBUG_COMPLETION: Calling multiTabCoordinator.completeExecution()"),w.completeExecution().then(f=>{f.ok?(r.info("V4_TRIAL_DEBUG_COMPLETION: Coordination layer updated to completed successfully"),r.info(`V4_TRIAL_DEBUG_COMPLETION: Post-completion execution state: ${_.status.value}`)):r.error("V4_TRIAL_DEBUG_COMPLETION: Coordination layer completion update failed:",f.error)})):(r.info("V4_TRIAL_DEBUG_COMPLETION: Calling multiTabCoordinator.cancelExecution() for error"),w.cancelExecution().then(f=>{f.ok?(r.info("V4_TRIAL_DEBUG_COMPLETION: Coordination layer updated to cancelled successfully"),r.info(`V4_TRIAL_DEBUG_COMPLETION: Post-cancellation execution state: ${_.status.value}`)):r.error("V4_TRIAL_DEBUG_COMPLETION: Coordination layer cancellation update failed:",f.error)})),setTimeout(()=>{r.info(`V4_TRIAL_DEBUG_COMPLETION: Executing delayed cleanup for trial ${e}`),r.info(`V4_TRIAL_DEBUG_COMPLETION: Post-completion execution state: ${_.status.value}`),this.cleanupStreams(e),this.orchestrators.has(e)&&(r.info(`V4_TRIAL_DEBUG_COMPLETION: Removing orchestrator for completed trial ${e}`),this.orchestrators.delete(e))},1e3))},error:c=>{r.error(`V4_TRIAL_DEBUG_COMPLETION: Stream error for trial ${e}:`,c),r.info("V4_TRIAL_DEBUG_COMPLETION: Updating V4 coordination layer to cancelled state due to error"),w.cancelExecution().then(f=>{f.ok?(r.info("V4_TRIAL_DEBUG_COMPLETION: Coordination layer updated to cancelled after error"),r.info(`V4_TRIAL_DEBUG_COMPLETION: Post-error execution state: ${_.status.value}`)):r.error("V4_TRIAL_DEBUG_COMPLETION: Coordination layer error cancellation failed:",f.error)}),this.cleanupStreams(e),this.orchestrators.has(e)&&(r.info(`V4_TRIAL_DEBUG_COMPLETION: Removing orchestrator for errored trial ${e}`),this.orchestrators.delete(e))}})),r.info(`V4_TRIAL_STORE: Storing activeStreams for trial ${e}`),this.activeStreams.set(e,{streams:n.value,subscription:h,sharedProgress$:m,sharedCalls$:g,callsSubject:p}),r.info(`V4_EXECUTION_CONTROL: Successfully created hot observables for trial ${e}`),{ok:!0,value:n.value}}catch(t){return r.error(`V4_EXECUTION_CONTROL: Failed to start streaming trial ${e}:`,t),{ok:!1,error:t instanceof Error?t:new Error("Failed to start streaming trial")}}}async pauseExecution(){this.initialized||await this.initialize();const e=_.trialId.value;if(r.info(`V4_TRIAL_DEBUG_PAUSE: pauseExecution() ENTRY for trial ${e||"NONE"}`),r.info(`V4_TRIAL_DEBUG_PAUSE: Current execution state: ${_.status.value}`),r.info(`V4_TRIAL_DEBUG_PAUSE: Active streams count: ${this.activeStreams.size}`),!e)return r.info("V4_TRIAL_DEBUG_PAUSE: ERROR - No active trial to pause"),{ok:!1,error:new Error("No active trial to pause")};if(!_.canPause())return r.info("V4_TRIAL_DEBUG_PAUSE: Cannot pause - invalid state"),{ok:!1,error:new Error("Cannot pause in current state")};r.info("V4_TRIAL_DEBUG_PAUSE: Calling V3 orchestrator pauseTrial FIRST");const t=this.orchestrators.get(e);t&&(await t.pauseTrial(),r.info("V4_TRIAL_DEBUG_PAUSE: V3 pipeline paused, keeping orchestrator alive for potential hot resume")),r.info("V4_TRIAL_DEBUG_PAUSE: V3 paused, now updating state machine to paused");const a=await _.pauseExecution();return a.ok?(w.pauseExecution(),r.info("V4_TRIAL_DEBUG_PAUSE: Pause successful"),{ok:!0,value:void 0}):(r.info("V4_TRIAL_DEBUG_PAUSE: State machine update failed:",a.error),a)}async resumeExecution(e){this.initialized||await this.initialize();const t=e||_.trialId.value;if(r.info(`V4_TRIAL_DEBUG_RESUME: resumeExecution() ENTRY for trial ${t||"NONE"}`),r.info(`V4_TRIAL_DEBUG_RESUME: Current execution state: ${_.status.value}`),r.info(`V4_TRIAL_DEBUG_RESUME: Active streams count: ${this.activeStreams.size}`),r.info(`V4_TRIAL_DEBUG_RESUME: Provided trialId: ${e||"NONE"}, state trialId: ${_.trialId.value||"NONE"}`),!t)return r.info("V4_TRIAL_DEBUG_RESUME: ERROR - No trial ID provided and no active trial to resume"),{ok:!1,error:new Error("No trial ID provided and no active trial to resume")};if(!_.canResume())return r.info("V4_TRIAL_DEBUG_RESUME: Cannot resume - invalid state"),{ok:!1,error:new Error("Cannot resume in current state")};r.info("V4_TRIAL_DEBUG_RESUME: Updating state machine to running");const a=w.tabId.value,s=await _.resumeExecution(t,a);if(!s.ok)return r.info("V4_TRIAL_DEBUG_RESUME: State machine update failed:",s.error),s;let i=this.orchestrators.get(t);if(i)r.info(`V4_TRIAL_DEBUG_RESUME: HOT RESUME - Found existing orchestrator for trial ${t}`),r.info("V4_TRIAL_DEBUG_RESUME: Calling orchestrator.resumeTrial() to flip pause$ and resume pipeline"),i.resumeTrial();else{r.info(`V4_TRIAL_DEBUG_RESUME: COLD RESUME - No orchestrator found for trial ${t}`),r.info("V4_TRIAL_DEBUG_RESUME: Creating fresh orchestrator and starting with pending calls"),i=$(),this.orchestrators.set(t,i),r.info("V4_TRIAL_DEBUG_RESUME: Calling startTrialAtomicWithStreaming to create new pipeline");const n=await i.startTrialAtomicWithStreaming(t);if(!n.ok)return r.error("V4_TRIAL_DEBUG_RESUME: Failed to start trial for cold resume:",n.error),{ok:!1,error:n.error};r.info("V4_TRIAL_DEBUG_RESUME: Cold resume successful, storing new streams")}return w.resumeExecution(t),r.info("V4_TRIAL_DEBUG_RESUME: Resume successful"),{ok:!0,value:void 0}}async cancelExecution(){this.initialized||await this.initialize(),r.info("V4_EXECUTION_CONTROL: Cancelling execution");const e=_.trialId.value;if(!e)return{ok:!1,error:new Error("No active trial to cancel")};if(!_.canCancel())return r.info("V4_EXECUTION_CONTROL: Cannot cancel - invalid state"),{ok:!1,error:new Error("Cannot cancel in current state")};r.info("V4_EXECUTION_CONTROL: Updating state machine to cancelled");const t=await _.cancelExecution();if(!t.ok)return r.info("V4_EXECUTION_CONTROL: State machine update failed:",t.error),t;r.info("V4_EXECUTION_CONTROL: Calling V3 orchestrator cancelTrial");const a=this.orchestrators.get(e);return a&&(a.cancelTrial(),r.info("V4_EXECUTION_CONTROL: Removing orchestrator after cancel"),this.orchestrators.delete(e)),w.cancelExecution(),this.cleanupStreams(e),r.info("V4_EXECUTION_CONTROL: Cancel successful"),{ok:!0,value:void 0}}async executeSingleCall(e,t,a){return this.initialized||await this.initialize(),this.playgroundService?this.playgroundService.executePlaygroundCall(e,a):{ok:!1,error:new Error("Playground service not initialized")}}getActiveStreams(e){const t=this.activeStreams.get(e);return r.info(`V4_TRIAL_GET: getActiveStreams(${e}) called, found: ${!!t}, has sharedCalls$: ${!!(t!=null&&t.sharedCalls$)}`),t}cleanupStreams(e){r.info(`V4_TRIAL_DEBUG_CLEANUP: cleanupStreams() ENTRY for trial ${e}`),r.info(`V4_TRIAL_DEBUG_CLEANUP: Current execution state: ${_.status.value}`),r.info(`V4_TRIAL_DEBUG_CLEANUP: Current state trialId: ${_.trialId.value}`);const t=this.activeStreams.get(e);t?(r.info(`V4_TRIAL_DEBUG_CLEANUP: Found streams for trial ${e}, unsubscribing`),t.subscription.unsubscribe(),this.activeStreams.delete(e),r.info(`V4_TRIAL_DEBUG_CLEANUP: Cleaned up streams, remaining active streams: ${this.activeStreams.size}`)):r.info(`V4_TRIAL_DEBUG_CLEANUP: No streams found for trial ${e} (already cleaned up?)`)}}let U=null;function me(){return U||(U=new le),U}class q{async createTrial(e){try{const t=this.validateTrialConfig(e);if(!t.ok)return{ok:!1,error:t.error};const a=await this.createConfigurationSnapshots(e.configurations);let s=e.templateConfig;if(e.type==="template"&&s){const m=await this.createVariableSnapshots(s.variables);s={...s,variables:m,hasSnapshots:!0}}const i={id:D("trial"),name:e.name,description:e.description,type:e.type,status:"draft",configurations:a,progress:{total:0,completed:0,failed:0,cancelled:0,pending:0,running:0,networkErrors:0},created:new Date,...e.repeatCount&&e.repeatCount>1?{repeatConfig:{callsPerPrompt:e.repeatCount}}:{},...e.type==="template"&&s?{templateConfig:s}:{},...e.type==="spreadsheet"&&e.spreadsheetConfig?{spreadsheetConfig:e.spreadsheetConfig}:{}},n=await this.generateApiCalls(i,e.repeatCount||1);return i.progress.total=n.length,i.progress.pending=n.length,await o.transaction("rw",o.trials,o.apiCalls,async()=>{await o.trials.add(i),n.length>0&&await o.apiCalls.bulkAdd(n)}),r.info(`V4_TRIALS: Created trial ${i.id} with ${n.length} API calls`),{ok:!0,value:i.id}}catch(t){return r.error("V4_TRIALS: Failed to create trial:",t),{ok:!1,error:t instanceof Error?t:new Error("Failed to create trial")}}}async updateTrial(e,t){try{return await o.transaction("rw",o.trials,async()=>{const a=await o.trials.get(e);if(!a)throw new Error(`Trial not found: ${e}`);const s={...a,...t,created:a.created};await o.trials.put(s)}),{ok:!0}}catch(a){return r.error("V4_TRIALS: Failed to update trial:",a),{ok:!1,error:a instanceof Error?a:new Error("Failed to update trial")}}}async deleteTrial(e){try{return await o.transaction("rw",o.trials,o.apiCalls,async()=>{const t=await o.trials.get(e);if(!t)throw new Error(`Trial not found: ${e}`);if(t.status==="running")throw new Error("Cannot delete running trial");await o.apiCalls.where("trialId").equals(e).delete(),await o.trials.delete(e)}),r.info(`V4_TRIALS: Deleted trial ${e} and all associated API calls`),{ok:!0}}catch(t){return r.error("V4_TRIALS: Failed to delete trial:",t),{ok:!1,error:t instanceof Error?t:new Error("Failed to delete trial")}}}async duplicateTrial(e){try{const t=await o.trials.get(e);if(!t)return{ok:!1,error:new Error(`Source trial not found: ${e}`)};const a={name:`${t.name} (Copy)`,description:t.description,type:t.type,configurations:t.configurations.map(s=>{var i;return{provider:s.provider,modelId:s.modelId,parameters:s.parameters,name:(i=s.modelSnapshot)==null?void 0:i.displayName}}),repeatCount:t.repeatCount,...t.type==="template"&&t.templateConfig?{templateConfig:t.templateConfig}:{},...t.type==="spreadsheet"&&t.spreadsheetConfig?{spreadsheetConfig:t.spreadsheetConfig}:{}};return this.createTrial(a)}catch(t){return r.error("V4_TRIALS: Failed to duplicate trial:",t),{ok:!1,error:t instanceof Error?t:new Error("Failed to duplicate trial")}}}async updateTrialProgress(e){try{return await o.transaction("rw",o.trials,o.apiCalls,async()=>{var d;const t=await o.trials.get(e);if(!t)throw new Error(`Trial not found: ${e}`);const a=await o.apiCalls.where("trialId").equals(e).toArray();let s=0,i=0,n=0,m=0,h=0;for(const g of a)switch(g.status){case"completed":s++;break;case"failed":i++,((d=g.result)==null?void 0:d.errorType)==="network_error_no_response"&&h++;break;case"cancelled":n++;break;case"running":m++;break}const p=t.progress.total-s-i-n-m;t.progress={total:t.progress.total,completed:s,failed:i,cancelled:n,pending:p,running:m,networkErrors:h},s+i+n>=t.progress.total&&t.status==="running"&&(t.status="completed",t.completed=new Date),await o.trials.put(t)}),{ok:!0}}catch(t){return r.error("V4_TRIALS: Failed to update trial progress:",t),{ok:!1,error:t instanceof Error?t:new Error("Failed to update progress")}}}async generateApiCalls(e,t){return r.info(`V4_TRIALS: Generating REAL API calls for trial ${e.id}, type: ${e.type}`),e.type==="template"&&e.templateConfig?this.generateTemplateApiCalls(e,e.templateConfig,t):e.type==="spreadsheet"&&e.spreadsheetConfig?this.generateSpreadsheetApiCalls(e,e.spreadsheetConfig,t):e.type==="playground"?[]:(r.warn(`V4_TRIALS: Unknown trial type or missing config for trial ${e.id}`),[])}async generateTemplateApiCalls(e,t,a){if(!t)return[];const s=[];let i=0;const n=await this.generateVariableCombinations(t.variables);r.info(`V4_TRIALS: Generated ${n.length} variable combinations`);for(let m=0;m<a;m++)for(let h=0;h<e.configurations.length;h++)for(const p of n){const d=this.substituteVariables(t.template,p.variables),g={id:D("call"),trialId:e.id,configurationIndex:h,order:i++,variables:p.variables,variableAttributes:p.variableAttributes,variableIndices:p.variableIndices,prompt:d,status:"pending",retryCount:0,created:new Date};s.push(g)}return r.info(`V4_TRIALS: Generated ${s.length} REAL API calls for template trial`),s}async generateSpreadsheetApiCalls(e,t,a){var m;if(!t)return[];const s=[];let i=0;const n=await o.variableLists.get(t.datasetId);if(!n||n.category!=="tabular"||!((m=n.tabularData)!=null&&m.rows))return r.warn(`V4_TRIALS: Dataset ${t.datasetId} not found or invalid`),[];for(let h=0;h<a;h++)for(const p of n.tabularData.rows){const d=this.substituteVariables(t.promptPattern,p);for(let g=0;g<e.configurations.length;g++){const c={id:D("call"),trialId:e.id,configurationIndex:g,order:i++,variables:p,prompt:d,status:"pending",retryCount:0,created:new Date};s.push(c)}}return r.info(`V4_TRIALS: Generated ${s.length} REAL API calls for spreadsheet trial`),s}async generateVariableCombinations(e){var m;const t=Object.keys(e).sort();if(t.length===0)return[{variables:{}}];const a={};for(const h of t){const p=e[h];let d=[];const g=p;if(g.snapshot)d=g.snapshot.items.map(c=>({value:c.value,attributes:c.attributes}));else if(p.type==="value"&&p.values)d=p.values.map(c=>({value:c}));else if(p.type==="list"&&p.listId){const c=await o.variableLists.get(p.listId);c&&(c.category==="simple"&&c.values?d=c.values.map(f=>({value:f})):c.category==="attributed"&&c.items?d=c.items.map(f=>({value:f.value||f.name||String(f),attributes:f.attributes||{}})):c.category==="tabular"&&((m=c.tabularData)!=null&&m.rows)&&(d=c.tabularData.rows.map(f=>({value:f.name||f[Object.keys(f)[0]]||String(f)}))))}a[h]=d}const i=t.map(h=>Math.max(a[h].length,1)).reduce((h,p)=>h*p,1),n=[];for(let h=0;h<i;h++){const p={},d={},g={};let c=h;for(let S=t.length-1;S>=0;S--){const E=t[S],l=a[E];if(l.length>0){const u=c%l.length,T=l[u];p[E]=T.value,g[E]=u,T.attributes&&Object.keys(T.attributes).length>0&&(d[E]={...T.attributes}),c=Math.floor(c/l.length)}else p[E]="",g[E]=0}const f={variables:p};Object.keys(d).length>0&&(f.variableAttributes=d),Object.keys(g).length>0&&(f.variableIndices=g),n.push(f)}return n}substituteVariables(e,t){let a=e;for(const[s,i]of Object.entries(t)){const n=new RegExp(`\\{\\{\\s*${s}\\s*\\}\\}`,"g");a=a.replace(n,i)}return a}validateTrialConfig(e){var t;if(!e.name||e.name.trim().length===0)return{ok:!1,error:new Error("Trial name is required")};if(!e.configurations||e.configurations.length===0)return{ok:!1,error:new Error("At least one model configuration is required")};for(const a of e.configurations){if(!k.getProvider(a.provider))return{ok:!1,error:new Error(`Provider not found: ${a.provider}`)};const i=k.validateParameters(a.provider,a.modelId,a.parameters);if(!i.valid)return{ok:!1,error:new Error(`Invalid parameters: ${((t=i.errors)==null?void 0:t.join(", "))||"Validation failed"}`)}}if(e.type==="template"){if(!e.templateConfig||!e.templateConfig.template)return{ok:!1,error:new Error("Template is required for template trials")}}else if(e.type==="spreadsheet"&&(!e.spreadsheetConfig||!e.spreadsheetConfig.promptPattern))return{ok:!1,error:new Error("Prompt pattern is required for spreadsheet trials")};return{ok:!0}}async createConfigurationSnapshots(e){const t=[];for(const a of e){const s=k.getProvider(a.provider);if(!s)throw new Error(`Provider not found: ${a.provider}`);const n=(await o.models.where("provider").equals(a.provider).toArray()).find(h=>h.modelId===a.modelId),m={provider:a.provider,modelId:a.modelId,parameters:a.parameters,providerSnapshot:s,modelSnapshot:n||{id:`${a.provider}:${a.modelId}`,provider:a.provider,modelId:a.modelId,displayName:a.name||a.modelId,enabled:!0,source:"user"}};t.push(m)}return t}async createVariableSnapshots(e){const t={};for(const[a,s]of Object.entries(e)){const i={...s};if(s.type==="value"&&s.values)i.snapshot={source:{type:"direct",snapshotDate:new Date},items:s.values.map(n=>({value:n}))};else if(s.type==="list"&&s.listId){const n=await o.variableLists.get(s.listId);n&&(i.snapshot=await this.snapshotVariableList(n))}t[a]=i}return t}async snapshotVariableList(e){var a,s,i;const t={source:{type:e.category,listId:e.id,listName:e.name,snapshotDate:new Date},items:[]};switch(e.category){case"simple":case"refusal":t.items=((a=e.values)==null?void 0:a.map(n=>({value:n})))||[];break;case"attributed":t.items=((s=e.items)==null?void 0:s.map(n=>({value:n.value,attributes:{...n.attributes}})))||[],t.attributeKeys=[...e.attributeKeys||[]];break;case"tabular":(i=e.tabularData)!=null&&i.rows&&(t.items=e.tabularData.rows.map(n=>({value:n.name||n[Object.keys(n)[0]]||""})));break}return t}}const V=new q,Te=Object.freeze(Object.defineProperty({__proto__:null,V4TrialOperations:q,v4TrialOperations:V},Symbol.toStringTag,{value:"Module"}));function Ee(){const C=N(!1),e=N(!1),t=N(!1),a=N(!1),s=N(null),i=async l=>{C.value=!0,s.value=null;try{r.info("V4_TRIAL_COMMANDS: Creating trial with config:",l);const u=await V.createTrial(l);return u.ok?r.info("V4_TRIAL_COMMANDS: Trial created successfully:",u.value):(s.value=u.error||new Error("Failed to create trial"),r.error("V4_TRIAL_COMMANDS: Create trial failed:",u.error)),u}finally{C.value=!1}},n=async(l,u,T)=>{try{const I=await o.template_prompts.get(l);if(!I)return{ok:!1,error:new Error(`Template not found: ${l}`)};const A={name:T||`${I.name} - ${new Date().toLocaleString()}`,description:I.description,type:"template",configurations:u,repeatCount:1,templateConfig:{template:I.template,templateId:I.id,templateName:I.name,variables:I.variables||{},outputType:I.outputType,extractPattern:I.extractPattern,refusalWords:I.refusalWords?[...I.refusalWords]:void 0,rejectRefusalWords:I.rejectRefusalWords}};return i(A)}catch(I){return r.error("V4_TRIAL_COMMANDS: Failed to create trial from template:",I),{ok:!1,error:I instanceof Error?I:new Error("Failed to create trial from template")}}},m=async(l,u,T,I)=>{try{const A=await o.variableLists.get(u);if(!A||A.category!=="tabular")return{ok:!1,error:new Error(`Dataset not found or not tabular: ${u}`)};const y={name:I||`Spreadsheet Trial - ${new Date().toLocaleString()}`,type:"spreadsheet",configurations:T,spreadsheetConfig:{promptPattern:l,datasetId:u}};return i(y)}catch(A){return r.error("V4_TRIAL_COMMANDS: Failed to create spreadsheet trial:",A),{ok:!1,error:A instanceof Error?A:new Error("Failed to create spreadsheet trial")}}},h=async(l,u)=>{e.value=!0,s.value=null;try{const T=await V.updateTrial(l,u);return T.ok||(s.value=T.error||new Error("Failed to update trial"),r.error("V4_TRIAL_COMMANDS: Update trial failed:",T.error)),T}finally{e.value=!1}},p=async(l,u)=>h(l,{status:u}),d=async l=>{t.value=!0,s.value=null;try{r.info("V4_TRIAL_COMMANDS: Deleting trial:",l);const u=await V.deleteTrial(l);return u.ok?r.info("V4_TRIAL_COMMANDS: Trial deleted successfully"):(s.value=u.error||new Error("Failed to delete trial"),r.error("V4_TRIAL_COMMANDS: Delete trial failed:",u.error)),u}finally{t.value=!1}},g=async l=>{t.value=!0,s.value=null;try{return r.info("V4_TRIAL_COMMANDS: Deleting multiple trials:",l.length),await o.transaction("rw",o.trials,o.apiCalls,async()=>{for(const u of l){const T=await o.trials.get(u);T&&T.status!=="running"&&(await o.apiCalls.where("trialId").equals(u).delete(),await o.trials.delete(u))}}),r.info("V4_TRIAL_COMMANDS: Multiple trials deleted successfully"),{ok:!0}}catch(u){return r.error("V4_TRIAL_COMMANDS: Failed to delete multiple trials:",u),s.value=u instanceof Error?u:new Error("Failed to delete trials"),{ok:!1,error:s.value}}finally{t.value=!1}},c=async l=>{a.value=!0,s.value=null;try{r.info("V4_TRIAL_COMMANDS: Duplicating trial:",l);const u=await V.duplicateTrial(l);return u.ok?r.info("V4_TRIAL_COMMANDS: Trial duplicated successfully:",u.value):(s.value=u.error||new Error("Failed to duplicate trial"),r.error("V4_TRIAL_COMMANDS: Duplicate trial failed:",u.error)),u}finally{a.value=!1}},f=async l=>{var u,T;try{let I=1;if(l.type==="template"&&l.templateConfig){const y=l.templateConfig.variables;for(const[,R]of Object.entries(y))if(R.type==="value"&&R.values)I*=R.values.length;else if(R.type==="list"&&R.listId){const O=await o.variableLists.get(R.listId);O&&(O.category==="simple"&&O.values?I*=O.values.length:O.category==="attributed"&&O.items?I*=O.items.length:O.category==="tabular"&&((u=O.tabularData)!=null&&u.rows)&&(I*=O.tabularData.rows.length))}}else if(l.type==="spreadsheet"&&l.spreadsheetConfig){const y=await o.variableLists.get(l.spreadsheetConfig.datasetId);y&&y.category==="tabular"&&((T=y.tabularData)!=null&&T.rows)&&(I=y.tabularData.rows.length)}return I*l.configurations.length*(l.repeatCount||1)}catch(I){return r.error("V4_TRIAL_COMMANDS: Failed to calculate API call count:",I),0}};return{createTrial:i,createTrialFromTemplate:n,createTrialFromSpreadsheet:m,updateTrial:h,updateTrialStatus:p,deleteTrial:d,deleteMultipleTrials:g,duplicateTrial:c,generateApiCallCount:f,estimateTrialCost:async l=>{var u,T;try{const I=await f(l);let A=0;for(const y of l.configurations){const O=(await o.models.where("provider").equals(y.provider).toArray()).find(P=>P.modelId===y.modelId);if(O!=null&&O.capabilities){const W=((u=y.parameters)==null?void 0:u.max_tokens)||((T=y.parameters)==null?void 0:T.maxTokens)||256,X=(O.capabilities.inputCostPerToken||0)*150,j=(O.capabilities.outputCostPerToken||0)*W;A+=(X+j)*I/l.configurations.length}}return A}catch(I){return r.error("V4_TRIAL_COMMANDS: Failed to estimate cost:",I),0}},validateTrialConfig:l=>!l.name||l.name.trim().length===0?{ok:!1,error:new Error("Trial name is required")}:!l.configurations||l.configurations.length===0?{ok:!1,error:new Error("At least one model configuration is required")}:l.type==="template"&&!l.templateConfig?{ok:!1,error:new Error("Template configuration is required for template trials")}:l.type==="spreadsheet"&&!l.spreadsheetConfig?{ok:!1,error:new Error("Spreadsheet configuration is required for spreadsheet trials")}:{ok:!0},isCreating:C,isUpdating:e,isDeleting:t,isDuplicating:a,lastError:s}}export{Ee as a,me as b,he as c,pe as u,Te as v};
