import{p as f,a as H,b as x}from"./index-CLqmclCd.js";import{Q as J,f as c,c as d}from"./vue-vendor-DPw1dQYc.js";const N=J("parsers",()=>{const t=c([]),u=c(!1),i=c(null),p=c(""),y=c("all"),l=c(null),h=c(null),m=d(()=>t.value.filter(e=>e.isBuiltIn)),g=d(()=>t.value.filter(e=>!e.isBuiltIn)),F=d(()=>t.value.filter(e=>e.isPublic&&!e.isBuiltIn)),B=d(()=>{let e=t.value;if(y.value!=="all"&&(e=e.filter(a=>a.type===y.value)),p.value){const a=p.value.toLowerCase();e=e.filter(r=>r.name.toLowerCase().includes(a)||r.description?.toLowerCase().includes(a)||r.tags.some(s=>s.toLowerCase().includes(a)))}return e}),w=d(()=>({regex:t.value.filter(e=>e.type==="regex"),javascript:t.value.filter(e=>e.type==="javascript"),python:t.value.filter(e=>e.type==="python")})),C=d(()=>({total:t.value.length,builtIn:m.value.length,user:g.value.length,regex:w.value.regex.length,javascript:w.value.javascript.length,python:w.value.python.length}));async function P(){u.value=!0,l.value=null;try{await f.initializeDefaults(),t.value=await f.getAll()}catch(e){l.value=e instanceof Error?e.message:"Failed to load parsers",H.error("Failed to load parsers:",e)}finally{u.value=!1}}async function E(e){u.value=!0,l.value=null;try{const a=await f.create(e);if(a.ok&&a.data){const r=a.data,s=[...t.value,r].sort((o,n)=>o.isBuiltIn!==n.isBuiltIn?o.isBuiltIn?-1:1:o.name.localeCompare(n.name));return t.value=s,i.value=r,r}else throw a.error||new Error("Failed to create parser")}catch(a){throw l.value=a instanceof Error?a.message:"Failed to create parser",a}finally{u.value=!1}}async function S(e,a){u.value=!0,l.value=null;try{const r=await f.update(e,a);if(r.ok&&r.data){const s=r.data,o=t.value.findIndex(n=>n.id===e);if(o!==-1){const n=[...t.value];n[o]=s,t.value[o].name!==s.name&&n.sort((v,I)=>v.isBuiltIn!==I.isBuiltIn?v.isBuiltIn?-1:1:v.name.localeCompare(I.name)),t.value=n}return i.value?.id===e&&(i.value=s),s}else throw r.error||new Error("Failed to update parser")}catch(r){throw l.value=r instanceof Error?r.message:"Failed to update parser",r}finally{u.value=!1}}async function j(e){u.value=!0,l.value=null;try{const a=await f.delete(e);if(a.ok)t.value=t.value.filter(r=>r.id!==e),i.value?.id===e&&(i.value=null);else throw a.error||new Error("Failed to delete parser")}catch(a){throw l.value=a instanceof Error?a.message:"Failed to delete parser",a}finally{u.value=!1}}async function k(e,a){u.value=!0,l.value=null;try{const r=await f.duplicate(e,a);if(r.ok&&r.data){const s=r.data,o=[...t.value,s].sort((n,v)=>n.isBuiltIn!==v.isBuiltIn?n.isBuiltIn?-1:1:n.name.localeCompare(v.name));return t.value=o,i.value=s,s}else throw r.error||new Error("Failed to duplicate parser")}catch(r){throw l.value=r instanceof Error?r.message:"Failed to duplicate parser",r}finally{u.value=!1}}async function L(e,a){try{return await x.test(e,a)}catch(r){throw l.value=r instanceof Error?r.message:"Failed to test parser",r}}async function Q(e,a){try{return await x.execute(e,a)}catch(r){throw l.value=r instanceof Error?r.message:"Failed to execute parser",r}}function b(e){i.value=e}function z(e){p.value=e}function T(e){y.value=e}function q(){l.value=null}function A(e){h.value=e}function D(){return h.value}function O(){h.value=null}async function G(){t.value.length===0&&await P()}return{parsers:t,loading:u,selectedParser:i,searchQuery:p,typeFilter:y,error:l,selectionContext:h,builtInParsers:m,userParsers:g,publicParsers:F,filteredParsers:B,parsersByType:w,parserCount:C,loadParsers:P,createParser:E,updateParser:S,deleteParser:j,duplicateParser:k,testParser:L,executeParser:Q,selectParser:b,setSearchQuery:z,setTypeFilter:T,clearError:q,setSelectionContext:A,getSelectionContext:D,clearSelectionContext:O,initialize:G}});export{N as u};
