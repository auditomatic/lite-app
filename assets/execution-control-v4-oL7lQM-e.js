const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/trial-stream-manager-v4-B1Pw328z.js","assets/index-CdMJKGfq.js","assets/vue-vendor-DPw1dQYc.js","assets/ui-vendor-IRGmExUJ.js","assets/utils-vendor-B76-F3_P.js","assets/tauri-vendor-1uBLmS9u.js","assets/index-gxIXtJdR.css"])))=>i.map(i=>d[i]);
var v=Object.defineProperty;var U=(T,t,r)=>t in T?v(T,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):T[t]=r;var c=(T,t,r)=>U(T,typeof t!="symbol"?t+"":t,r);import{a as e,d as u,i as y,P as b,m as C,n as A,_ as L}from"./index-CdMJKGfq.js";import{r as N,c as d}from"./vue-vendor-DPw1dQYc.js";import{s as w,a as $,S as V,R as P,m as x}from"./utils-vendor-B76-F3_P.js";class k{constructor(){c(this,"state",N({status:"idle",trialId:null,orchestratorType:null,startedAt:null,pausedAt:null,completedAt:null,tabId:null}));c(this,"currentState",d(()=>({...this.state})));c(this,"status",d(()=>this.state.status));c(this,"trialId",d(()=>this.state.trialId));c(this,"orchestratorType",d(()=>this.state.orchestratorType));c(this,"isExecuting",d(()=>["starting","running","pausing"].includes(this.state.status)));c(this,"isPaused",d(()=>this.state.status==="paused"));c(this,"isIdle",d(()=>this.state.status==="idle"))}async hydrate(){e.info("STATE_MACHINE: Hydrating state from database...");const t=await u.trials.where("status").equals("running").toArray();if(t.length>0){e.info(`STATE_MACHINE: Found ${t.length} running trials, marking as paused (page refreshed)`);for(const r of t)await u.trials.update(r.id,{status:"paused"}),e.info(`STATE_MACHINE: Paused trial ${r.id} (was running, page refreshed)`)}e.info("STATE_MACHINE: State machine starting idle - use resume to continue paused trials")}async startExecution(t,r,a){if(e.info(`STATE_MACHINE: Starting execution - trial=${t}, orchestrator=${r}, tab=${a}`),this.state.status!=="idle"&&this.state.status!=="paused"){let i="Cannot start trial: ";return this.state.status==="running"?i+=`Another trial is currently running (${this.state.trialId}). Please wait for it to complete or pause it first.`:this.state.status==="starting"?i+="A trial is currently starting. Please wait a moment and try again.":this.state.status==="cancelling"?i+="A trial is currently being cancelled. Please wait for it to finish.":i+=`System is in ${this.state.status} state. Please refresh the page if this persists.`,{ok:!1,error:new Error(i)}}try{return this.state.status="starting",this.state.trialId=t,this.state.orchestratorType=r,this.state.tabId=a,this.state.startedAt=new Date,this.state.pausedAt=null,this.state.completedAt=null,await u.trials.update(t,{status:"running",started:this.state.startedAt}),this.state.status="running",e.info(`STATE_MACHINE: Successfully started execution for trial ${t}`),{ok:!0,value:void 0}}catch(i){return this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,{ok:!1,error:i instanceof Error?i:new Error("Failed to start execution")}}}async pauseExecution(){if(e.info(`STATE_MACHINE: Pausing execution - current status=${this.state.status}`),this.state.status!=="running")return{ok:!1,error:new Error(`Cannot pause: current status is ${this.state.status}`)};if(!this.state.trialId)return{ok:!1,error:new Error("Cannot pause: no active trial")};try{return this.state.status="pausing",this.state.pausedAt=new Date,await u.trials.update(this.state.trialId,{status:"paused"}),this.state.status="paused",e.info(`STATE_MACHINE: Successfully paused execution for trial ${this.state.trialId}`),{ok:!0,value:void 0}}catch(t){return this.state.status="running",this.state.pausedAt=null,{ok:!1,error:t instanceof Error?t:new Error("Failed to pause execution")}}}async resumeExecution(t,r){if(e.info(`STATE_MACHINE: Resuming trial ${t} - current status=${this.state.status}, tab=${r}`),!["idle","paused"].includes(this.state.status))return{ok:!1,error:new Error(`Cannot resume: current status is ${this.state.status}`)};try{const a=await u.trials.get(t);if(!a)return{ok:!1,error:new Error(`Trial ${t} not found`)};if(a.status!=="paused")return{ok:!1,error:new Error(`Cannot resume: trial status is ${a.status}, expected paused`)};const i=a.type==="playground"?"streaming":"regular";return this.state.status="running",this.state.trialId=t,this.state.orchestratorType=i,this.state.tabId=r,this.state.startedAt=a.started||new Date,this.state.pausedAt=null,this.state.completedAt=null,await u.trials.update(t,{status:"running"}),e.info(`STATE_MACHINE: Successfully resumed execution for trial ${t}`),{ok:!0,value:void 0}}catch(a){return this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,this.state.pausedAt=null,{ok:!1,error:a instanceof Error?a:new Error("Failed to resume execution")}}}async cancelExecution(){if(e.info(`STATE_MACHINE: Cancelling execution - current status=${this.state.status}`),!["running","paused","starting"].includes(this.state.status))return{ok:!1,error:new Error(`Cannot cancel: current status is ${this.state.status}`)};if(!this.state.trialId)return{ok:!1,error:new Error("Cannot cancel: no active trial")};try{const t=this.state.trialId;return this.state.status="cancelling",this.state.completedAt=new Date,await u.trials.update(t,{status:"cancelled",completed:this.state.completedAt}),this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,this.state.pausedAt=null,e.info(`STATE_MACHINE: Successfully cancelled execution for trial ${t}`),{ok:!0,value:void 0}}catch(t){return this.state.status=this.state.pausedAt?"paused":"running",this.state.completedAt=null,{ok:!1,error:t instanceof Error?t:new Error("Failed to cancel execution")}}}async completeExecution(){if(e.info(`STATE_MACHINE: Completing execution - current status=${this.state.status}`),!["running","paused"].includes(this.state.status))return{ok:!1,error:new Error(`Cannot complete: current status is ${this.state.status}`)};if(!this.state.trialId)return{ok:!1,error:new Error("Cannot complete: no active trial")};try{const t=this.state.trialId;return this.state.status="completed",this.state.completedAt=new Date,await u.trials.update(t,{status:"completed",completed:this.state.completedAt}),this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,this.state.pausedAt=null,e.info(`STATE_MACHINE: Successfully completed execution for trial ${t}`),{ok:!0,value:void 0}}catch(t){return this.state.status="running",this.state.completedAt=null,{ok:!1,error:t instanceof Error?t:new Error("Failed to complete execution")}}}canStart(){return this.state.status==="idle"||this.state.status==="paused"}canPause(){return this.state.status==="running"}canResume(){return this.state.status==="paused"&&this.state.orchestratorType!==null}canCancel(){return["running","paused","starting"].includes(this.state.status)}isOwnedByTab(t){return this.state.tabId===t}}const o=new k;class D{constructor(){c(this,"state",N({tabId:y("tab"),role:"observer",isInitialized:!1,lastHeartbeat:new Date}));c(this,"broadcastChannel",null);c(this,"lockReleaseFunction",null);c(this,"heartbeatInterval",null);c(this,"tabId",d(()=>this.state.tabId));c(this,"role",d(()=>this.state.role));c(this,"isLeader",d(()=>this.state.role==="leader"));c(this,"isObserver",d(()=>this.state.role==="observer"));c(this,"isInitialized",d(()=>this.state.isInitialized))}async initialize(){if(this.state.isInitialized){e.info(`COORDINATION: Tab ${this.state.tabId} already initialized as ${this.state.role}`);return}e.info(`COORDINATION: Initializing tab ${this.state.tabId}`);try{this.broadcastChannel=new BroadcastChannel("auditomatic-coordination"),this.broadcastChannel.onmessage=t=>{this.handleCoordinationMessage(t.data)},await this.attemptLeadershipAcquisition(),this.startHeartbeat(),this.state.isInitialized=!0,e.info(`COORDINATION: Tab ${this.state.tabId} initialized as ${this.state.role}`)}catch(t){throw e.error(`COORDINATION: Failed to initialize tab ${this.state.tabId}:`,t),t}}async attemptLeadershipAcquisition(){if(!("locks"in navigator)){e.info(`COORDINATION: Web Locks not available, tab ${this.state.tabId} becomes leader`),this.state.role="leader";return}try{e.info(`COORDINATION: Tab ${this.state.tabId} attempting to acquire leadership lock`),navigator.locks.request("auditomatic-leader",{mode:"exclusive",ifAvailable:!0},t=>{if(t)return e.info(`COORDINATION: Tab ${this.state.tabId} acquired leadership lock`),this.state.role="leader",new Promise(r=>{this.lockReleaseFunction=r});e.info(`COORDINATION: Tab ${this.state.tabId} could not acquire lock - observer mode`),this.state.role="observer"}),await new Promise(t=>setTimeout(t,50))}catch(t){e.error(`COORDINATION: Leadership acquisition failed for tab ${this.state.tabId}:`,t),this.state.role="observer"}}startHeartbeat(){this.heartbeatInterval=setInterval(()=>{this.state.lastHeartbeat=new Date,this.broadcast({type:"heartbeat",tabId:this.state.tabId,timestamp:this.state.lastHeartbeat})},1e4)}broadcast(t){this.broadcastChannel&&(e.info(`COORDINATION: Broadcasting ${t.type} from tab ${this.state.tabId}`),this.broadcastChannel.postMessage(t))}handleCoordinationMessage(t){if(t.tabId!==this.state.tabId)switch(e.info(`COORDINATION: Tab ${this.state.tabId} received ${t.type} from ${t.tabId}`),t.type){case"execution:started":this.state.role==="observer"&&t.trialId&&e.info(`COORDINATION: Observer tab syncing to started execution: ${t.trialId}`);break;case"execution:paused":this.state.role==="observer"&&t.trialId&&e.info(`COORDINATION: Observer tab syncing to paused execution: ${t.trialId}`);break;case"execution:resumed":this.state.role==="observer"&&t.trialId&&e.info(`COORDINATION: Observer tab syncing to resumed execution: ${t.trialId}`);break;case"execution:cancelled":case"execution:completed":this.state.role==="observer"&&t.trialId&&e.info(`COORDINATION: Observer tab syncing to ended execution: ${t.trialId}`);break;case"heartbeat":e.info(`COORDINATION: Heartbeat from ${t.tabId}`);break}}canExecuteActions(){return this.state.role==="leader"}validateLeadership(t){return this.state.role!=="leader"?{ok:!1,error:new Error(`Cannot ${t}: only leader tab can execute actions`)}:{ok:!0,value:void 0}}async startExecution(t,r){const a=this.validateLeadership("start execution");if(!a.ok)return a;e.info(`COORDINATION: Leader starting execution - trial=${t}, orchestrator=${r}`);const i=await o.startExecution(t,r,this.state.tabId);return i.ok&&this.broadcast({type:"execution:started",tabId:this.state.tabId,timestamp:new Date,trialId:t,orchestratorType:r}),i}async pauseExecution(){const t=this.validateLeadership("pause execution");if(!t.ok)return t;e.info("COORDINATION: Leader pausing execution");const r=await o.pauseExecution();return r.ok&&this.broadcast({type:"execution:paused",tabId:this.state.tabId,timestamp:new Date,trialId:o.trialId.value||void 0}),r}async resumeExecution(t){const r=this.validateLeadership("resume execution");if(!r.ok)return r;e.info(`COORDINATION: Leader resuming execution for trial ${t}`);const a=await o.resumeExecution(t,this.state.tabId);return a.ok&&this.broadcast({type:"execution:resumed",tabId:this.state.tabId,timestamp:new Date,trialId:t}),a}async cancelExecution(){const t=this.validateLeadership("cancel execution");if(!t.ok)return t;e.info("COORDINATION: Leader cancelling execution");const r=o.trialId.value,a=await o.cancelExecution();return a.ok&&this.broadcast({type:"execution:cancelled",tabId:this.state.tabId,timestamp:new Date,trialId:r||void 0}),a}async completeExecution(){const t=this.validateLeadership("complete execution");if(!t.ok)return t;e.info("COORDINATION: Leader completing execution");const r=o.trialId.value,a=await o.completeExecution();return a.ok&&this.broadcast({type:"execution:completed",tabId:this.state.tabId,timestamp:new Date,trialId:r||void 0}),a}destroy(){e.info(`COORDINATION: Destroying tab ${this.state.tabId}`),this.heartbeatInterval&&(clearInterval(this.heartbeatInterval),this.heartbeatInterval=null),this.lockReleaseFunction&&(this.lockReleaseFunction(),this.lockReleaseFunction=null),this.broadcastChannel&&(this.broadcastChannel.close(),this.broadcastChannel=null),this.state.isInitialized=!1,e.info(`COORDINATION: Tab ${this.state.tabId} cleanup complete`)}}const E=new D;class M{async updateTrial(t){e.info(`ATOMIC_OPS: Updating trial ${t.trialId} - status=${t.status}`);try{const r={};return t.status!==void 0&&(r.status=t.status),t.started!==void 0&&(r.started=t.started),t.completed!==void 0&&(r.completed=t.completed),t.progress!==void 0&&(r.progress=t.progress),await u.trials.update(t.trialId,r),e.info(`ATOMIC_OPS: Successfully updated trial ${t.trialId}`),{ok:!0,value:void 0}}catch(r){return e.error(`ATOMIC_OPS: Failed to update trial ${t.trialId}:`,r),{ok:!1,error:r instanceof Error?r:new Error("Failed to update trial")}}}async resetRunningCallsToPending(t){e.info(`ATOMIC_OPS: Resetting running calls to pending for trial ${t}`);try{const r=await u.apiCalls.where("trialId").equals(t).and(a=>a.status==="running").toArray();return r.length===0?e.info(`ATOMIC_OPS: No running calls found for trial ${t}`):(await u.transaction("rw",u.apiCalls,async()=>{for(const a of r)await u.apiCalls.update(a.id,{status:"pending",started:void 0,response:void 0,result:void 0})}),e.info(`ATOMIC_OPS: Reset ${r.length} running calls to pending for trial ${t}`)),e.info("V4_TRIAL_DEBUG_PAUSE: Recalculating trial progress after call status changes"),await this.recalculateTrialProgress(t),{ok:!0,value:r.length}}catch(r){return e.error(`ATOMIC_OPS: Failed to reset running calls for trial ${t}:`,r),{ok:!1,error:r instanceof Error?r:new Error("Failed to reset running calls")}}}async getTrialCallCounts(t){e.info(`ATOMIC_OPS: Getting call counts for trial ${t}`);try{const r=await u.transaction("r",u.apiCalls,async()=>{const a=await u.apiCalls.where("trialId").equals(t).toArray();return{total:a.length,completed:a.filter(i=>i.status==="completed").length,failed:a.filter(i=>i.status==="failed").length,cancelled:a.filter(i=>i.status==="cancelled").length,pending:a.filter(i=>i.status==="pending").length,running:a.filter(i=>i.status==="running").length}});return e.info(`TRANSACTION_FIX: Trial ${t} call counts (consistent snapshot):`,r),{ok:!0,value:r}}catch(r){return e.error(`ATOMIC_OPS: Failed to get call counts for trial ${t}:`,r),{ok:!1,error:r instanceof Error?r:new Error("Failed to get call counts")}}}async updateApiCallsBatch(t){if(t.length===0)return{ok:!0,value:void 0};e.info(`ATOMIC_OPS: Updating batch of ${t.length} API calls`);try{return await u.transaction("rw",u.apiCalls,async()=>{for(const r of t){const a={status:r.status};r.started!==void 0&&(a.started=r.started),r.completed!==void 0&&(a.completed=r.completed),r.response!==void 0&&(a.response=r.response),r.error!==void 0&&(a.error=r.error),await u.apiCalls.update(r.callId,a)}}),e.info(`ATOMIC_OPS: Successfully updated batch of ${t.length} API calls`),{ok:!0,value:void 0}}catch(r){return e.error("ATOMIC_OPS: Failed to update API calls batch:",r),{ok:!1,error:r instanceof Error?r:new Error("Failed to update API calls batch")}}}async reconcileTrialState(t){e.info(`ATOMIC_OPS: Reconciling state for trial ${t}`);try{const r=await u.trials.get(t);if(!r)return{ok:!1,error:new Error(`Trial ${t} not found`)};const a=await this.getTrialCallCounts(t);if(!a.ok)return a;const i=a.value;let s=r.status;if(i.running>0?s="running":i.pending>0?s="paused":i.completed===i.total&&i.total>0||i.failed>0&&i.completed+i.failed===i.total?s="completed":i.cancelled>0&&(s="cancelled"),s!==r.status){e.info(`ATOMIC_OPS: Reconciling trial ${t} status: ${r.status} → ${s}`);const n=await this.updateTrial({trialId:t,status:s,progress:i,...s==="completed"&&{completed:new Date}});if(!n.ok)return n}else e.info(`ATOMIC_OPS: Trial ${t} status is consistent: ${s}`);return{ok:!0,value:s}}catch(r){return e.error(`ATOMIC_OPS: Failed to reconcile trial ${t} state:`,r),{ok:!1,error:r instanceof Error?r:new Error("Failed to reconcile trial state")}}}async performCleanupOperations(t){e.info(`ATOMIC_OPS: Performing cleanup operations for trial ${t}`);try{const r=await this.resetRunningCallsToPending(t);if(!r.ok)return r;const a=await this.reconcileTrialState(t);if(!a.ok)return a;const i={resetCount:r.value,reconciledStatus:a.value};return e.info(`ATOMIC_OPS: Cleanup complete for trial ${t}:`,i),{ok:!0,value:i}}catch(r){return e.error(`ATOMIC_OPS: Failed cleanup operations for trial ${t}:`,r),{ok:!1,error:r instanceof Error?r:new Error("Failed cleanup operations")}}}async recalculateTrialProgress(t){try{const r=await u.trials.get(t);if(!r){e.info(`V4_TRIAL_DEBUG_PAUSE: Trial ${t} not found, cannot recalculate progress`);return}const a=await u.apiCalls.where("trialId").equals(t).toArray();let i=0,s=0,n=0,h=0,p=0;for(const O of a)switch(O.status){case"completed":i++;break;case"failed":s++,O.result?.errorType==="network_error_no_response"&&p++;break;case"cancelled":n++;break;case"running":h++;break}const _=r.progress.total-i-s-n-h,I={total:r.progress.total,completed:i,failed:s,cancelled:n,pending:_,running:h,networkErrors:p};e.info(`V4_TRIAL_DEBUG_PAUSE: Recalculated progress for trial ${t} - completed: ${i}, failed: ${s}, running: ${h}, pending: ${_}`),await u.trials.update(t,{progress:I}),e.info("V4_TRIAL_DEBUG_PAUSE: Trial progress updated successfully")}catch(r){e.error(`V4_TRIAL_DEBUG_PAUSE: Failed to recalculate progress for trial ${t}:`,r)}}async performSystemCleanup(){e.info("ATOMIC_OPS: Performing system-wide cleanup");try{let t=0,r=0;const a=await u.trials.where("status").equals("running").toArray();e.info(`ATOMIC_OPS: Found ${a.length} active trials for cleanup`);for(const s of a){const n=await this.performCleanupOperations(s.id);if(n.ok)t+=n.value.resetCount,r++;else{const h=n;e.warn(`ATOMIC_OPS: Failed to cleanup trial ${s.id}:`,h.error.message)}}const i={trialsProcessed:r,callsReset:t};return e.info("ATOMIC_OPS: System cleanup complete:",i),{ok:!0,value:i}}catch(t){return e.error("ATOMIC_OPS: System cleanup failed:",t),{ok:!1,error:t instanceof Error?t:new Error("System cleanup failed")}}}}const S=new M;class G{constructor(){c(this,"playgroundService",null);c(this,"initialized",!1);c(this,"orchestrators",new Map);c(this,"activeStreams",new Map);c(this,"execution",d(()=>{const t=o.status.value;let r="idle";return t==="running"||t==="starting"||t==="pausing"?r="executing":t==="paused"?r="paused":r="idle",{status:r,currentTrialId:o.trialId.value,startedAt:o.currentState.value.startedAt}}));c(this,"progress",d(()=>({trials:new Map,activeApiCall:null,lastUpdated:new Date})));c(this,"queue",d(()=>({global:{pending:0,executing:0,capacity:0,utilization:0},providers:new Map})));c(this,"tabRole",d(()=>E.role.value));c(this,"isLeader",d(()=>E.isLeader.value));c(this,"canExecute",d(()=>E.isLeader.value&&o.canStart()))}async initialize(){const t=performance.now();if(e.info(`V4_TRIAL_SWITCH: V4ExecutionControl initialize() ENTRY at ${t}`),e.info(`V4_SINGLETON_DEBUG: Current initialized flag: ${this.initialized}`),e.info(`V4_SINGLETON_DEBUG: Active streams count: ${this.activeStreams.size}`),this.initialized){e.info("V4_SINGLETON_DEBUG: V4ExecutionControl already initialized, returning early - singleton working correctly!");return}try{e.info("V4_EXECUTION_CONTROL: Initializing with V4 coordination + V3 execution bridge");const r=performance.now();e.info(`V4_TRIAL_SWITCH: Starting multiTabCoordinator.initialize() at ${(r-t).toFixed(1)}ms`),await E.initialize();const a=performance.now();e.info(`V4_TRIAL_SWITCH: multiTabCoordinator.initialize() completed in ${(a-r).toFixed(1)}ms`),e.info("V4_EXECUTION_CONTROL: Performing system cleanup with V4 atomic operations");const i=performance.now();e.info(`V4_TRIAL_SWITCH: Starting atomicOperations.performSystemCleanup() at ${(i-t).toFixed(1)}ms`);const s=await S.performSystemCleanup(),n=performance.now();if(e.info(`V4_TRIAL_SWITCH: atomicOperations.performSystemCleanup() completed in ${(n-i).toFixed(1)}ms`),s.ok)e.info("V4_EXECUTION_CONTROL: System cleanup completed:",s.value);else{const I=s;e.warn("V4_EXECUTION_CONTROL: System cleanup failed:",I.error)}const h=performance.now();e.info(`V4_TRIAL_SWITCH: Creating PlaygroundExecutionService at ${(h-t).toFixed(1)}ms`),this.playgroundService=new b(async I=>{const O=await this.startTrialWithStreaming(I);return O.ok?{ok:!0,value:O.value.progress$}:O});const p=performance.now();e.info(`V4_TRIAL_SWITCH: PlaygroundExecutionService created in ${(p-h).toFixed(1)}ms`),this.initialized=!0;const _=performance.now();e.info(`V4_TRIAL_SWITCH: V4ExecutionControl initialization TOTAL: ${(_-t).toFixed(1)}ms`),e.info("V4_EXECUTION_CONTROL: Initialization complete")}catch(r){const a=performance.now();throw e.error(`V4_TRIAL_SWITCH: V4ExecutionControl initialization FAILED in ${(a-t).toFixed(1)}ms:`,r),r}}cleanup(){e.info("V4_SINGLETON_DEBUG: cleanup() called - this will reset initialized flag and destroy singleton!"),e.info(`V4_SINGLETON_DEBUG: Current active streams: ${this.activeStreams.size}`),e.info(`V4_SINGLETON_DEBUG: Current orchestrators: ${this.orchestrators.size}`);try{this.activeStreams.forEach((t,r)=>{e.info(`V4_SINGLETON_DEBUG: Cleaning up streams for trial ${r}`),t.subscription.unsubscribe()}),this.activeStreams.clear(),this.orchestrators.forEach((t,r)=>{e.info(`V4_SINGLETON_DEBUG: Cleaning up orchestrator for trial ${r}`)}),this.orchestrators.clear(),E.destroy(),this.playgroundService=null,this.initialized=!1,e.info("V4_SINGLETON_DEBUG: Cleanup complete - singleton destroyed, will reinitialize on next call")}catch(t){e.error("V4_EXECUTION_CONTROL: Cleanup error:",t)}}async startTrial(t){this.initialized||await this.initialize(),e.info(`V4_EXECUTION_CONTROL: Starting trial ${t} with V4+V3 bridge`);try{if(C(t)){const n=await(this.playgroundService?.executePlaygroundCall("",{})||Promise.resolve({ok:!1,error:new Error("Playground service not available")}));return n.ok?{ok:!0,value:void 0}:{ok:!1,error:n.error}}let a=this.orchestrators.get(t);a||(e.info("PAUSE_RESUME_BUG: V4_EXECUTION_CONTROL: Creating fresh V3 orchestrator for trial:",t),a=A(),e.info("PAUSE_RESUME_BUG: V4_EXECUTION_CONTROL: Orchestrator created and stored in map"),this.orchestrators.set(t,a));const s=await a.startTrialAtomic(t);return s.ok?(e.info(`V4_EXECUTION_CONTROL: Successfully started trial ${t} via bridge`),{ok:!0,value:void 0}):{ok:!1,error:s.error}}catch(r){return e.error(`V4_EXECUTION_CONTROL: Failed to start trial ${t}:`,r),{ok:!1,error:r instanceof Error?r:new Error("Failed to start trial")}}}async startTrialWithStreaming(t){this.initialized||await this.initialize(),e.info(`V4_EXECUTION_CONTROL: Starting streaming trial ${t}`),this.cleanupStreams(t);try{if(C(t))return e.info("V4_EXECUTION_CONTROL: Playground trial detected, using specialized handling"),{ok:!1,error:new Error("Playground streaming not yet implemented in V4")};if(!this.canExecute.value){e.info("V4_EXECUTION_CONTROL: Cannot start - not leader or invalid state");let l="Cannot start trial: ";return this.isLeader.value?this.execution.value.status==="executing"?l+="Another trial is currently running. Please wait for it to complete or pause it first.":this.execution.value.status==="paused"?l+="A trial is currently paused. Resume or cancel it before starting a new one.":l+="This tab is in observer mode. Only the controlling tab can start trials.":l+="Another browser tab is currently controlling trial execution. Close other tabs or wait for them to finish.",{ok:!1,error:new Error(l)}}e.info("V4_EXECUTION_CONTROL: Updating state machine to running");const a=E.tabId.value,i=await o.startExecution(t,"streaming",a);if(!i.ok)return e.info("V4_EXECUTION_CONTROL: State machine update failed:",i.error),{ok:!1,error:i.error};for(const[l,f]of this.orchestrators)if(l!==t){const g=C(l),m=C(t);if(g&&m){e.info(`ORCHESTRATOR_CLEANUP: Preserving playground orchestrator ${l} while starting ${t}`);continue}else if(g&&!m){e.info(`ORCHESTRATOR_CLEANUP: Preserving playground orchestrator ${l} while starting real trial ${t}`);continue}else if(!g&&m){e.info(`ORCHESTRATOR_CLEANUP: Preserving real trial orchestrator ${l} while starting playground ${t}`);continue}else e.info(`ORCHESTRATOR_CLEANUP: Cleaning up real trial orchestrator ${l} before starting ${t}`),f.cancelTrial(),typeof f.resetState=="function"&&f.resetState(),this.orchestrators.delete(l)}let s=this.orchestrators.get(t);s||(e.info("PAUSE_RESUME_BUG: V4_EXECUTION_CONTROL: Creating fresh V3 orchestrator for trial:",t),s=A(),e.info("PAUSE_RESUME_BUG: V4_EXECUTION_CONTROL: Orchestrator created and stored in map"),this.orchestrators.set(t,s)),e.info("V4_EXECUTION_CONTROL: Calling V3 orchestrator startTrialAtomicWithStreaming");const n=await s.startTrialAtomicWithStreaming(t);if(!n.ok)return{ok:!1,error:n.error};e.info("V4_EXECUTION_CONTROL: Creating hot observables without accumulation"),e.info(`V4_EXECUTION_CONTROL: Creating hot observables for trial ${t}`);const h=n.value.progress$.pipe(w(),$({bufferSize:1,refCount:!0})),p=new V,_=new P(1),I=n.value.calls$.pipe(x(l=>(e.info(`V4_EXECUTION_CONTROL: Batch of ${l.length} calls from pipeline`),l.map(f=>f.call&&f.providerId?f.call:f)))).subscribe({next:l=>{e.info(`V4_EXECUTION_CONTROL: Forwarding ${l.length} calls to subject`),_.next(l)},error:l=>{e.info("V4_TRIAL_ERROR: Error in calls stream:",l),_.error(l)},complete:()=>{e.info(`V4_TRIAL_COMPLETE: Original calls stream completed for trial ${t}`)}});p.add(I);const O=_;return e.info("V4_TRIAL_REF_TEST: callsSubject === sharedCalls$?",_===O),p.add(h.subscribe({next:l=>{e.info(`V4_TRIAL_DEBUG_COMPLETION: Progress update for trial ${t}: ${l.type}`),(l.type==="completed"||l.type==="error")&&(e.info(`V4_TRIAL_DEBUG_COMPLETION: Trial ${t} ${l.type}, scheduling cleanup in 1000ms`),e.info(`V4_TRIAL_DEBUG_COMPLETION: Current execution state: ${o.status.value}`),e.info("V4_TRIAL_DEBUG_COMPLETION: Updating V4 coordination layer to completed/cancelled state"),l.type==="completed"?(e.info("V4_TRIAL_DEBUG_COMPLETION: Calling multiTabCoordinator.completeExecution()"),E.completeExecution().then(f=>{f.ok?(e.info("V4_TRIAL_DEBUG_COMPLETION: Coordination layer updated to completed successfully"),e.info(`V4_TRIAL_DEBUG_COMPLETION: Post-completion execution state: ${o.status.value}`)):e.error("V4_TRIAL_DEBUG_COMPLETION: Coordination layer completion update failed:",f.error)})):(e.info("V4_TRIAL_DEBUG_COMPLETION: Calling multiTabCoordinator.cancelExecution() for error"),E.cancelExecution().then(f=>{f.ok?(e.info("V4_TRIAL_DEBUG_COMPLETION: Coordination layer updated to cancelled successfully"),e.info(`V4_TRIAL_DEBUG_COMPLETION: Post-cancellation execution state: ${o.status.value}`)):e.error("V4_TRIAL_DEBUG_COMPLETION: Coordination layer cancellation update failed:",f.error)})),setTimeout(()=>{e.info(`V4_TRIAL_DEBUG_COMPLETION: Executing delayed cleanup for trial ${t}`),e.info(`V4_TRIAL_DEBUG_COMPLETION: Post-completion execution state: ${o.status.value}`),this.cleanupStreams(t),this.orchestrators.has(t)&&(e.info(`V4_TRIAL_DEBUG_COMPLETION: Removing orchestrator for completed trial ${t}`),this.orchestrators.delete(t))},1e3))},error:l=>{e.error(`V4_TRIAL_DEBUG_COMPLETION: Stream error for trial ${t}:`,l),e.info("V4_TRIAL_DEBUG_COMPLETION: Updating V4 coordination layer to cancelled state due to error"),E.cancelExecution().then(f=>{f.ok?(e.info("V4_TRIAL_DEBUG_COMPLETION: Coordination layer updated to cancelled after error"),e.info(`V4_TRIAL_DEBUG_COMPLETION: Post-error execution state: ${o.status.value}`)):e.error("V4_TRIAL_DEBUG_COMPLETION: Coordination layer error cancellation failed:",f.error)}),this.cleanupStreams(t),this.orchestrators.has(t)&&(e.info(`V4_TRIAL_DEBUG_COMPLETION: Removing orchestrator for errored trial ${t}`),this.orchestrators.delete(t))}})),e.info(`V4_TRIAL_STORE: Storing activeStreams for trial ${t}`),this.activeStreams.set(t,{streams:n.value,subscription:p,sharedProgress$:h,sharedCalls$:O,callsSubject:_}),e.info(`V4_EXECUTION_CONTROL: Successfully created hot observables for trial ${t}`),{ok:!0,value:n.value}}catch(r){return e.error(`V4_EXECUTION_CONTROL: Failed to start streaming trial ${t}:`,r),{ok:!1,error:r instanceof Error?r:new Error("Failed to start streaming trial")}}}async pauseExecution(){this.initialized||await this.initialize();const t=o.trialId.value;if(e.info(`PAUSE_RESUME_BUG: V4 pauseExecution() ENTRY for trial ${t||"NONE"}`),e.info(`V4_TRIAL_DEBUG_PAUSE: pauseExecution() ENTRY for trial ${t||"NONE"}`),e.info(`V4_TRIAL_DEBUG_PAUSE: Current execution state: ${o.status.value}`),e.info(`V4_TRIAL_DEBUG_PAUSE: Active streams count: ${this.activeStreams.size}`),e.info(`PAUSE_RESUME_BUG: Orchestrators in map: ${this.orchestrators.size}, has ${t}? ${t?this.orchestrators.has(t):!1}`),!t)return e.info("V4_TRIAL_DEBUG_PAUSE: ERROR - No active trial to pause"),{ok:!1,error:new Error("No active trial to pause")};if(!o.canPause())return e.info("V4_TRIAL_DEBUG_PAUSE: Cannot pause - invalid state"),{ok:!1,error:new Error("Cannot pause in current state")};e.info("V4_TRIAL_DEBUG_PAUSE: Calling V3 orchestrator pauseTrial FIRST");const r=this.orchestrators.get(t);e.info(`PAUSE_RESUME_BUG: Got orchestrator for ${t}? ${!!r}`),r?(e.info("PAUSE_RESUME_BUG: Calling orchestrator.pauseTrial() NOW"),await r.pauseTrial(),e.info("V4_TRIAL_DEBUG_PAUSE: V3 pipeline paused, keeping orchestrator alive for potential hot resume")):e.info(`PAUSE_RESUME_BUG: WARNING - No orchestrator found for trial ${t}!`),e.info("V4_TRIAL_DEBUG_PAUSE: V3 paused, now updating state machine to paused");const a=await o.pauseExecution();return a.ok?(E.pauseExecution(),e.info("V4_TRIAL_DEBUG_PAUSE: Pause successful"),{ok:!0,value:void 0}):(e.info("V4_TRIAL_DEBUG_PAUSE: State machine update failed:",a.error),a)}async resumeExecution(t){this.initialized||await this.initialize();const r=t||o.trialId.value;if(e.info(`V4_TRIAL_DEBUG_RESUME: resumeExecution() ENTRY for trial ${r||"NONE"}`),e.info(`V4_TRIAL_DEBUG_RESUME: Current execution state: ${o.status.value}`),e.info(`V4_TRIAL_DEBUG_RESUME: Active streams count: ${this.activeStreams.size}`),e.info(`V4_TRIAL_DEBUG_RESUME: Provided trialId: ${t||"NONE"}, state trialId: ${o.trialId.value||"NONE"}`),!r)return e.info("V4_TRIAL_DEBUG_RESUME: ERROR - No trial ID provided and no active trial to resume"),{ok:!1,error:new Error("No trial ID provided and no active trial to resume")};if(!o.canResume())return e.info("V4_TRIAL_DEBUG_RESUME: Cannot resume - invalid state"),{ok:!1,error:new Error("Cannot resume in current state")};e.info("V4_TRIAL_DEBUG_RESUME: Updating state machine to running");const a=E.tabId.value,i=await o.resumeExecution(r,a);if(!i.ok)return e.info("V4_TRIAL_DEBUG_RESUME: State machine update failed:",i.error),i;e.info("V4_TRIAL_DEBUG_RESUME: Checking for stuck running calls before resume");try{const n=await S.resetRunningCallsToPending(r);if(n.ok&&n.value>0){e.info(`V4_TRIAL_DEBUG_RESUME: Reset ${n.value} stuck running calls to pending`),e.info("V4_TRIAL_DEBUG_RESUME: Forcing UI store refresh to reflect reset calls");const{useTrialStreamManagerV4:h}=await L(async()=>{const{useTrialStreamManagerV4:_}=await import("./trial-stream-manager-v4-B1Pw328z.js").then(I=>I.t);return{useTrialStreamManagerV4:_}},__vite__mapDeps([0,1,2,3,4,5,6])),p=h();p&&(await p.loadHistoricalData(r),e.info("V4_TRIAL_DEBUG_RESUME: UI store refreshed with updated call statuses"))}}catch(n){e.warn("V4_TRIAL_DEBUG_RESUME: Failed to reset running calls, continuing anyway:",n)}let s=this.orchestrators.get(r);if(s)e.info(`V4_TRIAL_DEBUG_RESUME: HOT RESUME - Found existing orchestrator for trial ${r}`),typeof s.resetState=="function"&&(e.info("V4_TRIAL_DEBUG_RESUME: Resetting orchestrator state before hot resume"),s.resetState()),e.info("V4_TRIAL_DEBUG_RESUME: Calling orchestrator.resumeTrial() to flip pause$ and resume pipeline"),s.resumeTrial();else{e.info(`V4_TRIAL_DEBUG_RESUME: COLD RESUME - No orchestrator found for trial ${r}`),e.info("V4_TRIAL_DEBUG_RESUME: Creating fresh orchestrator and starting with pending calls"),s=A(),this.orchestrators.set(r,s),e.info("V4_TRIAL_DEBUG_RESUME: Calling startTrialAtomicWithStreaming to create new pipeline");const n=await s.startTrialAtomicWithStreaming(r);if(!n.ok)return e.error("V4_TRIAL_DEBUG_RESUME: Failed to start trial for cold resume:",n.error),{ok:!1,error:n.error};e.info("V4_TRIAL_DEBUG_RESUME: Cold resume successful, storing new streams")}return E.resumeExecution(r),e.info("V4_TRIAL_DEBUG_RESUME: Resume successful"),{ok:!0,value:void 0}}async cancelExecution(){this.initialized||await this.initialize(),e.info("V4_EXECUTION_CONTROL: Cancelling execution");const t=o.trialId.value;if(!t)return{ok:!1,error:new Error("No active trial to cancel")};if(!o.canCancel())return e.info("V4_EXECUTION_CONTROL: Cannot cancel - invalid state"),{ok:!1,error:new Error("Cannot cancel in current state")};e.info("V4_EXECUTION_CONTROL: Updating state machine to cancelled");const r=await o.cancelExecution();if(!r.ok)return e.info("V4_EXECUTION_CONTROL: State machine update failed:",r.error),r;e.info("V4_EXECUTION_CONTROL: Calling V3 orchestrator cancelTrial");const a=this.orchestrators.get(t);return a&&(a.cancelTrial(),e.info("V4_EXECUTION_CONTROL: Removing orchestrator after cancel"),this.orchestrators.delete(t)),E.cancelExecution(),this.cleanupStreams(t),e.info("V4_EXECUTION_CONTROL: Cancel successful"),{ok:!0,value:void 0}}async executeSingleCall(t,r,a){return this.initialized||await this.initialize(),this.playgroundService?this.playgroundService.executePlaygroundCall(t,a):{ok:!1,error:new Error("Playground service not initialized")}}getActiveStreams(t){const r=this.activeStreams.get(t);return e.info(`V4_TRIAL_GET: getActiveStreams(${t}) called, found: ${!!r}, has sharedCalls$: ${!!r?.sharedCalls$}`),r}cleanupStreams(t){e.info(`V4_TRIAL_DEBUG_CLEANUP: cleanupStreams() ENTRY for trial ${t}`),e.info(`V4_TRIAL_DEBUG_CLEANUP: Current execution state: ${o.status.value}`),e.info(`V4_TRIAL_DEBUG_CLEANUP: Current state trialId: ${o.trialId.value}`);const r=this.activeStreams.get(t);r?(e.info(`V4_TRIAL_DEBUG_CLEANUP: Found streams for trial ${t}, unsubscribing`),r.subscription.unsubscribe(),this.activeStreams.delete(t),e.info(`V4_TRIAL_DEBUG_CLEANUP: Cleaned up streams, remaining active streams: ${this.activeStreams.size}`)):e.info(`V4_TRIAL_DEBUG_CLEANUP: No streams found for trial ${t} (already cleaned up?)`)}}let R=null;function X(){return R||(R=new G),R}export{X as u};
