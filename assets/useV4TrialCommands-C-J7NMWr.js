const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-CqLkMh3s.js","assets/vue-vendor-Cg89ltm_.js","assets/ui-vendor-COTxn_WH.js","assets/utils-vendor-BXgHPvEJ.js","assets/data-vendor-lJS7wsn4.js","assets/index-B2v1RG59.css"])))=>i.map(i=>d[i]);
var X=Object.defineProperty;var Q=(_,e,t)=>e in _?X(_,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):_[e]=t;var b=(_,e,t)=>Q(_,typeof e!="symbol"?e+"":e,t);import{a as r,l as F,d as o,i as P,f as k,P as Y,j as M,k as $,_ as U,c as N}from"./index-CqLkMh3s.js";import{f as z,s as K,a as J,S as Z,R as ee,m as te}from"./utils-vendor-BXgHPvEJ.js";import{s as S,c as y,o as D,b as G,h as re,r as B,f as R}from"./vue-vendor-Cg89ltm_.js";function pe(){const _=performance.now();r.info(`V4_TRIAL_SWITCH: useV4Trials() composable ENTRY at ${_}`);const e=S([]),t=S(!0),a=S(null);let s=null;const i=y(()=>e.value),l=()=>{const g=performance.now();r.info(`V4_TRIAL_SWITCH: setupLiveQuery() ENTRY at ${g}`),s&&(s.unsubscribe(),s=null);const c=F(async()=>{try{return(await o.trials.orderBy("created").reverse().toArray()).filter(E=>!P(E)).map(E=>Object.freeze({...E,created:E.created instanceof Date?E.created:new Date(E.created),started:E.started?E.started instanceof Date?E.started:new Date(E.started):void 0,completed:E.completed?E.completed instanceof Date?E.completed:new Date(E.completed):void 0}))}catch(n){throw r.error("V4_TRIALS: Failed to load trials:",n),n}});s=z(c).subscribe({next:n=>{e.value=n,t.value=!1,a.value=null,`${n.length}`},error:n=>{r.error("V4_TRIALS: Query error:",n),a.value=n instanceof Error?n:new Error("Failed to load trials"),t.value=!1}})},p=y(()=>i.value.filter(g=>g.status==="running")),h=y(()=>i.value.filter(g=>g.status==="draft")),u=y(()=>i.value.filter(g=>g.status==="completed")),d=y(()=>i.value.filter(g=>g.status==="paused")),m=y(()=>i.value.filter(g=>g.status==="failed")),f=y(()=>i.value.length),T=y(()=>{const g={total:i.value.length,byStatus:{draft:0,pending:0,running:0,paused:0,completed:0,cancelled:0,failed:0},totalApiCalls:0,completedApiCalls:0,failedApiCalls:0,averageCompletionRate:0};for(const c of i.value)g.byStatus[c.status]++,c.progress&&(g.totalApiCalls+=c.progress.total,g.completedApiCalls+=c.progress.completed,g.failedApiCalls+=c.progress.failed);return g.totalApiCalls>0&&(g.averageCompletionRate=g.completedApiCalls/g.totalApiCalls*100),g}),O=async()=>{t.value=!0,a.value=null;try{const n=(await o.trials.orderBy("created").reverse().toArray()).filter(I=>!P(I)).map(I=>Object.freeze({...I,created:I.created instanceof Date?I.created:new Date(I.created),started:I.started?I.started instanceof Date?I.started:new Date(I.started):void 0,completed:I.completed?I.completed instanceof Date?I.completed:new Date(I.completed):void 0}));e.value=n,t.value=!1,`${n.length}`}catch(g){r.error("V4_TRIALS: Refresh failed:",g),a.value=g instanceof Error?g:new Error("Failed to refresh trials"),t.value=!1}};return D(()=>{const g=performance.now();r.info(`V4_TRIAL_SWITCH: useV4Trials onMounted() ENTRY at ${g}`),r.info("V4_TRIALS: Mounting trials query composable");const c=performance.now();r.info(`V4_TRIAL_SWITCH: useV4Trials calling setupLiveQuery() at ${(c-g).toFixed(1)}ms`),l();const n=performance.now();r.info(`V4_TRIAL_SWITCH: useV4Trials setupLiveQuery() completed in ${(n-c).toFixed(1)}ms`)}),G(()=>{s&&(s.unsubscribe(),s=null)}),{trials:i,loading:t,error:a,runningTrials:p,draftTrials:h,completedTrials:u,pausedTrials:d,failedTrials:m,totalTrials:f,statistics:T,refresh:O}}function fe(_){const e=S(null),t=S(!0),a=S(null);let s=null,i=null;const l=y(()=>(typeof _=="object"&&_!==null?_.value:_)?e.value:null),p=u=>{const d=performance.now();if(s&&(s.unsubscribe(),s=null),!u){e.value=null,t.value=!1;return}const m=F(async()=>{const f=performance.now();`${(f-d).toFixed(1)}`;const T=await o.trials.get(u);return`${(performance.now()-f).toFixed(1)}`,T?Object.freeze({...T,created:T.created instanceof Date?T.created:new Date(T.created),started:T.started?T.started instanceof Date?T.started:new Date(T.started):void 0,completed:T.completed?T.completed instanceof Date?T.completed:new Date(T.completed):void 0}):null});s=z(m).subscribe({next:f=>{const T=performance.now();e.value=f,t.value=!1,a.value=null,f&&`${f.id}${(T-d).toFixed(1)}`},error:f=>{r.error("V4_TRIALS: Single trial query error:",f),a.value=f instanceof Error?f:new Error("Failed to load trial"),t.value=!1}})},h=async()=>{const u=typeof _=="object"&&_!==null?_.value:_;if(!u){e.value=null,t.value=!1;return}t.value=!0,a.value=null;try{const d=await o.trials.get(u);d?e.value=Object.freeze({...d,created:d.created instanceof Date?d.created:new Date(d.created),started:d.started?d.started instanceof Date?d.started:new Date(d.started):void 0,completed:d.completed?d.completed instanceof Date?d.completed:new Date(d.completed):void 0}):e.value=null,t.value=!1}catch(d){r.error("V4_TRIALS: Refresh single trial failed:",d),a.value=d instanceof Error?d:new Error("Failed to refresh trial"),t.value=!1}};return typeof _=="object"&&_!==null?D(()=>{i=re(()=>{const u=_.value;p(u)})}):D(()=>{p(_)}),G(()=>{s&&(s.unsubscribe(),s=null),i&&(i(),i=null)}),{trial:l,loading:t,error:a,refresh:h}}class ae{constructor(){b(this,"state",B({status:"idle",trialId:null,orchestratorType:null,startedAt:null,pausedAt:null,completedAt:null,tabId:null}));b(this,"currentState",y(()=>({...this.state})));b(this,"status",y(()=>this.state.status));b(this,"trialId",y(()=>this.state.trialId));b(this,"orchestratorType",y(()=>this.state.orchestratorType));b(this,"isExecuting",y(()=>["starting","running","pausing"].includes(this.state.status)));b(this,"isPaused",y(()=>this.state.status==="paused"));b(this,"isIdle",y(()=>this.state.status==="idle"))}async hydrate(){const e=await o.trials.where("status").equals("running").toArray();if(e.length>0){`${e.length}`;for(const t of e)await o.trials.update(t.id,{status:"paused"}),`${t.id}`}}async startExecution(e,t,a){if(this.state.status!=="idle"&&this.state.status!=="paused")return{ok:!1,error:new Error(`Cannot start: current status is ${this.state.status}`)};try{return this.state.status="starting",this.state.trialId=e,this.state.orchestratorType=t,this.state.tabId=a,this.state.startedAt=new Date,this.state.pausedAt=null,this.state.completedAt=null,await o.trials.update(e,{status:"running",started:this.state.startedAt}),this.state.status="running",`${e}`,{ok:!0,value:void 0}}catch(s){return this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,{ok:!1,error:s instanceof Error?s:new Error("Failed to start execution")}}}async pauseExecution(){if(`${this.state.status}`,this.state.status!=="running")return{ok:!1,error:new Error(`Cannot pause: current status is ${this.state.status}`)};if(!this.state.trialId)return{ok:!1,error:new Error("Cannot pause: no active trial")};try{return this.state.status="pausing",this.state.pausedAt=new Date,await o.trials.update(this.state.trialId,{status:"paused"}),this.state.status="paused",`${this.state.trialId}`,{ok:!0,value:void 0}}catch(e){return this.state.status="running",this.state.pausedAt=null,{ok:!1,error:e instanceof Error?e:new Error("Failed to pause execution")}}}async resumeExecution(e,t){if(`${e}${this.state.status}${t}`,!["idle","paused"].includes(this.state.status))return{ok:!1,error:new Error(`Cannot resume: current status is ${this.state.status}`)};try{const a=await o.trials.get(e);if(!a)return{ok:!1,error:new Error(`Trial ${e} not found`)};if(a.status!=="paused")return{ok:!1,error:new Error(`Cannot resume: trial status is ${a.status}, expected paused`)};const s=a.type==="playground"?"streaming":"regular";return this.state.status="running",this.state.trialId=e,this.state.orchestratorType=s,this.state.tabId=t,this.state.startedAt=a.started||new Date,this.state.pausedAt=null,this.state.completedAt=null,await o.trials.update(e,{status:"running"}),`${e}`,{ok:!0,value:void 0}}catch(a){return this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,this.state.pausedAt=null,{ok:!1,error:a instanceof Error?a:new Error("Failed to resume execution")}}}async cancelExecution(){if(`${this.state.status}`,!["running","paused","starting"].includes(this.state.status))return{ok:!1,error:new Error(`Cannot cancel: current status is ${this.state.status}`)};if(!this.state.trialId)return{ok:!1,error:new Error("Cannot cancel: no active trial")};try{const e=this.state.trialId;return this.state.status="cancelling",this.state.completedAt=new Date,await o.trials.update(e,{status:"cancelled",completed:this.state.completedAt}),this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,this.state.pausedAt=null,`${e}`,{ok:!0,value:void 0}}catch(e){return this.state.status=this.state.pausedAt?"paused":"running",this.state.completedAt=null,{ok:!1,error:e instanceof Error?e:new Error("Failed to cancel execution")}}}async completeExecution(){if(`${this.state.status}`,this.state.status!=="running")return{ok:!1,error:new Error(`Cannot complete: current status is ${this.state.status}`)};if(!this.state.trialId)return{ok:!1,error:new Error("Cannot complete: no active trial")};try{const e=this.state.trialId;return this.state.status="completed",this.state.completedAt=new Date,await o.trials.update(e,{status:"completed",completed:this.state.completedAt}),this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,this.state.pausedAt=null,`${e}`,{ok:!0,value:void 0}}catch(e){return this.state.status="running",this.state.completedAt=null,{ok:!1,error:e instanceof Error?e:new Error("Failed to complete execution")}}}canStart(){return this.state.status==="idle"||this.state.status==="paused"}canPause(){return this.state.status==="running"}canResume(){return this.state.status==="paused"&&this.state.orchestratorType!==null}canCancel(){return["running","paused","starting"].includes(this.state.status)}isOwnedByTab(e){return this.state.tabId===e}}const C=new ae;class se{constructor(){b(this,"state",B({tabId:k("tab"),role:"observer",isInitialized:!1,lastHeartbeat:new Date}));b(this,"broadcastChannel",null);b(this,"lockReleaseFunction",null);b(this,"heartbeatInterval",null);b(this,"tabId",y(()=>this.state.tabId));b(this,"role",y(()=>this.state.role));b(this,"isLeader",y(()=>this.state.role==="leader"));b(this,"isObserver",y(()=>this.state.role==="observer"));b(this,"isInitialized",y(()=>this.state.isInitialized))}async initialize(){if(this.state.isInitialized){`${this.state.tabId}${this.state.role}`;return}`${this.state.tabId}`;try{this.broadcastChannel=new BroadcastChannel("auditomatic-coordination"),this.broadcastChannel.onmessage=e=>{this.handleCoordinationMessage(e.data)},await this.attemptLeadershipAcquisition(),this.startHeartbeat(),this.state.isInitialized=!0,`${this.state.tabId}${this.state.role}`}catch(e){throw r.error(`COORDINATION: Failed to initialize tab ${this.state.tabId}:`,e),e}}async attemptLeadershipAcquisition(){if(!("locks"in navigator)){`${this.state.tabId}`,this.state.role="leader";return}try{`${this.state.tabId}`,navigator.locks.request("auditomatic-leader",{mode:"exclusive",ifAvailable:!0},e=>{if(e)return`${this.state.tabId}`,this.state.role="leader",new Promise(t=>{this.lockReleaseFunction=t});`${this.state.tabId}`,this.state.role="observer"}),await new Promise(e=>setTimeout(e,50))}catch(e){r.error(`COORDINATION: Leadership acquisition failed for tab ${this.state.tabId}:`,e),this.state.role="observer"}}startHeartbeat(){this.heartbeatInterval=setInterval(()=>{this.state.lastHeartbeat=new Date,this.broadcast({type:"heartbeat",tabId:this.state.tabId,timestamp:this.state.lastHeartbeat})},1e4)}broadcast(e){this.broadcastChannel&&(`${e.type}${this.state.tabId}`,this.broadcastChannel.postMessage(e))}handleCoordinationMessage(e){if(e.tabId!==this.state.tabId)switch(`${this.state.tabId}${e.type}${e.tabId}`,e.type){case"execution:started":this.state.role==="observer"&&e.trialId&&`${e.trialId}`;break;case"execution:paused":this.state.role==="observer"&&e.trialId&&`${e.trialId}`;break;case"execution:resumed":this.state.role==="observer"&&e.trialId&&`${e.trialId}`;break;case"execution:cancelled":case"execution:completed":this.state.role==="observer"&&e.trialId&&`${e.trialId}`;break;case"heartbeat":`${e.tabId}`;break}}canExecuteActions(){return this.state.role==="leader"}validateLeadership(e){return this.state.role!=="leader"?{ok:!1,error:new Error(`Cannot ${e}: only leader tab can execute actions`)}:{ok:!0,value:void 0}}async startExecution(e,t){const a=this.validateLeadership("start execution");if(!a.ok)return a;const s=await C.startExecution(e,t,this.state.tabId);return s.ok&&this.broadcast({type:"execution:started",tabId:this.state.tabId,timestamp:new Date,trialId:e,orchestratorType:t}),s}async pauseExecution(){const e=this.validateLeadership("pause execution");if(!e.ok)return e;const t=await C.pauseExecution();return t.ok&&this.broadcast({type:"execution:paused",tabId:this.state.tabId,timestamp:new Date,trialId:C.trialId.value||void 0}),t}async resumeExecution(e){const t=this.validateLeadership("resume execution");if(!t.ok)return t;const a=await C.resumeExecution(e,this.state.tabId);return a.ok&&this.broadcast({type:"execution:resumed",tabId:this.state.tabId,timestamp:new Date,trialId:e}),a}async cancelExecution(){const e=this.validateLeadership("cancel execution");if(!e.ok)return e;const t=C.trialId.value,a=await C.cancelExecution();return a.ok&&this.broadcast({type:"execution:cancelled",tabId:this.state.tabId,timestamp:new Date,trialId:t||void 0}),a}async completeExecution(){const e=this.validateLeadership("complete execution");if(!e.ok)return e;const t=C.trialId.value,a=await C.completeExecution();return a.ok&&this.broadcast({type:"execution:completed",tabId:this.state.tabId,timestamp:new Date,trialId:t||void 0}),a}destroy(){`${this.state.tabId}`,this.heartbeatInterval&&(clearInterval(this.heartbeatInterval),this.heartbeatInterval=null),this.lockReleaseFunction&&(this.lockReleaseFunction(),this.lockReleaseFunction=null),this.broadcastChannel&&(this.broadcastChannel.close(),this.broadcastChannel=null),this.state.isInitialized=!1,`${this.state.tabId}`}}const A=new se;class ie{async updateTrial(e){`${e.trialId}${e.status}`;try{const t={};return e.status!==void 0&&(t.status=e.status),e.started!==void 0&&(t.started=e.started),e.completed!==void 0&&(t.completed=e.completed),e.progress!==void 0&&(t.progress=e.progress),await o.trials.update(e.trialId,t),`${e.trialId}`,{ok:!0,value:void 0}}catch(t){return r.error(`ATOMIC_OPS: Failed to update trial ${e.trialId}:`,t),{ok:!1,error:t instanceof Error?t:new Error("Failed to update trial")}}}async resetRunningCallsToPending(e){try{const t=await o.apiCalls.where("trialId").equals(e).and(a=>a.status==="running").toArray();return t.length===0?`${e}`:(await o.transaction("rw",o.apiCalls,async()=>{for(const a of t)await o.apiCalls.update(a.id,{status:"pending",started:void 0,response:void 0,result:void 0})}),`${t.length}${e}`),await this.recalculateTrialProgress(e),{ok:!0,value:t.length}}catch(t){return r.error(`ATOMIC_OPS: Failed to reset running calls for trial ${e}:`,t),{ok:!1,error:t instanceof Error?t:new Error("Failed to reset running calls")}}}async getTrialCallCounts(e){try{const t=await o.transaction("r",o.apiCalls,async()=>{const a=await o.apiCalls.where("trialId").equals(e).toArray();return{total:a.length,completed:a.filter(s=>s.status==="completed").length,failed:a.filter(s=>s.status==="failed").length,cancelled:a.filter(s=>s.status==="cancelled").length,pending:a.filter(s=>s.status==="pending").length,running:a.filter(s=>s.status==="running").length}});return`${e}`,{ok:!0,value:t}}catch(t){return r.error(`ATOMIC_OPS: Failed to get call counts for trial ${e}:`,t),{ok:!1,error:t instanceof Error?t:new Error("Failed to get call counts")}}}async updateApiCallsBatch(e){if(e.length===0)return{ok:!0,value:void 0};`${e.length}`;try{return await o.transaction("rw",o.apiCalls,async()=>{for(const t of e){const a={status:t.status};t.started!==void 0&&(a.started=t.started),t.completed!==void 0&&(a.completed=t.completed),t.response!==void 0&&(a.response=t.response),t.error!==void 0&&(a.error=t.error),await o.apiCalls.update(t.callId,a)}}),`${e.length}`,{ok:!0,value:void 0}}catch(t){return r.error("ATOMIC_OPS: Failed to update API calls batch:",t),{ok:!1,error:t instanceof Error?t:new Error("Failed to update API calls batch")}}}async reconcileTrialState(e){try{const t=await o.trials.get(e);if(!t)return{ok:!1,error:new Error(`Trial ${e} not found`)};const a=await this.getTrialCallCounts(e);if(!a.ok)return a;const s=a.value;let i=t.status;if(s.running>0?i="running":s.pending>0?i="paused":s.completed===s.total&&s.total>0||s.failed>0&&s.completed+s.failed===s.total?i="completed":s.cancelled>0&&(i="cancelled"),i!==t.status){`${e}${t.status}${i}`;const l=await this.updateTrial({trialId:e,status:i,progress:s,...i==="completed"&&{completed:new Date}});if(!l.ok)return l}else`${e}${i}`;return{ok:!0,value:i}}catch(t){return r.error(`ATOMIC_OPS: Failed to reconcile trial ${e} state:`,t),{ok:!1,error:t instanceof Error?t:new Error("Failed to reconcile trial state")}}}async performCleanupOperations(e){try{const t=await this.resetRunningCallsToPending(e);if(!t.ok)return t;const a=await this.reconcileTrialState(e);if(!a.ok)return a;const s={resetCount:t.value,reconciledStatus:a.value};return`${e}`,{ok:!0,value:s}}catch(t){return r.error(`ATOMIC_OPS: Failed cleanup operations for trial ${e}:`,t),{ok:!1,error:t instanceof Error?t:new Error("Failed cleanup operations")}}}async recalculateTrialProgress(e){try{const t=await o.trials.get(e);if(!t){`${e}`;return}const a=await o.apiCalls.where("trialId").equals(e).toArray();let s=0,i=0,l=0,p=0,h=0;for(const m of a)switch(m.status){case"completed":s++;break;case"failed":i++,m.result?.errorType==="network_error_no_response"&&h++;break;case"cancelled":l++;break;case"running":p++;break}const u=t.progress.total-s-i-l-p,d={total:t.progress.total,completed:s,failed:i,cancelled:l,pending:u,running:p,networkErrors:h};`${e}${s}${i}${p}${u}`,await o.trials.update(e,{progress:d})}catch(t){r.error(`V4_TRIAL_DEBUG_PAUSE: Failed to recalculate progress for trial ${e}:`,t)}}async performSystemCleanup(){try{let e=0,t=0;const a=await o.trials.where("status").equals("running").toArray();`${a.length}`;for(const i of a){const l=await this.performCleanupOperations(i.id);if(l.ok)e+=l.value.resetCount,t++;else{const p=l;r.warn(`ATOMIC_OPS: Failed to cleanup trial ${i.id}:`,p.error.message)}}const s={trialsProcessed:t,callsReset:e};return{ok:!0,value:s}}catch(e){return r.error("ATOMIC_OPS: System cleanup failed:",e),{ok:!1,error:e instanceof Error?e:new Error("System cleanup failed")}}}}const oe=new ie;class ne{constructor(){b(this,"playgroundService",null);b(this,"initialized",!1);b(this,"orchestrators",new Map);b(this,"activeStreams",new Map);b(this,"execution",y(()=>{const e=C.status.value;let t="idle";return e==="running"||e==="starting"||e==="pausing"?t="executing":e==="paused"?t="paused":t="idle",{status:t,currentTrialId:C.trialId.value,startedAt:C.currentState.value.startedAt}}));b(this,"progress",y(()=>({trials:new Map,activeApiCall:null,lastUpdated:new Date})));b(this,"queue",y(()=>({global:{pending:0,executing:0,capacity:0,utilization:0},providers:new Map})));b(this,"tabRole",y(()=>A.role.value));b(this,"isLeader",y(()=>A.isLeader.value));b(this,"canExecute",y(()=>A.isLeader.value&&C.canStart()))}async initialize(){const e=performance.now();if(`${this.initialized}`,`${this.activeStreams.size}`,!this.initialized)try{const t=performance.now();`${(t-e).toFixed(1)}`,await A.initialize(),`${(performance.now()-t).toFixed(1)}`;const s=performance.now();`${(s-e).toFixed(1)}`;const i=await oe.performSystemCleanup();if(`${(performance.now()-s).toFixed(1)}`,i.ok)i.value;else{const d=i;r.warn("V4_EXECUTION_CONTROL: System cleanup failed:",d.error)}const p=performance.now();`${(p-e).toFixed(1)}`,this.playgroundService=new Y(async d=>{const m=await this.startTrialWithStreaming(d);return m.ok?{ok:!0,value:m.value.progress$}:m}),`${(performance.now()-p).toFixed(1)}`,this.initialized=!0,`${(performance.now()-e).toFixed(1)}`}catch(t){const a=performance.now();throw r.error(`V4_TRIAL_SWITCH: V4ExecutionControl initialization FAILED in ${(a-e).toFixed(1)}ms:`,t),t}}cleanup(){`${this.activeStreams.size}`,`${this.orchestrators.size}`;try{this.activeStreams.forEach((e,t)=>{`${t}`,e.subscription.unsubscribe()}),this.activeStreams.clear(),this.orchestrators.forEach((e,t)=>{`${t}`}),this.orchestrators.clear(),A.destroy(),this.playgroundService=null,this.initialized=!1}catch(e){r.error("V4_EXECUTION_CONTROL: Cleanup error:",e)}}async startTrial(e){this.initialized||await this.initialize();try{if(M(e)){const l=await(this.playgroundService?.executePlaygroundCall("",{})||Promise.resolve({ok:!1,error:new Error("Playground service not available")}));return l.ok?{ok:!0,value:void 0}:{ok:!1,error:l.error}}let a=this.orchestrators.get(e);a||(a=$(),this.orchestrators.set(e,a));const i=await a.startTrialAtomic(e);return i.ok?(`${e}`,{ok:!0,value:void 0}):{ok:!1,error:i.error}}catch(t){return r.error(`V4_EXECUTION_CONTROL: Failed to start trial ${e}:`,t),{ok:!1,error:t instanceof Error?t:new Error("Failed to start trial")}}}async startTrialWithStreaming(e){this.initialized||await this.initialize(),this.cleanupStreams(e);try{if(M(e))return{ok:!1,error:new Error("Playground streaming not yet implemented in V4")};if(!this.canExecute.value)return{ok:!1,error:new Error("Cannot start trial - not leader or invalid state")};const a=A.tabId.value,s=await C.startExecution(e,"streaming",a);if(!s.ok)return s.error,{ok:!1,error:s.error};let i=this.orchestrators.get(e);i||(i=$(),this.orchestrators.set(e,i));const l=await i.startTrialAtomicWithStreaming(e);if(!l.ok)return{ok:!1,error:l.error};`${e}`;const p=l.value.progress$.pipe(K(),J({bufferSize:1,refCount:!0})),h=new Z,u=new ee(1),d=l.value.calls$.pipe(te(f=>(`${f.length}`,f.map(T=>T.call&&T.providerId?T.call:T)))).subscribe({next:f=>{`${f.length}`,u.next(f)},error:f=>{u.error(f)},complete:()=>{`${e}`}});h.add(d);const m=u;return h.add(p.subscribe({next:f=>{`${e}${f.type}`,(f.type==="completed"||f.type==="error")&&(`${e}${f.type}`,`${C.status.value}`,f.type==="completed"?A.completeExecution().then(T=>{T.ok?`${C.status.value}`:r.error("V4_TRIAL_DEBUG_COMPLETION: Coordination layer completion update failed:",T.error)}):A.cancelExecution().then(T=>{T.ok?`${C.status.value}`:r.error("V4_TRIAL_DEBUG_COMPLETION: Coordination layer cancellation update failed:",T.error)}),setTimeout(()=>{`${e}`,`${C.status.value}`,this.cleanupStreams(e),this.orchestrators.has(e)&&(`${e}`,this.orchestrators.delete(e))},1e3))},error:f=>{r.error(`V4_TRIAL_DEBUG_COMPLETION: Stream error for trial ${e}:`,f),A.cancelExecution().then(T=>{T.ok?`${C.status.value}`:r.error("V4_TRIAL_DEBUG_COMPLETION: Coordination layer error cancellation failed:",T.error)}),this.cleanupStreams(e),this.orchestrators.has(e)&&(`${e}`,this.orchestrators.delete(e))}})),`${e}`,this.activeStreams.set(e,{streams:l.value,subscription:h,sharedProgress$:p,sharedCalls$:m,callsSubject:u}),`${e}`,{ok:!0,value:l.value}}catch(t){return r.error(`V4_EXECUTION_CONTROL: Failed to start streaming trial ${e}:`,t),{ok:!1,error:t instanceof Error?t:new Error("Failed to start streaming trial")}}}async pauseExecution(){this.initialized||await this.initialize();const e=C.trialId.value;if(`${C.status.value}`,`${this.activeStreams.size}`,!e)return{ok:!1,error:new Error("No active trial to pause")};if(!C.canPause())return{ok:!1,error:new Error("Cannot pause in current state")};const t=this.orchestrators.get(e);t&&await t.pauseTrial();const a=await C.pauseExecution();return a.ok?(A.pauseExecution(),{ok:!0,value:void 0}):(a.error,a)}async resumeExecution(e){this.initialized||await this.initialize();const t=e||C.trialId.value;if(`${C.status.value}`,`${this.activeStreams.size}`,`${e||"NONE"}${C.trialId.value||"NONE"}`,!t)return{ok:!1,error:new Error("No trial ID provided and no active trial to resume")};if(!C.canResume())return{ok:!1,error:new Error("Cannot resume in current state")};const a=A.tabId.value,s=await C.resumeExecution(t,a);if(!s.ok)return s.error,s;let i=this.orchestrators.get(t);if(i)i.resumeTrial();else{i=$(),this.orchestrators.set(t,i);const l=await i.startTrialAtomicWithStreaming(t);if(!l.ok)return r.error("V4_TRIAL_DEBUG_RESUME: Failed to start trial for cold resume:",l.error),{ok:!1,error:l.error}}return A.resumeExecution(t),{ok:!0,value:void 0}}async cancelExecution(){this.initialized||await this.initialize();const e=C.trialId.value;if(!e)return{ok:!1,error:new Error("No active trial to cancel")};if(!C.canCancel())return{ok:!1,error:new Error("Cannot cancel in current state")};const t=await C.cancelExecution();if(!t.ok)return t.error,t;const a=this.orchestrators.get(e);return a&&(a.cancelTrial(),this.orchestrators.delete(e)),A.cancelExecution(),this.cleanupStreams(e),{ok:!0,value:void 0}}async executeSingleCall(e,t,a){return this.initialized||await this.initialize(),this.playgroundService?this.playgroundService.executePlaygroundCall(e,a):{ok:!1,error:new Error("Playground service not initialized")}}getActiveStreams(e){const t=this.activeStreams.get(e);return`${e}`,t?.sharedCalls$,t}cleanupStreams(e){`${C.status.value}`,`${C.trialId.value}`;const t=this.activeStreams.get(e);t&&(t.subscription.unsubscribe(),this.activeStreams.delete(e),`${this.activeStreams.size}`)}}let V=null;function he(){return V||(V=new ne),V}class W{async createTrial(e){try{const t=this.validateTrialConfig(e);if(!t.ok)return{ok:!1,error:t.error};const a=await this.createConfigurationSnapshots(e.configurations);let s=e.templateConfig;if(e.type==="template"&&s){const p=await this.createVariableSnapshots(s.variables);s={...s,variables:p,hasSnapshots:!0}}const i={id:k("trial"),name:e.name,description:e.description,type:e.type,status:"draft",configurations:a,progress:{total:0,completed:0,failed:0,cancelled:0,pending:0,running:0,networkErrors:0},created:new Date,...e.repeatCount&&e.repeatCount>1?{repeatConfig:{callsPerPrompt:e.repeatCount}}:{},...e.type==="template"&&s?{templateConfig:s}:{},...e.type==="spreadsheet"&&e.spreadsheetConfig?{spreadsheetConfig:e.spreadsheetConfig}:{}},l=await this.generateApiCalls(i,e.repeatCount||1);return i.progress.total=l.length,i.progress.pending=l.length,await o.transaction("rw",o.trials,o.apiCalls,async()=>{await o.trials.add(i),l.length>0&&await o.apiCalls.bulkAdd(l)}),`${i.id}${l.length}`,{ok:!0,value:i.id}}catch(t){return r.error("V4_TRIALS: Failed to create trial:",t),{ok:!1,error:t instanceof Error?t:new Error("Failed to create trial")}}}async updateTrial(e,t){try{return await o.transaction("rw",o.trials,async()=>{const a=await o.trials.get(e);if(!a)throw new Error(`Trial not found: ${e}`);const s={...a,...t,created:a.created};await o.trials.put(s)}),{ok:!0}}catch(a){return r.error("V4_TRIALS: Failed to update trial:",a),{ok:!1,error:a instanceof Error?a:new Error("Failed to update trial")}}}async deleteTrial(e){try{return await o.transaction("rw",o.trials,o.apiCalls,async()=>{const t=await o.trials.get(e);if(!t)throw new Error(`Trial not found: ${e}`);if(t.status==="running")throw new Error("Cannot delete running trial");await o.apiCalls.where("trialId").equals(e).delete(),await o.trials.delete(e)}),`${e}`,{ok:!0}}catch(t){return r.error("V4_TRIALS: Failed to delete trial:",t),{ok:!1,error:t instanceof Error?t:new Error("Failed to delete trial")}}}async duplicateTrial(e){try{const t=await o.trials.get(e);if(!t)return{ok:!1,error:new Error(`Source trial not found: ${e}`)};const a={name:`${t.name} (Copy)`,description:t.description,type:t.type,configurations:t.configurations.map(s=>({provider:s.provider,modelId:s.modelId,parameters:s.parameters,name:s.modelSnapshot?.displayName})),repeatCount:t.repeatCount,...t.type==="template"&&t.templateConfig?{templateConfig:t.templateConfig}:{},...t.type==="spreadsheet"&&t.spreadsheetConfig?{spreadsheetConfig:t.spreadsheetConfig}:{}};return this.createTrial(a)}catch(t){return r.error("V4_TRIALS: Failed to duplicate trial:",t),{ok:!1,error:t instanceof Error?t:new Error("Failed to duplicate trial")}}}async updatePostProcessingConfig(e,t,a=!1){try{const s=a&&t?.enabled?await U(()=>import("./index-CqLkMh3s.js").then(i=>i.w),__vite__mapDeps([0,1,2,3,4,5])):null;return await o.transaction("rw",o.trials,o.apiCalls,async()=>{const i=await o.trials.get(e);if(!i)throw new Error(`Trial not found: ${e}`);const l={...i,postProcessingConfig:t?{...t,refusalWords:t.refusalWords?[...t.refusalWords]:void 0,updatedAt:new Date}:void 0};if(await o.trials.put(l),a&&t?.enabled&&s){const{extractResponseContent:p}=s,h=await o.apiCalls.where("trialId").equals(e).and(u=>u.status==="completed"&&!!u.result?.content).toArray();`${h.length}`;for(const u of h){if(!u.result?.content)continue;const d=await p(u.result.content,{outputType:t.outputType,extractPattern:t.extractPattern,refusalWords:t.refusalWords,rejectRefusalWords:t.rejectRefusalWords,extractionMode:t.extractionMode,pythonCode:t.pythonCode,pythonFunctionName:t.pythonFunctionName}),m={...u.result,postParsedContent:d.parsedContent,postRefused:d.refused||!1};await o.apiCalls.update(u.id,{result:m})}}}),`${e}`,{ok:!0}}catch(s){return r.error("V4_TRIALS: Failed to update post-processing config:",s),{ok:!1,error:s instanceof Error?s:new Error("Failed to update post-processing config")}}}async updatePostParserId(e,t,a=!1){try{const s=a&&t?await U(()=>import("./index-CqLkMh3s.js").then(i=>i.x),__vite__mapDeps([0,1,2,3,4,5])):null;return await o.transaction("rw",o.trials,o.apiCalls,async()=>{const i=await o.trials.get(e);if(!i)throw new Error(`Trial not found: ${e}`);const l={...i,postParserId:t||void 0,postProcessingConfig:t?void 0:i.postProcessingConfig};if(await o.trials.put(l),a&&t&&s){const{parserService:p}=s,h=await o.apiCalls.where("trialId").equals(e).and(u=>u.status==="completed"&&!!u.result?.content).toArray();`${h.length}`;for(const u of h){if(!u.result?.content)continue;const d=await p.execute(u.result.content,t);if(d.success){const m={...u.result,postParsedContent:d.value,postRefused:d.refused||!1};await o.apiCalls.update(u.id,{result:m})}}}}),`${e}`,{ok:!0}}catch(s){return r.error("V4_TRIALS: Failed to update post-processing parser:",s),{ok:!1,error:s instanceof Error?s:new Error("Failed to update post-processing parser")}}}async updateTrialProgress(e){try{return await o.transaction("rw",o.trials,o.apiCalls,async()=>{const t=await o.trials.get(e);if(!t)throw new Error(`Trial not found: ${e}`);const a=await o.apiCalls.where("trialId").equals(e).toArray();let s=0,i=0,l=0,p=0,h=0;for(const d of a)switch(d.status){case"completed":s++;break;case"failed":i++,d.result?.errorType==="network_error_no_response"&&h++;break;case"cancelled":l++;break;case"running":p++;break}const u=t.progress.total-s-i-l-p;t.progress={total:t.progress.total,completed:s,failed:i,cancelled:l,pending:u,running:p,networkErrors:h},s+i+l>=t.progress.total&&t.status==="running"&&(t.status="completed",t.completed=new Date),await o.trials.put(t)}),{ok:!0}}catch(t){return r.error("V4_TRIALS: Failed to update trial progress:",t),{ok:!1,error:t instanceof Error?t:new Error("Failed to update progress")}}}async generateApiCalls(e,t){return`${e.id}${e.type}`,e.type==="template"&&e.templateConfig?this.generateTemplateApiCalls(e,e.templateConfig,t):e.type==="spreadsheet"&&e.spreadsheetConfig?this.generateSpreadsheetApiCalls(e,e.spreadsheetConfig,t):e.type==="playground"?[]:(r.warn(`V4_TRIALS: Unknown trial type or missing config for trial ${e.id}`),[])}async generateTemplateApiCalls(e,t,a){if(!t)return[];const s=[];let i=0;const l=await this.generateVariableCombinations(t.variables);`${l.length}`;for(let p=0;p<a;p++)for(let h=0;h<e.configurations.length;h++)for(const u of l){const d=this.substituteVariables(t.template,u.variables),m={id:k("call"),trialId:e.id,configurationIndex:h,order:i++,variables:u.variables,variableAttributes:u.variableAttributes,variableIndices:u.variableIndices,prompt:d,status:"pending",retryCount:0,created:new Date};s.push(m)}return`${s.length}`,s}async generateSpreadsheetApiCalls(e,t,a){if(!t)return[];const s=[];let i=0;const l=await o.variableLists.get(t.datasetId);if(!l||l.category!=="tabular"||!l.tabularData?.rows)return r.warn(`V4_TRIALS: Dataset ${t.datasetId} not found or invalid`),[];for(let p=0;p<a;p++)for(const h of l.tabularData.rows){const u=this.substituteVariables(t.promptPattern,h);for(let d=0;d<e.configurations.length;d++){const m={id:k("call"),trialId:e.id,configurationIndex:d,order:i++,variables:h,prompt:u,status:"pending",retryCount:0,created:new Date};s.push(m)}}return`${s.length}`,s}async generateVariableCombinations(e){const t=Object.keys(e).sort();if(t.length===0)return[{variables:{}}];const a={};for(const p of t){const h=e[p];let u=[];const d=h;if(d.snapshot)u=d.snapshot.items.map(m=>({value:m.value,attributes:m.attributes}));else if(h.type==="value"&&h.values)u=h.values.map(m=>({value:m}));else if(h.type==="list"&&h.listId){const m=await o.variableLists.get(h.listId);m&&(m.category==="simple"&&m.values?u=m.values.map(f=>({value:f})):m.category==="attributed"&&m.items?u=m.items.map(f=>({value:f.value||f.name||String(f),attributes:f.attributes||{}})):m.category==="tabular"&&m.tabularData?.rows&&(u=m.tabularData.rows.map(f=>({value:f.name||f[Object.keys(f)[0]]||String(f)}))))}a[p]=u}const i=t.map(p=>Math.max(a[p].length,1)).reduce((p,h)=>p*h,1),l=[];for(let p=0;p<i;p++){const h={},u={},d={};let m=p;for(let T=t.length-1;T>=0;T--){const O=t[T],g=a[O];if(g.length>0){const c=m%g.length,n=g[c];h[O]=n.value,d[O]=c,n.attributes&&Object.keys(n.attributes).length>0&&(u[O]={...n.attributes}),m=Math.floor(m/g.length)}else h[O]="",d[O]=0}const f={variables:h};Object.keys(u).length>0&&(f.variableAttributes=u),Object.keys(d).length>0&&(f.variableIndices=d),l.push(f)}return l}substituteVariables(e,t){let a=e;for(const[s,i]of Object.entries(t)){const l=new RegExp(`\\{\\{\\s*${s}\\s*\\}\\}`,"g");a=a.replace(l,i)}return a}validateTrialConfig(e){if(!e.name||e.name.trim().length===0)return{ok:!1,error:new Error("Trial name is required")};if(!e.configurations||e.configurations.length===0)return{ok:!1,error:new Error("At least one model configuration is required")};for(const t of e.configurations){if(!N.getProvider(t.provider))return{ok:!1,error:new Error(`Provider not found: ${t.provider}`)};const s=N.validateParameters(t.provider,t.modelId,t.parameters);if(!s.valid)return{ok:!1,error:new Error(`Invalid parameters: ${s.errors?.join(", ")||"Validation failed"}`)}}if(e.type==="template"){if(!e.templateConfig||!e.templateConfig.template)return{ok:!1,error:new Error("Template is required for template trials")}}else if(e.type==="spreadsheet"&&(!e.spreadsheetConfig||!e.spreadsheetConfig.promptPattern))return{ok:!1,error:new Error("Prompt pattern is required for spreadsheet trials")};return{ok:!0}}async createConfigurationSnapshots(e){const t=[];for(const a of e){const s=N.getProvider(a.provider);if(!s)throw new Error(`Provider not found: ${a.provider}`);const l=(await o.models.where("provider").equals(a.provider).toArray()).find(h=>h.modelId===a.modelId),p={provider:a.provider,modelId:a.modelId,parameters:a.parameters,providerSnapshot:s,modelSnapshot:l||{id:`${a.provider}:${a.modelId}`,provider:a.provider,modelId:a.modelId,displayName:a.name||a.modelId,enabled:!0,source:"user"}};t.push(p)}return t}async createVariableSnapshots(e){const t={};for(const[a,s]of Object.entries(e)){const i={...s};if(s.type==="value"&&s.values)i.snapshot={source:{type:"direct",snapshotDate:new Date},items:s.values.map(l=>({value:l}))};else if(s.type==="list"&&s.listId){const l=await o.variableLists.get(s.listId);l&&(i.snapshot=await this.snapshotVariableList(l))}t[a]=i}return t}async snapshotVariableList(e){const t={source:{type:e.category,listId:e.id,listName:e.name,snapshotDate:new Date},items:[]};switch(e.category){case"simple":case"refusal":t.items=e.values?.map(a=>({value:a}))||[];break;case"attributed":t.items=e.items?.map(a=>({value:a.value,attributes:{...a.attributes}}))||[],t.attributeKeys=[...e.attributeKeys||[]];break;case"tabular":e.tabularData?.rows&&(t.items=e.tabularData.rows.map(a=>({value:a.name||a[Object.keys(a)[0]]||""})));break}return t}}const L=new W,me=Object.freeze(Object.defineProperty({__proto__:null,V4TrialOperations:W,v4TrialOperations:L},Symbol.toStringTag,{value:"Module"}));function Te(){const _=R(!1),e=R(!1),t=R(!1),a=R(!1),s=R(null),i=async c=>{_.value=!0,s.value=null;try{const n=await L.createTrial(c);return n.ok?n.value:(s.value=n.error||new Error("Failed to create trial"),r.error("V4_TRIAL_COMMANDS: Create trial failed:",n.error)),n}finally{_.value=!1}},l=async(c,n,I)=>{try{const v=await o.template_prompts.get(c);if(!v)return{ok:!1,error:new Error(`Template not found: ${c}`)};const E={name:I||`${v.name} - ${new Date().toLocaleString()}`,description:v.description,type:"template",configurations:n,repeatCount:1,templateConfig:{template:v.template,templateId:v.id,templateName:v.name,variables:v.variables||{},outputType:v.outputType,extractPattern:v.extractPattern,refusalWords:v.refusalWords?[...v.refusalWords]:void 0,rejectRefusalWords:v.rejectRefusalWords}};return i(E)}catch(v){return r.error("V4_TRIAL_COMMANDS: Failed to create trial from template:",v),{ok:!1,error:v instanceof Error?v:new Error("Failed to create trial from template")}}},p=async(c,n,I,v)=>{try{const E=await o.variableLists.get(n);if(!E||E.category!=="tabular")return{ok:!1,error:new Error(`Dataset not found or not tabular: ${n}`)};const w={name:v||`Spreadsheet Trial - ${new Date().toLocaleString()}`,type:"spreadsheet",configurations:I,spreadsheetConfig:{promptPattern:c,datasetId:n}};return i(w)}catch(E){return r.error("V4_TRIAL_COMMANDS: Failed to create spreadsheet trial:",E),{ok:!1,error:E instanceof Error?E:new Error("Failed to create spreadsheet trial")}}},h=async(c,n)=>{e.value=!0,s.value=null;try{const I=await L.updateTrial(c,n);return I.ok||(s.value=I.error||new Error("Failed to update trial"),r.error("V4_TRIAL_COMMANDS: Update trial failed:",I.error)),I}finally{e.value=!1}},u=async(c,n)=>h(c,{status:n}),d=async c=>{t.value=!0,s.value=null;try{const n=await L.deleteTrial(c);return n.ok||(s.value=n.error||new Error("Failed to delete trial"),r.error("V4_TRIAL_COMMANDS: Delete trial failed:",n.error)),n}finally{t.value=!1}},m=async c=>{t.value=!0,s.value=null;try{return c.length,await o.transaction("rw",o.trials,o.apiCalls,async()=>{for(const n of c){const I=await o.trials.get(n);I&&I.status!=="running"&&(await o.apiCalls.where("trialId").equals(n).delete(),await o.trials.delete(n))}}),{ok:!0}}catch(n){return r.error("V4_TRIAL_COMMANDS: Failed to delete multiple trials:",n),s.value=n instanceof Error?n:new Error("Failed to delete trials"),{ok:!1,error:s.value}}finally{t.value=!1}},f=async c=>{a.value=!0,s.value=null;try{const n=await L.duplicateTrial(c);return n.ok?n.value:(s.value=n.error||new Error("Failed to duplicate trial"),r.error("V4_TRIAL_COMMANDS: Duplicate trial failed:",n.error)),n}finally{a.value=!1}},T=async c=>{try{let n=1;if(c.type==="template"&&c.templateConfig){const v=c.templateConfig.variables;for(const[,E]of Object.entries(v))if(E.type==="value"&&E.values)n*=E.values.length;else if(E.type==="list"&&E.listId){const w=await o.variableLists.get(E.listId);w&&(w.category==="simple"&&w.values?n*=w.values.length:w.category==="attributed"&&w.items?n*=w.items.length:w.category==="tabular"&&w.tabularData?.rows&&(n*=w.tabularData.rows.length))}}else if(c.type==="spreadsheet"&&c.spreadsheetConfig){const v=await o.variableLists.get(c.spreadsheetConfig.datasetId);v&&v.category==="tabular"&&v.tabularData?.rows&&(n=v.tabularData.rows.length)}return n*c.configurations.length*(c.repeatCount||1)}catch(n){return r.error("V4_TRIAL_COMMANDS: Failed to calculate API call count:",n),0}};return{createTrial:i,createTrialFromTemplate:l,createTrialFromSpreadsheet:p,updateTrial:h,updateTrialStatus:u,deleteTrial:d,deleteMultipleTrials:m,duplicateTrial:f,generateApiCallCount:T,estimateTrialCost:async c=>{try{const n=await T(c);let I=0;for(const v of c.configurations){const w=(await o.models.where("provider").equals(v.provider).toArray()).find(x=>x.modelId===v.modelId);if(w?.capabilities){const q=v.parameters?.max_tokens||v.parameters?.maxTokens||256,H=(w.capabilities.inputCostPerToken||0)*150,j=(w.capabilities.outputCostPerToken||0)*q;I+=(H+j)*n/c.configurations.length}}return I}catch(n){return r.error("V4_TRIAL_COMMANDS: Failed to estimate cost:",n),0}},validateTrialConfig:c=>!c.name||c.name.trim().length===0?{ok:!1,error:new Error("Trial name is required")}:!c.configurations||c.configurations.length===0?{ok:!1,error:new Error("At least one model configuration is required")}:c.type==="template"&&!c.templateConfig?{ok:!1,error:new Error("Template configuration is required for template trials")}:c.type==="spreadsheet"&&!c.spreadsheetConfig?{ok:!1,error:new Error("Spreadsheet configuration is required for spreadsheet trials")}:{ok:!0},isCreating:_,isUpdating:e,isDeleting:t,isDuplicating:a,lastError:s}}export{Te as a,he as b,fe as c,me as d,pe as u,L as v};
