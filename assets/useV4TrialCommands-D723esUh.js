const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-C1mYG9hD.js","assets/vue-vendor-DPw1dQYc.js","assets/ui-vendor-IRGmExUJ.js","assets/utils-vendor-B76-F3_P.js","assets/tauri-vendor-1uBLmS9u.js","assets/index-BsU_NJBS.css"])))=>i.map(i=>d[i]);
import{a as o,l as M,d as i,k,i as L,_ as x,c as V}from"./index-C1mYG9hD.js";import{f as $}from"./utils-vendor-B76-F3_P.js";import{s as _,c as I,o as R,b as F,h as j,f as S}from"./vue-vendor-DPw1dQYc.js";function U(){const w=performance.now();o.info(`V4_TRIAL_SWITCH: useV4Trials() composable ENTRY at ${w}`);const t=_([]),e=_(!0),a=_(null);let r=null;const n=I(()=>t.value),c=()=>{const f=performance.now();o.info(`V4_TRIAL_SWITCH: setupLiveQuery() ENTRY at ${f}`),r&&(r.unsubscribe(),r=null);const l=M(async()=>{try{return(await i.trials.orderBy("created").reverse().toArray()).filter(T=>!k(T)).map(T=>Object.freeze({...T,created:T.created instanceof Date?T.created:new Date(T.created),started:T.started?T.started instanceof Date?T.started:new Date(T.started):void 0,completed:T.completed?T.completed instanceof Date?T.completed:new Date(T.completed):void 0}))}catch(s){throw o.error("V4_TRIALS: Failed to load trials:",s),s}});r=$(l).subscribe({next:s=>{t.value=s,e.value=!1,a.value=null,o.info(`V4_TRIALS_DB: Loaded ${s.length} trials from database`)},error:s=>{o.error("V4_TRIALS: Query error:",s),a.value=s instanceof Error?s:new Error("Failed to load trials"),e.value=!1}})},u=I(()=>n.value.filter(f=>f.status==="running")),p=I(()=>n.value.filter(f=>f.status==="draft")),m=I(()=>n.value.filter(f=>f.status==="completed")),d=I(()=>n.value.filter(f=>f.status==="paused")),y=I(()=>n.value.filter(f=>f.status==="failed")),h=I(()=>n.value.length),b=I(()=>{const f={total:n.value.length,byStatus:{draft:0,pending:0,running:0,paused:0,completed:0,cancelled:0,failed:0},totalApiCalls:0,completedApiCalls:0,failedApiCalls:0,averageCompletionRate:0};for(const l of n.value)f.byStatus[l.status]++,l.progress&&(f.totalApiCalls+=l.progress.total,f.completedApiCalls+=l.progress.completed,f.failedApiCalls+=l.progress.failed);return f.totalApiCalls>0&&(f.averageCompletionRate=f.completedApiCalls/f.totalApiCalls*100),f}),A=async()=>{e.value=!0,a.value=null;try{const s=(await i.trials.orderBy("created").reverse().toArray()).filter(g=>!k(g)).map(g=>Object.freeze({...g,created:g.created instanceof Date?g.created:new Date(g.created),started:g.started?g.started instanceof Date?g.started:new Date(g.started):void 0,completed:g.completed?g.completed instanceof Date?g.completed:new Date(g.completed):void 0}));t.value=s,e.value=!1,o.info(`V4_TRIALS: Manual refresh loaded ${s.length} trials`)}catch(f){o.error("V4_TRIALS: Refresh failed:",f),a.value=f instanceof Error?f:new Error("Failed to refresh trials"),e.value=!1}};return R(()=>{const f=performance.now();o.info(`V4_TRIAL_SWITCH: useV4Trials onMounted() ENTRY at ${f}`),o.info("V4_TRIALS: Mounting trials query composable");const l=performance.now();o.info(`V4_TRIAL_SWITCH: useV4Trials calling setupLiveQuery() at ${(l-f).toFixed(1)}ms`),c();const s=performance.now();o.info(`V4_TRIAL_SWITCH: useV4Trials setupLiveQuery() completed in ${(s-l).toFixed(1)}ms`)}),F(()=>{o.info("V4_TRIALS: Unmounting trials query composable"),r&&(r.unsubscribe(),r=null)}),{trials:n,loading:e,error:a,runningTrials:u,draftTrials:p,completedTrials:m,pausedTrials:d,failedTrials:y,totalTrials:h,statistics:b,refresh:A}}function Q(w){const t=_(null),e=_(!0),a=_(null);let r=null,n=null;const c=I(()=>(typeof w=="object"&&w!==null?w.value:w)?t.value:null),u=m=>{const d=performance.now();if(o.info(`V4_TRIAL_SWITCH: Single trial query setup for ${m}`),r&&(r.unsubscribe(),r=null),!m){t.value=null,e.value=!1,o.info("V4_TRIAL_SWITCH: Single trial query cleared (no ID)");return}const y=M(async()=>{const h=performance.now();o.info(`V4_TRIAL_SWITCH: Single trial DB query starting at ${(h-d).toFixed(1)}ms`);const b=await i.trials.get(m),A=performance.now();return o.info(`V4_TRIAL_SWITCH: Single trial DB query completed in ${(A-h).toFixed(1)}ms`),b?Object.freeze({...b,created:b.created instanceof Date?b.created:new Date(b.created),started:b.started?b.started instanceof Date?b.started:new Date(b.started):void 0,completed:b.completed?b.completed instanceof Date?b.completed:new Date(b.completed):void 0}):null});r=$(y).subscribe({next:h=>{const b=performance.now();t.value=h,e.value=!1,a.value=null,h&&o.info(`V4_TRIAL_SWITCH: Trial ${h.id} loaded from database in ${(b-d).toFixed(1)}ms`)},error:h=>{o.error("V4_TRIALS: Single trial query error:",h),a.value=h instanceof Error?h:new Error("Failed to load trial"),e.value=!1}})},p=async()=>{const m=typeof w=="object"&&w!==null?w.value:w;if(!m){t.value=null,e.value=!1;return}e.value=!0,a.value=null;try{const d=await i.trials.get(m);d?t.value=Object.freeze({...d,created:d.created instanceof Date?d.created:new Date(d.created),started:d.started?d.started instanceof Date?d.started:new Date(d.started):void 0,completed:d.completed?d.completed instanceof Date?d.completed:new Date(d.completed):void 0}):t.value=null,e.value=!1}catch(d){o.error("V4_TRIALS: Refresh single trial failed:",d),a.value=d instanceof Error?d:new Error("Failed to refresh trial"),e.value=!1}};return typeof w=="object"&&w!==null?R(()=>{o.info("V4_TRIALS: Mounting single trial query with reactive ID"),n=j(()=>{const m=w.value;o.info("V4_TRIALS: Trial ID changed to:",m),u(m)})}):R(()=>{o.info("V4_TRIALS: Mounting single trial query for static ID:",w),u(w)}),F(()=>{o.info("V4_TRIALS: Unmounting single trial query"),r&&(r.unsubscribe(),r=null),n&&(n(),n=null)}),{trial:c,loading:e,error:a,refresh:p}}class O{async createTrial(t){try{const e=this.validateTrialConfig(t);if(!e.ok)return{ok:!1,error:e.error};const a=await this.createConfigurationSnapshots(t.configurations);let r=t.templateConfig;if(t.type==="template"&&r){const u=await this.createVariableSnapshots(r.variables);r={...r,variables:u,hasSnapshots:!0}}const n={id:L("trial"),name:t.name,description:t.description,type:t.type,status:"draft",configurations:a,progress:{total:0,completed:0,failed:0,cancelled:0,pending:0,running:0,networkErrors:0},created:new Date,...t.repeatCount&&t.repeatCount>1?{repeatConfig:{callsPerPrompt:t.repeatCount}}:{},...t.type==="template"&&r?{templateConfig:r}:{},...t.type==="spreadsheet"&&t.spreadsheetConfig?{spreadsheetConfig:t.spreadsheetConfig}:{}},c=await this.generateApiCalls(n,t.repeatCount||1);return n.progress.total=c.length,n.progress.pending=c.length,await i.transaction("rw",i.trials,i.apiCalls,async()=>{await i.trials.add(n),c.length>0&&await i.apiCalls.bulkAdd(c)}),o.info(`V4_TRIALS: Created trial ${n.id} with ${c.length} API calls`),{ok:!0,value:n.id}}catch(e){return o.error("V4_TRIALS: Failed to create trial:",e),{ok:!1,error:e instanceof Error?e:new Error("Failed to create trial")}}}async updateTrial(t,e){try{return await i.transaction("rw",i.trials,async()=>{const a=await i.trials.get(t);if(!a)throw new Error(`Trial not found: ${t}`);const r={...a,...e,created:a.created};await i.trials.put(r)}),{ok:!0}}catch(a){return o.error("V4_TRIALS: Failed to update trial:",a),{ok:!1,error:a instanceof Error?a:new Error("Failed to update trial")}}}async deleteTrial(t){try{return await i.transaction("rw",i.trials,i.apiCalls,async()=>{const e=await i.trials.get(t);if(!e)throw new Error(`Trial not found: ${t}`);if(e.status==="running")throw new Error("Cannot delete running trial");await i.apiCalls.where("trialId").equals(t).delete(),await i.trials.delete(t)}),o.info(`V4_TRIALS: Deleted trial ${t} and all associated API calls`),{ok:!0}}catch(e){return o.error("V4_TRIALS: Failed to delete trial:",e),{ok:!1,error:e instanceof Error?e:new Error("Failed to delete trial")}}}async duplicateTrial(t){try{const e=await i.trials.get(t);if(!e)return{ok:!1,error:new Error(`Source trial not found: ${t}`)};const a={name:`${e.name} (Copy)`,description:e.description,type:e.type,configurations:e.configurations.map(r=>({provider:r.provider,modelId:r.modelId,parameters:r.parameters,name:r.modelSnapshot?.displayName})),repeatCount:e.repeatCount,...e.type==="template"&&e.templateConfig?{templateConfig:e.templateConfig}:{},...e.type==="spreadsheet"&&e.spreadsheetConfig?{spreadsheetConfig:e.spreadsheetConfig}:{}};return this.createTrial(a)}catch(e){return o.error("V4_TRIALS: Failed to duplicate trial:",e),{ok:!1,error:e instanceof Error?e:new Error("Failed to duplicate trial")}}}async updatePostParserId(t,e,a=!1){try{let r=[];if(a&&e){const{parserService:n}=await x(async()=>{const{parserService:u}=await import("./index-C1mYG9hD.js").then(p=>p.J);return{parserService:u}},__vite__mapDeps([0,1,2,3,4,5])),c=await i.apiCalls.where("trialId").equals(t).and(u=>u.status==="completed"&&!!u.result?.content).toArray();o.info(`V4_TRIALS: Processing ${c.length} calls with parser (outside transaction)`);for(const u of c){if(!u.result?.content)continue;const p=await n.execute(u.result.content,e);p.success&&r.push({callId:u.id,result:{...u.result,postParsedContent:p.value,postRefused:p.refused||!1}})}o.info(`V4_TRIALS: Processed ${r.length} calls successfully`)}return await i.transaction("rw",i.trials,i.apiCalls,async()=>{const n=await i.trials.get(t);if(!n)throw new Error(`Trial not found: ${t}`);const c={...n,postParserId:e||void 0,postProcessingConfig:e?void 0:n.postProcessingConfig};if(await i.trials.put(c),r.length>0){o.info(`V4_TRIALS: Updating ${r.length} calls in database`);for(const{callId:u,result:p}of r)await i.apiCalls.update(u,{result:p});o.info("V4_TRIALS: Parser post-processing applied retroactively")}}),o.info(`V4_TRIALS: Updated post-processing parser for trial ${t}`),{ok:!0}}catch(r){return o.error("V4_TRIALS: Failed to update post-processing parser:",r),{ok:!1,error:r instanceof Error?r:new Error("Failed to update post-processing parser")}}}async updateTrialProgress(t){try{return await i.transaction("rw",i.trials,i.apiCalls,async()=>{const e=await i.trials.get(t);if(!e)throw new Error(`Trial not found: ${t}`);const a=await i.apiCalls.where("trialId").equals(t).toArray();let r=0,n=0,c=0,u=0,p=0;for(const d of a)switch(d.status){case"completed":r++;break;case"failed":n++,d.result?.errorType==="network_error_no_response"&&p++;break;case"cancelled":c++;break;case"running":u++;break}const m=e.progress.total-r-n-c-u;e.progress={total:e.progress.total,completed:r,failed:n,cancelled:c,pending:m,running:u,networkErrors:p},r+n+c>=e.progress.total&&e.status==="running"&&(e.status="completed",e.completed=new Date),await i.trials.put(e)}),{ok:!0}}catch(e){return o.error("V4_TRIALS: Failed to update trial progress:",e),{ok:!1,error:e instanceof Error?e:new Error("Failed to update progress")}}}async generateApiCalls(t,e){return o.info(`V4_TRIALS: Generating REAL API calls for trial ${t.id}, type: ${t.type}`),t.type==="template"&&t.templateConfig?this.generateTemplateApiCalls(t,t.templateConfig,e):t.type==="spreadsheet"&&t.spreadsheetConfig?this.generateSpreadsheetApiCalls(t,t.spreadsheetConfig,e):t.type==="playground"?[]:(o.warn(`V4_TRIALS: Unknown trial type or missing config for trial ${t.id}`),[])}async generateTemplateApiCalls(t,e,a){if(!e)return[];const r=[];let n=0;const c=await this.generateVariableCombinations(e.variables);o.info(`V4_TRIALS: Generated ${c.length} variable combinations`);for(let u=0;u<a;u++)for(let p=0;p<t.configurations.length;p++)for(const m of c){const d=this.substituteVariables(e.template,m.variables),y={id:L("call"),trialId:t.id,configurationIndex:p,order:n++,variables:m.variables,variableAttributes:m.variableAttributes,variableIndices:m.variableIndices,prompt:d,status:"pending",retryCount:0,created:new Date};r.push(y)}return o.info(`V4_TRIALS: Generated ${r.length} REAL API calls for template trial`),r}async generateSpreadsheetApiCalls(t,e,a){if(!e)return[];const r=[];let n=0;const c=await i.variableLists.get(e.datasetId);if(!c||c.category!=="tabular"||!c.tabularData?.rows)return o.warn(`V4_TRIALS: Dataset ${e.datasetId} not found or invalid`),[];for(let u=0;u<a;u++)for(const p of c.tabularData.rows){const m=this.substituteVariables(e.promptPattern,p);for(let d=0;d<t.configurations.length;d++){const y={id:L("call"),trialId:t.id,configurationIndex:d,order:n++,variables:p,prompt:m,status:"pending",retryCount:0,created:new Date};r.push(y)}}return o.info(`V4_TRIALS: Generated ${r.length} REAL API calls for spreadsheet trial`),r}async generateVariableCombinations(t){const e=Object.keys(t).sort();if(e.length===0)return[{variables:{}}];const a={};for(const u of e){const p=t[u];let m=[];const d=p;if(d.snapshot)m=d.snapshot.items.map(y=>({value:y.value,attributes:y.attributes}));else if(p.type==="value"&&p.values)m=p.values.map(y=>({value:y}));else if(p.type==="list"&&p.listId){const y=await i.variableLists.get(p.listId);y&&(y.category==="simple"&&y.values?m=y.values.map(h=>({value:h})):y.category==="attributed"&&y.items?m=y.items.map(h=>({value:h.value||h.name||String(h),attributes:h.attributes||{}})):y.category==="tabular"&&y.tabularData?.rows&&(m=y.tabularData.rows.map(h=>({value:h.name||h[Object.keys(h)[0]]||String(h)}))))}a[u]=m}const n=e.map(u=>Math.max(a[u].length,1)).reduce((u,p)=>u*p,1),c=[];for(let u=0;u<n;u++){const p={},m={},d={};let y=u;for(let b=e.length-1;b>=0;b--){const A=e[b],f=a[A];if(f.length>0){const l=y%f.length,s=f[l];p[A]=s.value,d[A]=l,s.attributes&&Object.keys(s.attributes).length>0&&(m[A]={...s.attributes}),y=Math.floor(y/f.length)}else p[A]="",d[A]=0}const h={variables:p};Object.keys(m).length>0&&(h.variableAttributes=m),Object.keys(d).length>0&&(h.variableIndices=d),c.push(h)}return c}substituteVariables(t,e){let a=t;for(const[r,n]of Object.entries(e)){const c=new RegExp(`\\{\\{\\s*${r}\\s*\\}\\}`,"g");a=a.replace(c,n)}return a}validateTrialConfig(t){if(!t.name||t.name.trim().length===0)return{ok:!1,error:new Error("Trial name is required")};if(!t.configurations||t.configurations.length===0)return{ok:!1,error:new Error("At least one model configuration is required")};for(const e of t.configurations){if(!V.getProvider(e.provider))return{ok:!1,error:new Error(`Provider not found: ${e.provider}`)};const r=V.validateParameters(e.provider,e.modelId,e.parameters);if(!r.valid)return{ok:!1,error:new Error(`Invalid parameters: ${r.errors?.join(", ")||"Validation failed"}`)}}if(t.type==="template"){if(!t.templateConfig||!t.templateConfig.template)return{ok:!1,error:new Error("Template is required for template trials")}}else if(t.type==="spreadsheet"&&(!t.spreadsheetConfig||!t.spreadsheetConfig.promptPattern))return{ok:!1,error:new Error("Prompt pattern is required for spreadsheet trials")};return{ok:!0}}async createConfigurationSnapshots(t){const e=[];for(const a of t){const r=V.getProvider(a.provider);if(!r)throw new Error(`Provider not found: ${a.provider}`);const c=(await i.models.where("provider").equals(a.provider).toArray()).find(p=>p.modelId===a.modelId),u={provider:a.provider,modelId:a.modelId,parameters:a.parameters,providerSnapshot:r,modelSnapshot:c||{id:`${a.provider}:${a.modelId}`,provider:a.provider,modelId:a.modelId,displayName:a.name||a.modelId,enabled:!0,source:"user"}};e.push(u)}return e}async createVariableSnapshots(t){const e={};for(const[a,r]of Object.entries(t)){const n={...r};if(r.type==="value"&&r.values)n.snapshot={source:{type:"direct",snapshotDate:new Date},items:r.values.map(c=>({value:c}))};else if(r.type==="list"&&r.listId){const c=await i.variableLists.get(r.listId);c&&(n.snapshot=await this.snapshotVariableList(c))}e[a]=n}return e}async snapshotVariableList(t){const e={source:{type:t.category,listId:t.id,listName:t.name,snapshotDate:new Date},items:[]};switch(t.category){case"simple":case"refusal":e.items=t.values?.map(a=>({value:a}))||[];break;case"attributed":e.items=t.items?.map(a=>({value:a.value,attributes:{...a.attributes}}))||[],e.attributeKeys=[...t.attributeKeys||[]];break;case"tabular":t.tabularData?.rows&&(e.items=t.tabularData.rows.map(a=>({value:a.name||a[Object.keys(a)[0]]||""})));break}return e}}const D=new O,B=Object.freeze(Object.defineProperty({__proto__:null,V4TrialOperations:O,v4TrialOperations:D},Symbol.toStringTag,{value:"Module"}));function G(){const w=S(!1),t=S(!1),e=S(!1),a=S(!1),r=S(null),n=async l=>{w.value=!0,r.value=null;try{o.info("V4_TRIAL_COMMANDS: Creating trial with config:",l);const s=await D.createTrial(l);return s.ok?o.info("V4_TRIAL_COMMANDS: Trial created successfully:",s.value):(r.value=s.error||new Error("Failed to create trial"),o.error("V4_TRIAL_COMMANDS: Create trial failed:",s.error)),s}finally{w.value=!1}},c=async(l,s,g)=>{try{const v=await i.template_prompts.get(l);if(!v)return{ok:!1,error:new Error(`Template not found: ${l}`)};const T={name:g||`${v.name} - ${new Date().toLocaleString()}`,description:v.description,type:"template",configurations:s,repeatCount:1,templateConfig:{template:v.template,templateId:v.id,templateName:v.name,variables:v.variables||{},outputType:v.outputType,extractPattern:v.extractPattern,refusalWords:v.refusalWords?[...v.refusalWords]:void 0,refusalMode:v.refusalMode,rejectRefusalWords:v.rejectRefusalWords}};return n(T)}catch(v){return o.error("V4_TRIAL_COMMANDS: Failed to create trial from template:",v),{ok:!1,error:v instanceof Error?v:new Error("Failed to create trial from template")}}},u=async(l,s,g,v)=>{try{const T=await i.variableLists.get(s);if(!T||T.category!=="tabular")return{ok:!1,error:new Error(`Dataset not found or not tabular: ${s}`)};const C={name:v||`Spreadsheet Trial - ${new Date().toLocaleString()}`,type:"spreadsheet",configurations:g,spreadsheetConfig:{promptPattern:l,datasetId:s}};return n(C)}catch(T){return o.error("V4_TRIAL_COMMANDS: Failed to create spreadsheet trial:",T),{ok:!1,error:T instanceof Error?T:new Error("Failed to create spreadsheet trial")}}},p=async(l,s)=>{t.value=!0,r.value=null;try{const g=await D.updateTrial(l,s);return g.ok||(r.value=g.error||new Error("Failed to update trial"),o.error("V4_TRIAL_COMMANDS: Update trial failed:",g.error)),g}finally{t.value=!1}},m=async(l,s)=>p(l,{status:s}),d=async l=>{e.value=!0,r.value=null;try{o.info("V4_TRIAL_COMMANDS: Deleting trial:",l);const s=await D.deleteTrial(l);return s.ok?o.info("V4_TRIAL_COMMANDS: Trial deleted successfully"):(r.value=s.error||new Error("Failed to delete trial"),o.error("V4_TRIAL_COMMANDS: Delete trial failed:",s.error)),s}finally{e.value=!1}},y=async l=>{e.value=!0,r.value=null;try{return o.info("V4_TRIAL_COMMANDS: Deleting multiple trials:",l.length),await i.transaction("rw",i.trials,i.apiCalls,async()=>{for(const s of l){const g=await i.trials.get(s);g&&g.status!=="running"&&(await i.apiCalls.where("trialId").equals(s).delete(),await i.trials.delete(s))}}),o.info("V4_TRIAL_COMMANDS: Multiple trials deleted successfully"),{ok:!0}}catch(s){return o.error("V4_TRIAL_COMMANDS: Failed to delete multiple trials:",s),r.value=s instanceof Error?s:new Error("Failed to delete trials"),{ok:!1,error:r.value}}finally{e.value=!1}},h=async l=>{a.value=!0,r.value=null;try{o.info("V4_TRIAL_COMMANDS: Duplicating trial:",l);const s=await D.duplicateTrial(l);return s.ok?o.info("V4_TRIAL_COMMANDS: Trial duplicated successfully:",s.value):(r.value=s.error||new Error("Failed to duplicate trial"),o.error("V4_TRIAL_COMMANDS: Duplicate trial failed:",s.error)),s}finally{a.value=!1}},b=async l=>{try{let s=1;if(l.type==="template"&&l.templateConfig){const v=l.templateConfig.variables;for(const[,T]of Object.entries(v))if(T.type==="value"&&T.values)s*=T.values.length;else if(T.type==="list"&&T.listId){const C=await i.variableLists.get(T.listId);C&&(C.category==="simple"&&C.values?s*=C.values.length:C.category==="attributed"&&C.items?s*=C.items.length:C.category==="tabular"&&C.tabularData?.rows&&(s*=C.tabularData.rows.length))}}else if(l.type==="spreadsheet"&&l.spreadsheetConfig){const v=await i.variableLists.get(l.spreadsheetConfig.datasetId);v&&v.category==="tabular"&&v.tabularData?.rows&&(s=v.tabularData.rows.length)}return s*l.configurations.length*(l.repeatCount||1)}catch(s){return o.error("V4_TRIAL_COMMANDS: Failed to calculate API call count:",s),0}};return{createTrial:n,createTrialFromTemplate:c,createTrialFromSpreadsheet:u,updateTrial:p,updateTrialStatus:m,deleteTrial:d,deleteMultipleTrials:y,duplicateTrial:h,generateApiCallCount:b,estimateTrialCost:async l=>{try{const s=await b(l);let g=0;for(const v of l.configurations){const C=(await i.models.where("provider").equals(v.provider).toArray()).find(E=>E.modelId===v.modelId);if(C?.capabilities){const P=v.parameters?.max_tokens||v.parameters?.maxTokens||256,q=(C.capabilities.inputCostPerToken||0)*150,N=(C.capabilities.outputCostPerToken||0)*P;g+=(q+N)*s/l.configurations.length}}return g}catch(s){return o.error("V4_TRIAL_COMMANDS: Failed to estimate cost:",s),0}},validateTrialConfig:l=>!l.name||l.name.trim().length===0?{ok:!1,error:new Error("Trial name is required")}:!l.configurations||l.configurations.length===0?{ok:!1,error:new Error("At least one model configuration is required")}:l.type==="template"&&!l.templateConfig?{ok:!1,error:new Error("Template configuration is required for template trials")}:l.type==="spreadsheet"&&!l.spreadsheetConfig?{ok:!1,error:new Error("Spreadsheet configuration is required for spreadsheet trials")}:{ok:!0},isCreating:w,isUpdating:t,isDeleting:e,isDuplicating:a,lastError:r}}export{G as a,Q as b,B as c,U as u,D as v};
