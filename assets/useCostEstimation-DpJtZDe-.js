var at=Object.defineProperty;var it=(d,t,e)=>t in d?at(d,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):d[t]=e;var A=(d,t,e)=>it(d,typeof t!="symbol"?t+"":t,e);import{e as W,I as q,a1 as nt,a2 as ot,a3 as st,a4 as j,a as r,s as x,c as b,v as M,o as X,a5 as lt,l as Q,d as p,a6 as F,q as Y,a7 as Z,g as $,a8 as ut,a9 as G,aa as D,ab as ct,ac as dt,p as P,r as N,ad as ft,ae as pt}from"./index-BET_-Wmx.js";var ht={icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M516 673c0 4.4 3.4 8 7.5 8h185c4.1 0 7.5-3.6 7.5-8v-48c0-4.4-3.4-8-7.5-8h-185c-4.1 0-7.5 3.6-7.5 8v48zm-194.9 6.1l192-161c3.8-3.2 3.8-9.1 0-12.3l-192-160.9A7.95 7.95 0 00308 351v62.7c0 2.4 1 4.6 2.9 6.1L420.7 512l-109.8 92.2a8.1 8.1 0 00-2.9 6.1V673c0 6.8 7.9 10.5 13.1 6.1zM880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z"}}]},name:"code",theme:"outlined"};function B(d){for(var t=1;t<arguments.length;t++){var e=arguments[t]!=null?Object(arguments[t]):{},a=Object.keys(e);typeof Object.getOwnPropertySymbols=="function"&&(a=a.concat(Object.getOwnPropertySymbols(e).filter(function(i){return Object.getOwnPropertyDescriptor(e,i).enumerable}))),a.forEach(function(i){mt(d,i,e[i])})}return d}function mt(d,t,e){return t in d?Object.defineProperty(d,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):d[t]=e,d}var J=function(t,e){var a=B({},t,e.attrs);return W(q,B({},a,{icon:ht}),null)};J.displayName="CodeOutlined";J.inheritAttrs=!1;var Tt={icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494zM514.1 580.1l-61.8-102.4c-2.2-3.6-6.1-5.8-10.3-5.8h-38.4c-2.3 0-4.5.6-6.4 1.9-5.6 3.5-7.3 10.9-3.7 16.6l82.3 130.4-83.4 132.8a12.04 12.04 0 0010.2 18.4h34.5c4.2 0 8-2.2 10.2-5.7L510 664.8l62.3 101.4c2.2 3.6 6.1 5.7 10.2 5.7H620c2.3 0 4.5-.7 6.5-1.9 5.6-3.6 7.2-11 3.6-16.6l-84-130.4 85.3-132.5a12.04 12.04 0 00-10.1-18.5h-35.7c-4.2 0-8.1 2.2-10.3 5.8l-61.2 102.3z"}}]},name:"file-excel",theme:"outlined"};function z(d){for(var t=1;t<arguments.length;t++){var e=arguments[t]!=null?Object(arguments[t]):{},a=Object.keys(e);typeof Object.getOwnPropertySymbols=="function"&&(a=a.concat(Object.getOwnPropertySymbols(e).filter(function(i){return Object.getOwnPropertyDescriptor(e,i).enumerable}))),a.forEach(function(i){_t(d,i,e[i])})}return d}function _t(d,t,e){return t in d?Object.defineProperty(d,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):d[t]=e,d}var K=function(t,e){var a=z({},t,e.attrs);return W(q,z({},a,{icon:Tt}),null)};K.displayName="FileExcelOutlined";K.inheritAttrs=!1;var tt=function(d){nt(t,d);function t(e,a,i){e===void 0&&(e=1/0),a===void 0&&(a=1/0),i===void 0&&(i=ot);var n=d.call(this)||this;return n._bufferSize=e,n._windowTime=a,n._timestampProvider=i,n._buffer=[],n._infiniteTimeWindow=!0,n._infiniteTimeWindow=a===1/0,n._bufferSize=Math.max(1,e),n._windowTime=Math.max(1,a),n}return t.prototype.next=function(e){var a=this,i=a.isStopped,n=a._buffer,c=a._infiniteTimeWindow,m=a._timestampProvider,_=a._windowTime;i||(n.push(e),!c&&n.push(m.now()+_)),this._trimBuffer(),d.prototype.next.call(this,e)},t.prototype._subscribe=function(e){this._throwIfClosed(),this._trimBuffer();for(var a=this._innerSubscribe(e),i=this,n=i._infiniteTimeWindow,c=i._buffer,m=c.slice(),_=0;_<m.length&&!e.closed;_+=n?1:2)e.next(m[_]);return this._checkFinalizedStatuses(e),a},t.prototype._trimBuffer=function(){var e=this,a=e._bufferSize,i=e._timestampProvider,n=e._buffer,c=e._infiniteTimeWindow,m=(c?1:2)*a;if(a<1/0&&m<n.length&&n.splice(0,n.length-m),!c){for(var _=i.now(),T=0,h=1;h<n.length&&n[h]<=_;h+=2)T=h;T&&n.splice(0,T+1)}},t}(st);function Ct(d,t,e){var a,i,n,c,m=!1;return d&&typeof d=="object"?(a=d.bufferSize,c=a===void 0?1/0:a,i=d.windowTime,t=i===void 0?1/0:i,n=d.refCount,m=n===void 0?!1:n,e=d.scheduler):c=d??1/0,j({connector:function(){return new tt(c,t,e)},resetOnError:!0,resetOnComplete:!1,resetOnRefCountZero:m})}function wt(){const d=performance.now();r.info(`V4_TRIAL_SWITCH: useV4Trials() composable ENTRY at ${d}`);const t=x([]),e=x(!0),a=x(null);let i=null;const n=b(()=>t.value),c=()=>{const C=performance.now();r.info(`V4_TRIAL_SWITCH: setupLiveQuery() ENTRY at ${C}`),i&&(i.unsubscribe(),i=null);const l=Q(async()=>{try{return(await p.trials.orderBy("created").reverse().toArray()).filter(I=>!F(I)).map(I=>Object.freeze({...I,created:I.created instanceof Date?I.created:new Date(I.created),started:I.started?I.started instanceof Date?I.started:new Date(I.started):void 0,completed:I.completed?I.completed instanceof Date?I.completed:new Date(I.completed):void 0}))}catch(u){throw r.error("V4_TRIALS: Failed to load trials:",u),u}});i=Y(l).subscribe({next:u=>{t.value=u,e.value=!1,a.value=null,r.info(`V4_TRIALS_DB: Loaded ${u.length} trials from database`)},error:u=>{r.error("V4_TRIALS: Query error:",u),a.value=u instanceof Error?u:new Error("Failed to load trials"),e.value=!1}})},m=b(()=>n.value.filter(C=>C.status==="running")),_=b(()=>n.value.filter(C=>C.status==="draft")),T=b(()=>n.value.filter(C=>C.status==="completed")),h=b(()=>n.value.filter(C=>C.status==="paused")),s=b(()=>n.value.filter(C=>C.status==="failed")),o=b(()=>n.value.length),f=b(()=>{const C={total:n.value.length,byStatus:{draft:0,pending:0,running:0,paused:0,completed:0,cancelled:0,failed:0},totalApiCalls:0,completedApiCalls:0,failedApiCalls:0,averageCompletionRate:0};for(const l of n.value)C.byStatus[l.status]++,l.progress&&(C.totalApiCalls+=l.progress.total,C.completedApiCalls+=l.progress.completed,C.failedApiCalls+=l.progress.failed);return C.totalApiCalls>0&&(C.averageCompletionRate=C.completedApiCalls/C.totalApiCalls*100),C}),O=async()=>{e.value=!0,a.value=null;try{const u=(await p.trials.orderBy("created").reverse().toArray()).filter(g=>!F(g)).map(g=>Object.freeze({...g,created:g.created instanceof Date?g.created:new Date(g.created),started:g.started?g.started instanceof Date?g.started:new Date(g.started):void 0,completed:g.completed?g.completed instanceof Date?g.completed:new Date(g.completed):void 0}));t.value=u,e.value=!1,r.info(`V4_TRIALS: Manual refresh loaded ${u.length} trials`)}catch(C){r.error("V4_TRIALS: Refresh failed:",C),a.value=C instanceof Error?C:new Error("Failed to refresh trials"),e.value=!1}};return M(()=>{const C=performance.now();r.info(`V4_TRIAL_SWITCH: useV4Trials onMounted() ENTRY at ${C}`),r.info("V4_TRIALS: Mounting trials query composable");const l=performance.now();r.info(`V4_TRIAL_SWITCH: useV4Trials calling setupLiveQuery() at ${(l-C).toFixed(1)}ms`),c();const u=performance.now();r.info(`V4_TRIAL_SWITCH: useV4Trials setupLiveQuery() completed in ${(u-l).toFixed(1)}ms`)}),X(()=>{r.info("V4_TRIALS: Unmounting trials query composable"),i&&(i.unsubscribe(),i=null)}),{trials:n,loading:e,error:a,runningTrials:m,draftTrials:_,completedTrials:T,pausedTrials:h,failedTrials:s,totalTrials:o,statistics:f,refresh:O}}function St(d){const t=x(null),e=x(!0),a=x(null);let i=null,n=null;const c=b(()=>(typeof d=="object"&&d!==null?d.value:d)?t.value:null),m=T=>{const h=performance.now();if(r.info(`V4_TRIAL_SWITCH: Single trial query setup for ${T}`),i&&(i.unsubscribe(),i=null),!T){t.value=null,e.value=!1,r.info("V4_TRIAL_SWITCH: Single trial query cleared (no ID)");return}const s=Q(async()=>{const o=performance.now();r.info(`V4_TRIAL_SWITCH: Single trial DB query starting at ${(o-h).toFixed(1)}ms`);const f=await p.trials.get(T),O=performance.now();return r.info(`V4_TRIAL_SWITCH: Single trial DB query completed in ${(O-o).toFixed(1)}ms`),f?Object.freeze({...f,created:f.created instanceof Date?f.created:new Date(f.created),started:f.started?f.started instanceof Date?f.started:new Date(f.started):void 0,completed:f.completed?f.completed instanceof Date?f.completed:new Date(f.completed):void 0}):null});i=Y(s).subscribe({next:o=>{const f=performance.now();t.value=o,e.value=!1,a.value=null,o&&r.info(`V4_TRIAL_SWITCH: Trial ${o.id} loaded from database in ${(f-h).toFixed(1)}ms`)},error:o=>{r.error("V4_TRIALS: Single trial query error:",o),a.value=o instanceof Error?o:new Error("Failed to load trial"),e.value=!1}})},_=async()=>{const T=typeof d=="object"&&d!==null?d.value:d;if(!T){t.value=null,e.value=!1;return}e.value=!0,a.value=null;try{const h=await p.trials.get(T);h?t.value=Object.freeze({...h,created:h.created instanceof Date?h.created:new Date(h.created),started:h.started?h.started instanceof Date?h.started:new Date(h.started):void 0,completed:h.completed?h.completed instanceof Date?h.completed:new Date(h.completed):void 0}):t.value=null,e.value=!1}catch(h){r.error("V4_TRIALS: Refresh single trial failed:",h),a.value=h instanceof Error?h:new Error("Failed to refresh trial"),e.value=!1}};return typeof d=="object"&&d!==null?M(()=>{r.info("V4_TRIALS: Mounting single trial query with reactive ID"),n=lt(()=>{const T=d.value;r.info("V4_TRIALS: Trial ID changed to:",T),m(T)})}):M(()=>{r.info("V4_TRIALS: Mounting single trial query for static ID:",d),m(d)}),X(()=>{r.info("V4_TRIALS: Unmounting single trial query"),i&&(i.unsubscribe(),i=null),n&&(n(),n=null)}),{trial:c,loading:e,error:a,refresh:_}}class gt{constructor(){A(this,"state",Z({status:"idle",trialId:null,orchestratorType:null,startedAt:null,pausedAt:null,completedAt:null,tabId:null}));A(this,"currentState",b(()=>({...this.state})));A(this,"status",b(()=>this.state.status));A(this,"trialId",b(()=>this.state.trialId));A(this,"orchestratorType",b(()=>this.state.orchestratorType));A(this,"isExecuting",b(()=>["starting","running","pausing"].includes(this.state.status)));A(this,"isPaused",b(()=>this.state.status==="paused"));A(this,"isIdle",b(()=>this.state.status==="idle"))}async hydrate(){r.info("STATE_MACHINE: Hydrating state from database...");const t=await p.trials.where("status").equals("running").toArray();if(t.length>0){r.info(`STATE_MACHINE: Found ${t.length} running trials, marking as paused (page refreshed)`);for(const e of t)await p.trials.update(e.id,{status:"paused"}),r.info(`STATE_MACHINE: Paused trial ${e.id} (was running, page refreshed)`)}r.info("STATE_MACHINE: State machine starting idle - use resume to continue paused trials")}async startExecution(t,e,a){if(r.info(`STATE_MACHINE: Starting execution - trial=${t}, orchestrator=${e}, tab=${a}`),this.state.status!=="idle"&&this.state.status!=="paused")return{ok:!1,error:new Error(`Cannot start: current status is ${this.state.status}`)};try{return this.state.status="starting",this.state.trialId=t,this.state.orchestratorType=e,this.state.tabId=a,this.state.startedAt=new Date,this.state.pausedAt=null,this.state.completedAt=null,await p.trials.update(t,{status:"running",started:this.state.startedAt}),this.state.status="running",r.info(`STATE_MACHINE: Successfully started execution for trial ${t}`),{ok:!0,value:void 0}}catch(i){return this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,{ok:!1,error:i instanceof Error?i:new Error("Failed to start execution")}}}async pauseExecution(){if(r.info(`STATE_MACHINE: Pausing execution - current status=${this.state.status}`),this.state.status!=="running")return{ok:!1,error:new Error(`Cannot pause: current status is ${this.state.status}`)};if(!this.state.trialId)return{ok:!1,error:new Error("Cannot pause: no active trial")};try{return this.state.status="pausing",this.state.pausedAt=new Date,await p.trials.update(this.state.trialId,{status:"paused"}),this.state.status="paused",r.info(`STATE_MACHINE: Successfully paused execution for trial ${this.state.trialId}`),{ok:!0,value:void 0}}catch(t){return this.state.status="running",this.state.pausedAt=null,{ok:!1,error:t instanceof Error?t:new Error("Failed to pause execution")}}}async resumeExecution(t,e){if(r.info(`STATE_MACHINE: Resuming trial ${t} - current status=${this.state.status}, tab=${e}`),!["idle","paused"].includes(this.state.status))return{ok:!1,error:new Error(`Cannot resume: current status is ${this.state.status}`)};try{const a=await p.trials.get(t);if(!a)return{ok:!1,error:new Error(`Trial ${t} not found`)};if(a.status!=="paused")return{ok:!1,error:new Error(`Cannot resume: trial status is ${a.status}, expected paused`)};const i=a.type==="playground"?"streaming":"regular";return this.state.status="running",this.state.trialId=t,this.state.orchestratorType=i,this.state.tabId=e,this.state.startedAt=a.started||new Date,this.state.pausedAt=null,this.state.completedAt=null,await p.trials.update(t,{status:"running"}),r.info(`STATE_MACHINE: Successfully resumed execution for trial ${t}`),{ok:!0,value:void 0}}catch(a){return this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,this.state.pausedAt=null,{ok:!1,error:a instanceof Error?a:new Error("Failed to resume execution")}}}async cancelExecution(){if(r.info(`STATE_MACHINE: Cancelling execution - current status=${this.state.status}`),!["running","paused","starting"].includes(this.state.status))return{ok:!1,error:new Error(`Cannot cancel: current status is ${this.state.status}`)};if(!this.state.trialId)return{ok:!1,error:new Error("Cannot cancel: no active trial")};try{const t=this.state.trialId;return this.state.status="cancelling",this.state.completedAt=new Date,await p.trials.update(t,{status:"cancelled",completed:this.state.completedAt}),this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,this.state.pausedAt=null,r.info(`STATE_MACHINE: Successfully cancelled execution for trial ${t}`),{ok:!0,value:void 0}}catch(t){return this.state.status=this.state.pausedAt?"paused":"running",this.state.completedAt=null,{ok:!1,error:t instanceof Error?t:new Error("Failed to cancel execution")}}}async completeExecution(){if(r.info(`STATE_MACHINE: Completing execution - current status=${this.state.status}`),this.state.status!=="running")return{ok:!1,error:new Error(`Cannot complete: current status is ${this.state.status}`)};if(!this.state.trialId)return{ok:!1,error:new Error("Cannot complete: no active trial")};try{const t=this.state.trialId;return this.state.status="completed",this.state.completedAt=new Date,await p.trials.update(t,{status:"completed",completed:this.state.completedAt}),this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,this.state.pausedAt=null,r.info(`STATE_MACHINE: Successfully completed execution for trial ${t}`),{ok:!0,value:void 0}}catch(t){return this.state.status="running",this.state.completedAt=null,{ok:!1,error:t instanceof Error?t:new Error("Failed to complete execution")}}}canStart(){return this.state.status==="idle"||this.state.status==="paused"}canPause(){return this.state.status==="running"}canResume(){return this.state.status==="paused"&&this.state.orchestratorType!==null}canCancel(){return["running","paused","starting"].includes(this.state.status)}isOwnedByTab(t){return this.state.tabId===t}}const v=new gt;class Et{constructor(){A(this,"state",Z({tabId:$("tab"),role:"observer",isInitialized:!1,lastHeartbeat:new Date}));A(this,"broadcastChannel",null);A(this,"lockReleaseFunction",null);A(this,"heartbeatInterval",null);A(this,"tabId",b(()=>this.state.tabId));A(this,"role",b(()=>this.state.role));A(this,"isLeader",b(()=>this.state.role==="leader"));A(this,"isObserver",b(()=>this.state.role==="observer"));A(this,"isInitialized",b(()=>this.state.isInitialized))}async initialize(){if(this.state.isInitialized){r.info(`COORDINATION: Tab ${this.state.tabId} already initialized as ${this.state.role}`);return}r.info(`COORDINATION: Initializing tab ${this.state.tabId}`);try{this.broadcastChannel=new BroadcastChannel("auditomatic-coordination"),this.broadcastChannel.onmessage=t=>{this.handleCoordinationMessage(t.data)},await this.attemptLeadershipAcquisition(),this.startHeartbeat(),this.state.isInitialized=!0,r.info(`COORDINATION: Tab ${this.state.tabId} initialized as ${this.state.role}`)}catch(t){throw r.error(`COORDINATION: Failed to initialize tab ${this.state.tabId}:`,t),t}}async attemptLeadershipAcquisition(){if(!("locks"in navigator)){r.info(`COORDINATION: Web Locks not available, tab ${this.state.tabId} becomes leader`),this.state.role="leader";return}try{r.info(`COORDINATION: Tab ${this.state.tabId} attempting to acquire leadership lock`),navigator.locks.request("auditomatic-leader",{mode:"exclusive",ifAvailable:!0},t=>{if(t)return r.info(`COORDINATION: Tab ${this.state.tabId} acquired leadership lock`),this.state.role="leader",new Promise(e=>{this.lockReleaseFunction=e});r.info(`COORDINATION: Tab ${this.state.tabId} could not acquire lock - observer mode`),this.state.role="observer"}),await new Promise(t=>setTimeout(t,50))}catch(t){r.error(`COORDINATION: Leadership acquisition failed for tab ${this.state.tabId}:`,t),this.state.role="observer"}}startHeartbeat(){this.heartbeatInterval=setInterval(()=>{this.state.lastHeartbeat=new Date,this.broadcast({type:"heartbeat",tabId:this.state.tabId,timestamp:this.state.lastHeartbeat})},1e4)}broadcast(t){this.broadcastChannel&&(r.info(`COORDINATION: Broadcasting ${t.type} from tab ${this.state.tabId}`),this.broadcastChannel.postMessage(t))}handleCoordinationMessage(t){if(t.tabId!==this.state.tabId)switch(r.info(`COORDINATION: Tab ${this.state.tabId} received ${t.type} from ${t.tabId}`),t.type){case"execution:started":this.state.role==="observer"&&t.trialId&&r.info(`COORDINATION: Observer tab syncing to started execution: ${t.trialId}`);break;case"execution:paused":this.state.role==="observer"&&t.trialId&&r.info(`COORDINATION: Observer tab syncing to paused execution: ${t.trialId}`);break;case"execution:resumed":this.state.role==="observer"&&t.trialId&&r.info(`COORDINATION: Observer tab syncing to resumed execution: ${t.trialId}`);break;case"execution:cancelled":case"execution:completed":this.state.role==="observer"&&t.trialId&&r.info(`COORDINATION: Observer tab syncing to ended execution: ${t.trialId}`);break;case"heartbeat":r.info(`COORDINATION: Heartbeat from ${t.tabId}`);break}}canExecuteActions(){return this.state.role==="leader"}validateLeadership(t){return this.state.role!=="leader"?{ok:!1,error:new Error(`Cannot ${t}: only leader tab can execute actions`)}:{ok:!0,value:void 0}}async startExecution(t,e){const a=this.validateLeadership("start execution");if(!a.ok)return a;r.info(`COORDINATION: Leader starting execution - trial=${t}, orchestrator=${e}`);const i=await v.startExecution(t,e,this.state.tabId);return i.ok&&this.broadcast({type:"execution:started",tabId:this.state.tabId,timestamp:new Date,trialId:t,orchestratorType:e}),i}async pauseExecution(){const t=this.validateLeadership("pause execution");if(!t.ok)return t;r.info("COORDINATION: Leader pausing execution");const e=await v.pauseExecution();return e.ok&&this.broadcast({type:"execution:paused",tabId:this.state.tabId,timestamp:new Date,trialId:v.trialId.value||void 0}),e}async resumeExecution(t){const e=this.validateLeadership("resume execution");if(!e.ok)return e;r.info(`COORDINATION: Leader resuming execution for trial ${t}`);const a=await v.resumeExecution(t,this.state.tabId);return a.ok&&this.broadcast({type:"execution:resumed",tabId:this.state.tabId,timestamp:new Date,trialId:t}),a}async cancelExecution(){const t=this.validateLeadership("cancel execution");if(!t.ok)return t;r.info("COORDINATION: Leader cancelling execution");const e=v.trialId.value,a=await v.cancelExecution();return a.ok&&this.broadcast({type:"execution:cancelled",tabId:this.state.tabId,timestamp:new Date,trialId:e||void 0}),a}async completeExecution(){const t=this.validateLeadership("complete execution");if(!t.ok)return t;r.info("COORDINATION: Leader completing execution");const e=v.trialId.value,a=await v.completeExecution();return a.ok&&this.broadcast({type:"execution:completed",tabId:this.state.tabId,timestamp:new Date,trialId:e||void 0}),a}destroy(){r.info(`COORDINATION: Destroying tab ${this.state.tabId}`),this.heartbeatInterval&&(clearInterval(this.heartbeatInterval),this.heartbeatInterval=null),this.lockReleaseFunction&&(this.lockReleaseFunction(),this.lockReleaseFunction=null),this.broadcastChannel&&(this.broadcastChannel.close(),this.broadcastChannel=null),this.state.isInitialized=!1,r.info(`COORDINATION: Tab ${this.state.tabId} cleanup complete`)}}const R=new Et;class It{async updateTrial(t){r.info(`ATOMIC_OPS: Updating trial ${t.trialId} - status=${t.status}`);try{const e={};return t.status!==void 0&&(e.status=t.status),t.started!==void 0&&(e.started=t.started),t.completed!==void 0&&(e.completed=t.completed),t.progress!==void 0&&(e.progress=t.progress),await p.trials.update(t.trialId,e),r.info(`ATOMIC_OPS: Successfully updated trial ${t.trialId}`),{ok:!0,value:void 0}}catch(e){return r.error(`ATOMIC_OPS: Failed to update trial ${t.trialId}:`,e),{ok:!1,error:e instanceof Error?e:new Error("Failed to update trial")}}}async resetRunningCallsToPending(t){r.info(`ATOMIC_OPS: Resetting running calls to pending for trial ${t}`);try{const e=await p.apiCalls.where("trialId").equals(t).and(a=>a.status==="running").toArray();return e.length===0?r.info(`ATOMIC_OPS: No running calls found for trial ${t}`):(await p.transaction("rw",p.apiCalls,async()=>{for(const a of e)await p.apiCalls.update(a.id,{status:"pending",started:void 0,response:void 0,result:void 0})}),r.info(`ATOMIC_OPS: Reset ${e.length} running calls to pending for trial ${t}`)),r.info("V4_TRIAL_DEBUG_PAUSE: Recalculating trial progress after call status changes"),await this.recalculateTrialProgress(t),{ok:!0,value:e.length}}catch(e){return r.error(`ATOMIC_OPS: Failed to reset running calls for trial ${t}:`,e),{ok:!1,error:e instanceof Error?e:new Error("Failed to reset running calls")}}}async getTrialCallCounts(t){r.info(`ATOMIC_OPS: Getting call counts for trial ${t}`);try{const e=await p.transaction("r",p.apiCalls,async()=>{const a=await p.apiCalls.where("trialId").equals(t).toArray();return{total:a.length,completed:a.filter(i=>i.status==="completed").length,failed:a.filter(i=>i.status==="failed").length,cancelled:a.filter(i=>i.status==="cancelled").length,pending:a.filter(i=>i.status==="pending").length,running:a.filter(i=>i.status==="running").length}});return r.info(`TRANSACTION_FIX: Trial ${t} call counts (consistent snapshot):`,e),{ok:!0,value:e}}catch(e){return r.error(`ATOMIC_OPS: Failed to get call counts for trial ${t}:`,e),{ok:!1,error:e instanceof Error?e:new Error("Failed to get call counts")}}}async updateApiCallsBatch(t){if(t.length===0)return{ok:!0,value:void 0};r.info(`ATOMIC_OPS: Updating batch of ${t.length} API calls`);try{return await p.transaction("rw",p.apiCalls,async()=>{for(const e of t){const a={status:e.status};e.started!==void 0&&(a.started=e.started),e.completed!==void 0&&(a.completed=e.completed),e.response!==void 0&&(a.response=e.response),e.error!==void 0&&(a.error=e.error),await p.apiCalls.update(e.callId,a)}}),r.info(`ATOMIC_OPS: Successfully updated batch of ${t.length} API calls`),{ok:!0,value:void 0}}catch(e){return r.error("ATOMIC_OPS: Failed to update API calls batch:",e),{ok:!1,error:e instanceof Error?e:new Error("Failed to update API calls batch")}}}async reconcileTrialState(t){r.info(`ATOMIC_OPS: Reconciling state for trial ${t}`);try{const e=await p.trials.get(t);if(!e)return{ok:!1,error:new Error(`Trial ${t} not found`)};const a=await this.getTrialCallCounts(t);if(!a.ok)return a;const i=a.value;let n=e.status;if(i.running>0?n="running":i.pending>0?n="paused":i.completed===i.total&&i.total>0||i.failed>0&&i.completed+i.failed===i.total?n="completed":i.cancelled>0&&(n="cancelled"),n!==e.status){r.info(`ATOMIC_OPS: Reconciling trial ${t} status: ${e.status} â†’ ${n}`);const c=await this.updateTrial({trialId:t,status:n,progress:i,...n==="completed"&&{completed:new Date}});if(!c.ok)return c}else r.info(`ATOMIC_OPS: Trial ${t} status is consistent: ${n}`);return{ok:!0,value:n}}catch(e){return r.error(`ATOMIC_OPS: Failed to reconcile trial ${t} state:`,e),{ok:!1,error:e instanceof Error?e:new Error("Failed to reconcile trial state")}}}async performCleanupOperations(t){r.info(`ATOMIC_OPS: Performing cleanup operations for trial ${t}`);try{const e=await this.resetRunningCallsToPending(t);if(!e.ok)return e;const a=await this.reconcileTrialState(t);if(!a.ok)return a;const i={resetCount:e.value,reconciledStatus:a.value};return r.info(`ATOMIC_OPS: Cleanup complete for trial ${t}:`,i),{ok:!0,value:i}}catch(e){return r.error(`ATOMIC_OPS: Failed cleanup operations for trial ${t}:`,e),{ok:!1,error:e instanceof Error?e:new Error("Failed cleanup operations")}}}async recalculateTrialProgress(t){var e;try{const a=await p.trials.get(t);if(!a){r.info(`V4_TRIAL_DEBUG_PAUSE: Trial ${t} not found, cannot recalculate progress`);return}const i=await p.apiCalls.where("trialId").equals(t).toArray();let n=0,c=0,m=0,_=0,T=0;for(const o of i)switch(o.status){case"completed":n++;break;case"failed":c++,((e=o.result)==null?void 0:e.errorType)==="network_error_no_response"&&T++;break;case"cancelled":m++;break;case"running":_++;break}const h=a.progress.total-n-c-m-_,s={total:a.progress.total,completed:n,failed:c,cancelled:m,pending:h,running:_,networkErrors:T};r.info(`V4_TRIAL_DEBUG_PAUSE: Recalculated progress for trial ${t} - completed: ${n}, failed: ${c}, running: ${_}, pending: ${h}`),await p.trials.update(t,{progress:s}),r.info("V4_TRIAL_DEBUG_PAUSE: Trial progress updated successfully")}catch(a){r.error(`V4_TRIAL_DEBUG_PAUSE: Failed to recalculate progress for trial ${t}:`,a)}}async performSystemCleanup(){r.info("ATOMIC_OPS: Performing system-wide cleanup");try{let t=0,e=0;const a=await p.trials.where("status").equals("running").toArray();r.info(`ATOMIC_OPS: Found ${a.length} active trials for cleanup`);for(const n of a){const c=await this.performCleanupOperations(n.id);if(c.ok)t+=c.value.resetCount,e++;else{const m=c;r.warn(`ATOMIC_OPS: Failed to cleanup trial ${n.id}:`,m.error.message)}}const i={trialsProcessed:e,callsReset:t};return r.info("ATOMIC_OPS: System cleanup complete:",i),{ok:!0,value:i}}catch(t){return r.error("ATOMIC_OPS: System cleanup failed:",t),{ok:!1,error:t instanceof Error?t:new Error("System cleanup failed")}}}}const vt=new It;class Ot{constructor(){A(this,"playgroundService",null);A(this,"initialized",!1);A(this,"orchestrators",new Map);A(this,"activeStreams",new Map);A(this,"execution",b(()=>{const t=v.status.value;let e="idle";return t==="running"||t==="starting"||t==="pausing"?e="executing":t==="paused"?e="paused":e="idle",{status:e,currentTrialId:v.trialId.value,startedAt:v.currentState.value.startedAt}}));A(this,"progress",b(()=>({trials:new Map,activeApiCall:null,lastUpdated:new Date})));A(this,"queue",b(()=>({global:{pending:0,executing:0,capacity:0,utilization:0},providers:new Map})));A(this,"tabRole",b(()=>R.role.value));A(this,"isLeader",b(()=>R.isLeader.value));A(this,"canExecute",b(()=>R.isLeader.value&&v.canStart()))}async initialize(){const t=performance.now();if(r.info(`V4_TRIAL_SWITCH: V4ExecutionControl initialize() ENTRY at ${t}`),r.info(`V4_SINGLETON_DEBUG: Current initialized flag: ${this.initialized}`),r.info(`V4_SINGLETON_DEBUG: Active streams count: ${this.activeStreams.size}`),this.initialized){r.info("V4_SINGLETON_DEBUG: V4ExecutionControl already initialized, returning early - singleton working correctly!");return}try{r.info("V4_EXECUTION_CONTROL: Initializing with V4 coordination + V3 execution bridge");const e=performance.now();r.info(`V4_TRIAL_SWITCH: Starting multiTabCoordinator.initialize() at ${(e-t).toFixed(1)}ms`),await R.initialize();const a=performance.now();r.info(`V4_TRIAL_SWITCH: multiTabCoordinator.initialize() completed in ${(a-e).toFixed(1)}ms`),r.info("V4_EXECUTION_CONTROL: Performing system cleanup with V4 atomic operations");const i=performance.now();r.info(`V4_TRIAL_SWITCH: Starting atomicOperations.performSystemCleanup() at ${(i-t).toFixed(1)}ms`);const n=await vt.performSystemCleanup(),c=performance.now();if(r.info(`V4_TRIAL_SWITCH: atomicOperations.performSystemCleanup() completed in ${(c-i).toFixed(1)}ms`),n.ok)r.info("V4_EXECUTION_CONTROL: System cleanup completed:",n.value);else{const h=n;r.warn("V4_EXECUTION_CONTROL: System cleanup failed:",h.error)}const m=performance.now();r.info(`V4_TRIAL_SWITCH: Creating PlaygroundExecutionService at ${(m-t).toFixed(1)}ms`),this.playgroundService=new ut(async h=>{const s=await this.startTrialWithStreaming(h);return s.ok?{ok:!0,value:s.value.progress$}:s});const _=performance.now();r.info(`V4_TRIAL_SWITCH: PlaygroundExecutionService created in ${(_-m).toFixed(1)}ms`),this.initialized=!0;const T=performance.now();r.info(`V4_TRIAL_SWITCH: V4ExecutionControl initialization TOTAL: ${(T-t).toFixed(1)}ms`),r.info("V4_EXECUTION_CONTROL: Initialization complete")}catch(e){const a=performance.now();throw r.error(`V4_TRIAL_SWITCH: V4ExecutionControl initialization FAILED in ${(a-t).toFixed(1)}ms:`,e),e}}cleanup(){r.info("V4_SINGLETON_DEBUG: cleanup() called - this will reset initialized flag and destroy singleton!"),r.info(`V4_SINGLETON_DEBUG: Current active streams: ${this.activeStreams.size}`),r.info(`V4_SINGLETON_DEBUG: Current orchestrators: ${this.orchestrators.size}`);try{this.activeStreams.forEach((t,e)=>{r.info(`V4_SINGLETON_DEBUG: Cleaning up streams for trial ${e}`),t.subscription.unsubscribe()}),this.activeStreams.clear(),this.orchestrators.forEach((t,e)=>{r.info(`V4_SINGLETON_DEBUG: Cleaning up orchestrator for trial ${e}`)}),this.orchestrators.clear(),R.destroy(),this.playgroundService=null,this.initialized=!1,r.info("V4_SINGLETON_DEBUG: Cleanup complete - singleton destroyed, will reinitialize on next call")}catch(t){r.error("V4_EXECUTION_CONTROL: Cleanup error:",t)}}async startTrial(t){var e;this.initialized||await this.initialize(),r.info(`V4_EXECUTION_CONTROL: Starting trial ${t} with V4+V3 bridge`);try{if(G(t)){const m=await(((e=this.playgroundService)==null?void 0:e.executePlaygroundCall("",{}))||Promise.resolve({ok:!1,error:new Error("Playground service not available")}));return m.ok?{ok:!0,value:void 0}:{ok:!1,error:m.error}}let i=this.orchestrators.get(t);i||(r.info("V4_EXECUTION_CONTROL: Creating fresh V3 orchestrator for trial:",t),i=D(),this.orchestrators.set(t,i));const c=await i.startTrialAtomic(t);return c.ok?(r.info(`V4_EXECUTION_CONTROL: Successfully started trial ${t} via bridge`),{ok:!0,value:void 0}):{ok:!1,error:c.error}}catch(a){return r.error(`V4_EXECUTION_CONTROL: Failed to start trial ${t}:`,a),{ok:!1,error:a instanceof Error?a:new Error("Failed to start trial")}}}async startTrialWithStreaming(t){this.initialized||await this.initialize(),r.info(`V4_EXECUTION_CONTROL: Starting streaming trial ${t}`),this.cleanupStreams(t);try{if(G(t))return r.info("V4_EXECUTION_CONTROL: Playground trial detected, using specialized handling"),{ok:!1,error:new Error("Playground streaming not yet implemented in V4")};if(!this.canExecute.value)return r.info("V4_EXECUTION_CONTROL: Cannot start - not leader or invalid state"),{ok:!1,error:new Error("Cannot start trial - not leader or invalid state")};r.info("V4_EXECUTION_CONTROL: Updating state machine to running");const a=R.tabId.value,i=await v.startExecution(t,"streaming",a);if(!i.ok)return r.info("V4_EXECUTION_CONTROL: State machine update failed:",i.error),{ok:!1,error:i.error};let n=this.orchestrators.get(t);n||(r.info("V4_EXECUTION_CONTROL: Creating fresh V3 orchestrator for trial:",t),n=D(),this.orchestrators.set(t,n)),r.info("V4_EXECUTION_CONTROL: Calling V3 orchestrator startTrialAtomicWithStreaming");const c=await n.startTrialAtomicWithStreaming(t);if(!c.ok)return{ok:!1,error:c.error};r.info("V4_EXECUTION_CONTROL: Creating hot observables without accumulation"),r.info(`V4_EXECUTION_CONTROL: Creating hot observables for trial ${t}`);const m=c.value.progress$.pipe(j(),Ct({bufferSize:1,refCount:!0})),_=new ct,T=new tt(1),h=c.value.calls$.pipe(dt(o=>(r.info(`V4_EXECUTION_CONTROL: Batch of ${o.length} calls from pipeline`),o.map(f=>f.call&&f.providerId?f.call:f)))).subscribe({next:o=>{r.info(`V4_EXECUTION_CONTROL: Forwarding ${o.length} calls to subject`),T.next(o)},error:o=>{r.info("V4_TRIAL_ERROR: Error in calls stream:",o),T.error(o)},complete:()=>{r.info(`V4_TRIAL_COMPLETE: Original calls stream completed for trial ${t}`)}});_.add(h);const s=T;return r.info("V4_TRIAL_REF_TEST: callsSubject === sharedCalls$?",T===s),_.add(m.subscribe({next:o=>{r.info(`V4_TRIAL_DEBUG_COMPLETION: Progress update for trial ${t}: ${o.type}`),(o.type==="completed"||o.type==="error")&&(r.info(`V4_TRIAL_DEBUG_COMPLETION: Trial ${t} ${o.type}, scheduling cleanup in 1000ms`),r.info(`V4_TRIAL_DEBUG_COMPLETION: Current execution state: ${v.status.value}`),r.info("V4_TRIAL_DEBUG_COMPLETION: Updating V4 coordination layer to completed/cancelled state"),o.type==="completed"?(r.info("V4_TRIAL_DEBUG_COMPLETION: Calling multiTabCoordinator.completeExecution()"),R.completeExecution().then(f=>{f.ok?(r.info("V4_TRIAL_DEBUG_COMPLETION: Coordination layer updated to completed successfully"),r.info(`V4_TRIAL_DEBUG_COMPLETION: Post-completion execution state: ${v.status.value}`)):r.error("V4_TRIAL_DEBUG_COMPLETION: Coordination layer completion update failed:",f.error)})):(r.info("V4_TRIAL_DEBUG_COMPLETION: Calling multiTabCoordinator.cancelExecution() for error"),R.cancelExecution().then(f=>{f.ok?(r.info("V4_TRIAL_DEBUG_COMPLETION: Coordination layer updated to cancelled successfully"),r.info(`V4_TRIAL_DEBUG_COMPLETION: Post-cancellation execution state: ${v.status.value}`)):r.error("V4_TRIAL_DEBUG_COMPLETION: Coordination layer cancellation update failed:",f.error)})),setTimeout(()=>{r.info(`V4_TRIAL_DEBUG_COMPLETION: Executing delayed cleanup for trial ${t}`),r.info(`V4_TRIAL_DEBUG_COMPLETION: Post-completion execution state: ${v.status.value}`),this.cleanupStreams(t),this.orchestrators.has(t)&&(r.info(`V4_TRIAL_DEBUG_COMPLETION: Removing orchestrator for completed trial ${t}`),this.orchestrators.delete(t))},1e3))},error:o=>{r.error(`V4_TRIAL_DEBUG_COMPLETION: Stream error for trial ${t}:`,o),r.info("V4_TRIAL_DEBUG_COMPLETION: Updating V4 coordination layer to cancelled state due to error"),R.cancelExecution().then(f=>{f.ok?(r.info("V4_TRIAL_DEBUG_COMPLETION: Coordination layer updated to cancelled after error"),r.info(`V4_TRIAL_DEBUG_COMPLETION: Post-error execution state: ${v.status.value}`)):r.error("V4_TRIAL_DEBUG_COMPLETION: Coordination layer error cancellation failed:",f.error)}),this.cleanupStreams(t),this.orchestrators.has(t)&&(r.info(`V4_TRIAL_DEBUG_COMPLETION: Removing orchestrator for errored trial ${t}`),this.orchestrators.delete(t))}})),r.info(`V4_TRIAL_STORE: Storing activeStreams for trial ${t}`),this.activeStreams.set(t,{streams:c.value,subscription:_,sharedProgress$:m,sharedCalls$:s,callsSubject:T}),r.info(`V4_EXECUTION_CONTROL: Successfully created hot observables for trial ${t}`),{ok:!0,value:c.value}}catch(e){return r.error(`V4_EXECUTION_CONTROL: Failed to start streaming trial ${t}:`,e),{ok:!1,error:e instanceof Error?e:new Error("Failed to start streaming trial")}}}async pauseExecution(){this.initialized||await this.initialize();const t=v.trialId.value;if(r.info(`V4_TRIAL_DEBUG_PAUSE: pauseExecution() ENTRY for trial ${t||"NONE"}`),r.info(`V4_TRIAL_DEBUG_PAUSE: Current execution state: ${v.status.value}`),r.info(`V4_TRIAL_DEBUG_PAUSE: Active streams count: ${this.activeStreams.size}`),!t)return r.info("V4_TRIAL_DEBUG_PAUSE: ERROR - No active trial to pause"),{ok:!1,error:new Error("No active trial to pause")};if(!v.canPause())return r.info("V4_TRIAL_DEBUG_PAUSE: Cannot pause - invalid state"),{ok:!1,error:new Error("Cannot pause in current state")};r.info("V4_TRIAL_DEBUG_PAUSE: Calling V3 orchestrator pauseTrial FIRST");const e=this.orchestrators.get(t);e&&(await e.pauseTrial(),r.info("V4_TRIAL_DEBUG_PAUSE: V3 pipeline paused, keeping orchestrator alive for potential hot resume")),r.info("V4_TRIAL_DEBUG_PAUSE: V3 paused, now updating state machine to paused");const a=await v.pauseExecution();return a.ok?(R.pauseExecution(),r.info("V4_TRIAL_DEBUG_PAUSE: Pause successful"),{ok:!0,value:void 0}):(r.info("V4_TRIAL_DEBUG_PAUSE: State machine update failed:",a.error),a)}async resumeExecution(t){this.initialized||await this.initialize();const e=t||v.trialId.value;if(r.info(`V4_TRIAL_DEBUG_RESUME: resumeExecution() ENTRY for trial ${e||"NONE"}`),r.info(`V4_TRIAL_DEBUG_RESUME: Current execution state: ${v.status.value}`),r.info(`V4_TRIAL_DEBUG_RESUME: Active streams count: ${this.activeStreams.size}`),r.info(`V4_TRIAL_DEBUG_RESUME: Provided trialId: ${t||"NONE"}, state trialId: ${v.trialId.value||"NONE"}`),!e)return r.info("V4_TRIAL_DEBUG_RESUME: ERROR - No trial ID provided and no active trial to resume"),{ok:!1,error:new Error("No trial ID provided and no active trial to resume")};if(!v.canResume())return r.info("V4_TRIAL_DEBUG_RESUME: Cannot resume - invalid state"),{ok:!1,error:new Error("Cannot resume in current state")};r.info("V4_TRIAL_DEBUG_RESUME: Updating state machine to running");const a=R.tabId.value,i=await v.resumeExecution(e,a);if(!i.ok)return r.info("V4_TRIAL_DEBUG_RESUME: State machine update failed:",i.error),i;let n=this.orchestrators.get(e);if(n)r.info(`V4_TRIAL_DEBUG_RESUME: HOT RESUME - Found existing orchestrator for trial ${e}`),r.info("V4_TRIAL_DEBUG_RESUME: Calling orchestrator.resumeTrial() to flip pause$ and resume pipeline"),n.resumeTrial();else{r.info(`V4_TRIAL_DEBUG_RESUME: COLD RESUME - No orchestrator found for trial ${e}`),r.info("V4_TRIAL_DEBUG_RESUME: Creating fresh orchestrator and starting with pending calls"),n=D(),this.orchestrators.set(e,n),r.info("V4_TRIAL_DEBUG_RESUME: Calling startTrialAtomicWithStreaming to create new pipeline");const c=await n.startTrialAtomicWithStreaming(e);if(!c.ok)return r.error("V4_TRIAL_DEBUG_RESUME: Failed to start trial for cold resume:",c.error),{ok:!1,error:c.error};r.info("V4_TRIAL_DEBUG_RESUME: Cold resume successful, storing new streams")}return R.resumeExecution(e),r.info("V4_TRIAL_DEBUG_RESUME: Resume successful"),{ok:!0,value:void 0}}async cancelExecution(){this.initialized||await this.initialize(),r.info("V4_EXECUTION_CONTROL: Cancelling execution");const t=v.trialId.value;if(!t)return{ok:!1,error:new Error("No active trial to cancel")};if(!v.canCancel())return r.info("V4_EXECUTION_CONTROL: Cannot cancel - invalid state"),{ok:!1,error:new Error("Cannot cancel in current state")};r.info("V4_EXECUTION_CONTROL: Updating state machine to cancelled");const e=await v.cancelExecution();if(!e.ok)return r.info("V4_EXECUTION_CONTROL: State machine update failed:",e.error),e;r.info("V4_EXECUTION_CONTROL: Calling V3 orchestrator cancelTrial");const a=this.orchestrators.get(t);return a&&(a.cancelTrial(),r.info("V4_EXECUTION_CONTROL: Removing orchestrator after cancel"),this.orchestrators.delete(t)),R.cancelExecution(),this.cleanupStreams(t),r.info("V4_EXECUTION_CONTROL: Cancel successful"),{ok:!0,value:void 0}}async executeSingleCall(t,e,a){return this.initialized||await this.initialize(),this.playgroundService?this.playgroundService.executePlaygroundCall(t,a):{ok:!1,error:new Error("Playground service not initialized")}}getActiveStreams(t){const e=this.activeStreams.get(t);return r.info(`V4_TRIAL_GET: getActiveStreams(${t}) called, found: ${!!e}, has sharedCalls$: ${!!(e!=null&&e.sharedCalls$)}`),e}cleanupStreams(t){r.info(`V4_TRIAL_DEBUG_CLEANUP: cleanupStreams() ENTRY for trial ${t}`),r.info(`V4_TRIAL_DEBUG_CLEANUP: Current execution state: ${v.status.value}`),r.info(`V4_TRIAL_DEBUG_CLEANUP: Current state trialId: ${v.trialId.value}`);const e=this.activeStreams.get(t);e?(r.info(`V4_TRIAL_DEBUG_CLEANUP: Found streams for trial ${t}, unsubscribing`),e.subscription.unsubscribe(),this.activeStreams.delete(t),r.info(`V4_TRIAL_DEBUG_CLEANUP: Cleaned up streams, remaining active streams: ${this.activeStreams.size}`)):r.info(`V4_TRIAL_DEBUG_CLEANUP: No streams found for trial ${t} (already cleaned up?)`)}}let U=null;function Rt(){return U||(U=new Ot),U}class At{async createTrial(t){try{const e=this.validateTrialConfig(t);if(!e.ok)return{ok:!1,error:e.error};const a=await this.createConfigurationSnapshots(t.configurations),i={id:$("trial"),name:t.name,description:t.description,type:t.type,status:"draft",configurations:a,progress:{total:0,completed:0,failed:0,cancelled:0,pending:0,running:0,networkErrors:0},created:new Date,...t.repeatCount&&t.repeatCount>1?{repeatConfig:{callsPerPrompt:t.repeatCount}}:{},...t.type==="template"&&t.templateConfig?{templateConfig:{...t.templateConfig,template:t.templateConfig.template,variables:t.templateConfig.variables,outputType:t.templateConfig.outputType,extractPattern:t.templateConfig.extractPattern,refusalWords:t.templateConfig.refusalWords,rejectRefusalWords:t.templateConfig.rejectRefusalWords}}:{},...t.type==="spreadsheet"&&t.spreadsheetConfig?{spreadsheetConfig:t.spreadsheetConfig}:{}},n=await this.generateApiCalls(i,t.repeatCount||1);return i.progress.total=n.length,i.progress.pending=n.length,await p.transaction("rw",p.trials,p.apiCalls,async()=>{await p.trials.add(i),n.length>0&&await p.apiCalls.bulkAdd(n)}),r.info(`V4_TRIALS: Created trial ${i.id} with ${n.length} API calls`),{ok:!0,value:i.id}}catch(e){return r.error("V4_TRIALS: Failed to create trial:",e),{ok:!1,error:e instanceof Error?e:new Error("Failed to create trial")}}}async updateTrial(t,e){try{return await p.transaction("rw",p.trials,async()=>{const a=await p.trials.get(t);if(!a)throw new Error(`Trial not found: ${t}`);const i={...a,...e,created:a.created};await p.trials.put(i)}),{ok:!0}}catch(a){return r.error("V4_TRIALS: Failed to update trial:",a),{ok:!1,error:a instanceof Error?a:new Error("Failed to update trial")}}}async deleteTrial(t){try{return await p.transaction("rw",p.trials,p.apiCalls,async()=>{const e=await p.trials.get(t);if(!e)throw new Error(`Trial not found: ${t}`);if(e.status==="running")throw new Error("Cannot delete running trial");await p.apiCalls.where("trialId").equals(t).delete(),await p.trials.delete(t)}),r.info(`V4_TRIALS: Deleted trial ${t} and all associated API calls`),{ok:!0}}catch(e){return r.error("V4_TRIALS: Failed to delete trial:",e),{ok:!1,error:e instanceof Error?e:new Error("Failed to delete trial")}}}async duplicateTrial(t){try{const e=await p.trials.get(t);if(!e)return{ok:!1,error:new Error(`Source trial not found: ${t}`)};const a={name:`${e.name} (Copy)`,description:e.description,type:e.type,configurations:e.configurations.map(i=>{var n;return{provider:i.provider,modelId:i.modelId,parameters:i.parameters,name:(n=i.modelSnapshot)==null?void 0:n.displayName}}),repeatCount:e.repeatCount,...e.type==="template"&&e.templateConfig?{templateConfig:e.templateConfig}:{},...e.type==="spreadsheet"&&e.spreadsheetConfig?{spreadsheetConfig:e.spreadsheetConfig}:{}};return this.createTrial(a)}catch(e){return r.error("V4_TRIALS: Failed to duplicate trial:",e),{ok:!1,error:e instanceof Error?e:new Error("Failed to duplicate trial")}}}async updateTrialProgress(t){try{return await p.transaction("rw",p.trials,p.apiCalls,async()=>{var h;const e=await p.trials.get(t);if(!e)throw new Error(`Trial not found: ${t}`);const a=await p.apiCalls.where("trialId").equals(t).toArray();let i=0,n=0,c=0,m=0,_=0;for(const s of a)switch(s.status){case"completed":i++;break;case"failed":n++,((h=s.result)==null?void 0:h.errorType)==="network_error_no_response"&&_++;break;case"cancelled":c++;break;case"running":m++;break}const T=e.progress.total-i-n-c-m;e.progress={total:e.progress.total,completed:i,failed:n,cancelled:c,pending:T,running:m,networkErrors:_},i+n+c>=e.progress.total&&e.status==="running"&&(e.status="completed",e.completed=new Date),await p.trials.put(e)}),{ok:!0}}catch(e){return r.error("V4_TRIALS: Failed to update trial progress:",e),{ok:!1,error:e instanceof Error?e:new Error("Failed to update progress")}}}async generateApiCalls(t,e){return r.info(`V4_TRIALS: Generating REAL API calls for trial ${t.id}, type: ${t.type}`),t.type==="template"&&t.templateConfig?this.generateTemplateApiCalls(t,t.templateConfig,e):t.type==="spreadsheet"&&t.spreadsheetConfig?this.generateSpreadsheetApiCalls(t,t.spreadsheetConfig,e):t.type==="playground"?[]:(r.warn(`V4_TRIALS: Unknown trial type or missing config for trial ${t.id}`),[])}async generateTemplateApiCalls(t,e,a){if(!e)return[];const i=[];let n=0;const c=await this.generateVariableCombinations(e.variables);r.info(`V4_TRIALS: Generated ${c.length} variable combinations`);for(let m=0;m<a;m++)for(let _=0;_<t.configurations.length;_++)for(const T of c){const h=this.substituteVariables(e.template,T.variables),s={id:$("call"),trialId:t.id,configurationIndex:_,order:n++,variables:T.variables,variableAttributes:T.variableAttributes,prompt:h,status:"pending",retryCount:0,created:new Date};i.push(s)}return r.info(`V4_TRIALS: Generated ${i.length} REAL API calls for template trial`),i}async generateSpreadsheetApiCalls(t,e,a){var m;if(!e)return[];const i=[];let n=0;const c=await p.variableLists.get(e.datasetId);if(!c||c.category!=="tabular"||!((m=c.tabularData)!=null&&m.rows))return r.warn(`V4_TRIALS: Dataset ${e.datasetId} not found or invalid`),[];for(let _=0;_<a;_++)for(const T of c.tabularData.rows){const h=this.substituteVariables(e.promptPattern,T);for(let s=0;s<t.configurations.length;s++){const o={id:$("call"),trialId:t.id,configurationIndex:s,order:n++,variables:T,prompt:h,status:"pending",retryCount:0,created:new Date};i.push(o)}}return r.info(`V4_TRIALS: Generated ${i.length} REAL API calls for spreadsheet trial`),i}async generateVariableCombinations(t){var m;const e=Object.keys(t).sort();if(e.length===0)return[{variables:{}}];const a={};for(const _ of e){const T=t[_];let h=[];if(T.type==="value"&&T.values)h=T.values.map(s=>({value:s}));else if(T.type==="list"&&T.listId){const s=await p.variableLists.get(T.listId);s&&(s.category==="simple"&&s.values?h=s.values.map(o=>({value:o})):s.category==="attributed"&&s.items?h=s.items.map(o=>({value:o.value||o.name||String(o),attributes:o.attributes||{}})):s.category==="tabular"&&((m=s.tabularData)!=null&&m.rows)&&(h=s.tabularData.rows.map(o=>({value:o.name||o[Object.keys(o)[0]]||String(o)}))))}a[_]=h}const n=e.map(_=>Math.max(a[_].length,1)).reduce((_,T)=>_*T,1),c=[];for(let _=0;_<n;_++){const T={},h={};let s=_;for(let f=e.length-1;f>=0;f--){const O=e[f],C=a[O];if(C.length>0){const l=s%C.length,u=C[l];T[O]=u.value,u.attributes&&Object.keys(u.attributes).length>0&&(h[O]={...u.attributes}),s=Math.floor(s/C.length)}else T[O]=""}const o={variables:T};Object.keys(h).length>0&&(o.variableAttributes=h),c.push(o)}return c}substituteVariables(t,e){let a=t;for(const[i,n]of Object.entries(e)){const c=new RegExp(`\\{\\{\\s*${i}\\s*\\}\\}`,"g");a=a.replace(c,n)}return a}validateTrialConfig(t){var e;if(!t.name||t.name.trim().length===0)return{ok:!1,error:new Error("Trial name is required")};if(!t.configurations||t.configurations.length===0)return{ok:!1,error:new Error("At least one model configuration is required")};for(const a of t.configurations){if(!P.getProvider(a.provider))return{ok:!1,error:new Error(`Provider not found: ${a.provider}`)};const n=P.validateParameters(a.provider,a.modelId,a.parameters);if(!n.valid)return{ok:!1,error:new Error(`Invalid parameters: ${((e=n.errors)==null?void 0:e.join(", "))||"Validation failed"}`)}}if(t.type==="template"){if(!t.templateConfig||!t.templateConfig.template)return{ok:!1,error:new Error("Template is required for template trials")}}else if(t.type==="spreadsheet"&&(!t.spreadsheetConfig||!t.spreadsheetConfig.promptPattern))return{ok:!1,error:new Error("Prompt pattern is required for spreadsheet trials")};return{ok:!0}}async createConfigurationSnapshots(t){const e=[];for(const a of t){const i=P.getProvider(a.provider);if(!i)throw new Error(`Provider not found: ${a.provider}`);const c=(await p.models.where("provider").equals(a.provider).toArray()).find(_=>_.modelId===a.modelId),m={provider:a.provider,modelId:a.modelId,parameters:a.parameters,providerSnapshot:i,modelSnapshot:c||{id:`${a.provider}:${a.modelId}`,provider:a.provider,modelId:a.modelId,displayName:a.name||a.modelId,enabled:!0,source:"user"}};e.push(m)}return e}}const k=new At;function Lt(){const d=N(!1),t=N(!1),e=N(!1),a=N(!1),i=N(null),n=async l=>{d.value=!0,i.value=null;try{r.info("V4_TRIAL_COMMANDS: Creating trial with config:",l);const u=await k.createTrial(l);return u.ok?r.info("V4_TRIAL_COMMANDS: Trial created successfully:",u.value):(i.value=u.error||new Error("Failed to create trial"),r.error("V4_TRIAL_COMMANDS: Create trial failed:",u.error)),u}finally{d.value=!1}},c=async(l,u,g)=>{try{const E=await p.template_prompts.get(l);if(!E)return{ok:!1,error:new Error(`Template not found: ${l}`)};const I={name:g||`${E.name} - ${new Date().toLocaleString()}`,description:E.description,type:"template",configurations:u,repeatCount:1,templateConfig:{template:E.template,variables:E.variables||{},outputType:E.outputType,extractPattern:E.extractPattern,refusalWords:E.refusalWords?[...E.refusalWords]:void 0,rejectRefusalWords:E.rejectRefusalWords}};return n(I)}catch(E){return r.error("V4_TRIAL_COMMANDS: Failed to create trial from template:",E),{ok:!1,error:E instanceof Error?E:new Error("Failed to create trial from template")}}},m=async(l,u,g,E)=>{try{const I=await p.variableLists.get(u);if(!I||I.category!=="tabular")return{ok:!1,error:new Error(`Dataset not found or not tabular: ${u}`)};const w={name:E||`Spreadsheet Trial - ${new Date().toLocaleString()}`,type:"spreadsheet",configurations:g,spreadsheetConfig:{promptPattern:l,datasetId:u}};return n(w)}catch(I){return r.error("V4_TRIAL_COMMANDS: Failed to create spreadsheet trial:",I),{ok:!1,error:I instanceof Error?I:new Error("Failed to create spreadsheet trial")}}},_=async(l,u)=>{t.value=!0,i.value=null;try{const g=await k.updateTrial(l,u);return g.ok||(i.value=g.error||new Error("Failed to update trial"),r.error("V4_TRIAL_COMMANDS: Update trial failed:",g.error)),g}finally{t.value=!1}},T=async(l,u)=>_(l,{status:u}),h=async l=>{e.value=!0,i.value=null;try{r.info("V4_TRIAL_COMMANDS: Deleting trial:",l);const u=await k.deleteTrial(l);return u.ok?r.info("V4_TRIAL_COMMANDS: Trial deleted successfully"):(i.value=u.error||new Error("Failed to delete trial"),r.error("V4_TRIAL_COMMANDS: Delete trial failed:",u.error)),u}finally{e.value=!1}},s=async l=>{e.value=!0,i.value=null;try{return r.info("V4_TRIAL_COMMANDS: Deleting multiple trials:",l.length),await p.transaction("rw",p.trials,p.apiCalls,async()=>{for(const u of l){const g=await p.trials.get(u);g&&g.status!=="running"&&(await p.apiCalls.where("trialId").equals(u).delete(),await p.trials.delete(u))}}),r.info("V4_TRIAL_COMMANDS: Multiple trials deleted successfully"),{ok:!0}}catch(u){return r.error("V4_TRIAL_COMMANDS: Failed to delete multiple trials:",u),i.value=u instanceof Error?u:new Error("Failed to delete trials"),{ok:!1,error:i.value}}finally{e.value=!1}},o=async l=>{a.value=!0,i.value=null;try{r.info("V4_TRIAL_COMMANDS: Duplicating trial:",l);const u=await k.duplicateTrial(l);return u.ok?r.info("V4_TRIAL_COMMANDS: Trial duplicated successfully:",u.value):(i.value=u.error||new Error("Failed to duplicate trial"),r.error("V4_TRIAL_COMMANDS: Duplicate trial failed:",u.error)),u}finally{a.value=!1}},f=async l=>{var u,g;try{let E=1;if(l.type==="template"&&l.templateConfig){const w=l.templateConfig.variables;for(const[,S]of Object.entries(w))if(S.type==="value"&&S.values)E*=S.values.length;else if(S.type==="list"&&S.listId){const y=await p.variableLists.get(S.listId);y&&(y.category==="simple"&&y.values?E*=y.values.length:y.category==="attributed"&&y.items?E*=y.items.length:y.category==="tabular"&&((u=y.tabularData)!=null&&u.rows)&&(E*=y.tabularData.rows.length))}}else if(l.type==="spreadsheet"&&l.spreadsheetConfig){const w=await p.variableLists.get(l.spreadsheetConfig.datasetId);w&&w.category==="tabular"&&((g=w.tabularData)!=null&&g.rows)&&(E=w.tabularData.rows.length)}return E*l.configurations.length*(l.repeatCount||1)}catch(E){return r.error("V4_TRIAL_COMMANDS: Failed to calculate API call count:",E),0}};return{createTrial:n,createTrialFromTemplate:c,createTrialFromSpreadsheet:m,updateTrial:_,updateTrialStatus:T,deleteTrial:h,deleteMultipleTrials:s,duplicateTrial:o,generateApiCallCount:f,estimateTrialCost:async l=>{var u,g;try{const E=await f(l);let I=0;for(const w of l.configurations){const y=(await p.models.where("provider").equals(w.provider).toArray()).find(L=>L.modelId===w.modelId);if(y!=null&&y.capabilities){const V=((u=w.parameters)==null?void 0:u.max_tokens)||((g=w.parameters)==null?void 0:g.maxTokens)||256,et=(y.capabilities.inputCostPerToken||0)*150,rt=(y.capabilities.outputCostPerToken||0)*V;I+=(et+rt)*E/l.configurations.length}}return I}catch(E){return r.error("V4_TRIAL_COMMANDS: Failed to estimate cost:",E),0}},validateTrialConfig:l=>!l.name||l.name.trim().length===0?{ok:!1,error:new Error("Trial name is required")}:!l.configurations||l.configurations.length===0?{ok:!1,error:new Error("At least one model configuration is required")}:l.type==="template"&&!l.templateConfig?{ok:!1,error:new Error("Template configuration is required for template trials")}:l.type==="spreadsheet"&&!l.spreadsheetConfig?{ok:!1,error:new Error("Spreadsheet configuration is required for spreadsheet trials")}:{ok:!0},isCreating:d,isUpdating:t,isDeleting:e,isDuplicating:a,lastError:i}}const H=10;function xt(){const d=ft(),t=pt();function e(s,o,f){var E;if(!s)return 0;let O=s;const C=/\{\{?\s*(\w+)\s*\}?\}/g,l=new Set;O=O.replace(C,(I,w)=>(l.add(w),""));const u=t.estimateTokens(O);let g=0;for(const[I,w]of Object.entries(o)){if(!l.has(I))continue;let S=[];if(w.type==="value"&&w.values)S=w.values;else if(w.type==="list"&&w.listId&&f){const y=f.find(L=>L.id===w.listId);y&&(y.category==="simple"?S=y.values||[]:y.category==="attributed"&&(S=((E=y.items)==null?void 0:E.map(L=>L.value))||[]))}if(S.length>0){const y=S.reduce((L,V)=>L+t.estimateTokens(V),0);g+=y/S.length}}return Math.ceil(u+g)}function a(s){return s?t.estimateTokens(s):0}function i(s,o,f){const O=d.getOutputTokenLimit(s,o,f);if(!O)return r.warn("No output token limit found for model",{provider:s,modelId:o}),{min:-1,max:-1,expected:-1};const C=["max_tokens","max_completion_tokens","max_output_tokens","num_predict","maxTokens"];let l=0;for(const u of C)if(f[u]!==void 0){l=f[u];break}return l||(l=O),{min:H,max:O,expected:Math.min(l,O)}}function n(s,o,f={}){var E,I;if(!o)return h();const O=i(o.provider,o.modelId,f);if(O.expected===-1)return{tokens:{input:s,output:{min:-1,max:-1,expected:-1}},cost:{input:0,output:{min:-1,max:-1,expected:-1},total:{min:-1,max:-1,expected:-1}},meta:{hasValidCost:!1,isLocalModel:o.provider.includes("ollama")||o.provider==="deterministic",confidence:"low",provider:o.provider,modelId:o.modelId}};const C=((E=o.capabilities)==null?void 0:E.inputCostPerToken)||0,l=((I=o.capabilities)==null?void 0:I.outputCostPerToken)||0,u=s*C;let g="low";return C>0&&l>0&&(O.expected>0?g="high":g="medium"),{tokens:{input:s,output:O},cost:{input:u,output:{min:O.min*l,max:O.max*l,expected:O.expected*l},total:{min:u+O.min*l,max:u+O.max*l,expected:u+O.expected*l}},meta:{hasValidCost:C>0||l>0,isLocalModel:o.provider.includes("ollama")||o.provider==="deterministic",confidence:g,provider:o.provider,modelId:o.modelId}}}function c(s,o="range"){if(s.cost.total.expected===-1)return"Unable to estimate";if(s.meta.isLocalModel)return"Free (local)";if(!s.meta.hasValidCost)return"No pricing data";if(s.cost.total.max===0)return"Free";switch(o){case"compact":return m(s.cost.total.expected);case"range":const f=m(s.cost.total.min),O=m(s.cost.total.max),C=m(s.cost.total.expected);return Math.abs(s.cost.total.max-s.cost.total.min)<1e-4?C:`~${C} (${f}-${O})`;case"detailed":const l=`${s.tokens.input} input`,u=`${s.tokens.output.min}-${s.tokens.output.max} output`,g=`${m(s.cost.total.min)}-${m(s.cost.total.max)}`;return`${l} + ${u} tokens: ${g}`;case"tokens":return`${s.tokens.input} + ${s.tokens.output.min}-${s.tokens.output.max} tokens`}}function m(s){return s===0?"$0":s<1e-4?"<$0.0001":s<.01?`$${s.toFixed(4)}`:s<1?`$${s.toFixed(3)}`:s<10?`$${s.toFixed(2)}`:`$${Math.round(s)}`}function _(s){return s.length===0?h():s.reduce((o,f)=>({tokens:{input:o.tokens.input+f.tokens.input,output:{min:o.tokens.output.min+f.tokens.output.min,max:o.tokens.output.max+f.tokens.output.max,expected:o.tokens.output.expected+f.tokens.output.expected}},cost:{input:o.cost.input+f.cost.input,output:{min:o.cost.output.min+f.cost.output.min,max:o.cost.output.max+f.cost.output.max,expected:o.cost.output.expected+f.cost.output.expected},total:{min:o.cost.total.min+f.cost.total.min,max:o.cost.total.max+f.cost.total.max,expected:o.cost.total.expected+f.cost.total.expected}},meta:{hasValidCost:f.meta.hasValidCost||o.meta.hasValidCost,isLocalModel:f.meta.isLocalModel&&o.meta.isLocalModel,confidence:f.meta.confidence==="low"?"low":o.meta.confidence,provider:"multiple",modelId:"multiple"}}),h())}function T(s,o){return{tokens:{input:s.tokens.input*o,output:{min:s.tokens.output.min*o,max:s.tokens.output.max*o,expected:s.tokens.output.expected*o}},cost:{input:s.cost.input*o,output:{min:s.cost.output.min*o,max:s.cost.output.max*o,expected:s.cost.output.expected*o},total:{min:s.cost.total.min*o,max:s.cost.total.max*o,expected:s.cost.total.expected*o}},meta:s.meta}}function h(){return{tokens:{input:0,output:{min:0,max:0,expected:0}},cost:{input:0,output:{min:0,max:0,expected:0},total:{min:0,max:0,expected:0}},meta:{hasValidCost:!1,isLocalModel:!1,confidence:"low",provider:"",modelId:""}}}return{calculateTemplateTokens:e,calculatePromptTokens:a,getOutputTokenRange:i,estimateCost:n,formatCost:c,formatSingleCost:m,sumEstimates:_,multiplyEstimate:T,createEmptyEstimate:h,MIN_OUTPUT_TOKENS:H}}export{J as C,K as F,Lt as a,Rt as b,xt as c,St as d,wt as u};
