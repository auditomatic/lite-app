import{d as e,r as t}from"./index-Bz5Ugese.js";import"./vendor-DdqHZeTC.js";import"./db-ftwlfnxb.js";class s{async deleteDesign(s){try{const a=await e.designs.get(s);if(!a)return{success:!1,deletedCount:0,error:"Design not found"};let r=0;const n={runs:0,tasks:0},i=await e.runs.where("design_id").equals(s).toArray();for(const t of i){const s=await e.tasks.where("run_id").equals(t.id).toArray();await e.tasks.where("run_id").equals(t.id).delete(),n.tasks+=s.length,r+=s.length}return await e.runs.where("design_id").equals(s).delete(),n.runs=i.length,r+=i.length,await e.designs.delete(s),r+=1,await t.logOperation("design",s,"delete",{context:"cascade_delete_design",cascade_details:n,design_name:a.name}),{success:!0,deletedCount:r,details:n}}catch(a){return await t.logError(a,{entity_type:"design",entity_id:s,operation:"cascade_delete"}),{success:!1,deletedCount:0,error:a instanceof Error?a.message:String(a)}}}async deleteRun(s){try{const a=await e.runs.get(s);if(!a)return{success:!1,deletedCount:0,error:"Run not found"};let r=0;const n={tasks:0},i=await e.tasks.where("run_id").equals(s).toArray();return await e.tasks.where("run_id").equals(s).delete(),n.tasks=i.length,r+=i.length,await e.runs.delete(s),r+=1,await t.logOperation("run",s,"delete",{context:"cascade_delete_run",cascade_details:n,run_name:a.name}),{success:!0,deletedCount:r,details:n}}catch(a){return await t.logError(a,{entity_type:"run",entity_id:s,operation:"cascade_delete"}),{success:!1,deletedCount:0,error:a instanceof Error?a.message:String(a)}}}async deleteVariableList(s){try{const a=await e.variable_lists.get(s);if(!a)return{success:!1,deletedCount:0,error:"Variable list not found"};let r=0;const n={variableListItems:0},i=await e.variable_lists.where("id").equals(s).toArray();n.variableListItems=i.length,r+=i.length;const l=(await e.designs.toArray()).filter(e=>e.variable_list_refs&&Object.values(e.variable_list_refs).includes(s));return l.length>0&&console.warn(`Variable list ${s} is referenced by ${l.length} designs. References should be updated.`),await e.variable_lists.delete(s),r+=1,await t.logOperation("system",s,"delete",{context:"cascade_delete_variable_list",cascade_details:n,list_name:a.name,affected_designs:l.length}),{success:!0,deletedCount:r,details:n}}catch(a){return await t.logError(a,{entity_type:"system",entity_id:s,operation:"cascade_delete"}),{success:!1,deletedCount:0,error:a instanceof Error?a.message:String(a)}}}async getRelationshipSummary(t,s){try{switch(t){case"designs":{const t=await e.runs.where("design_id").equals(s).toArray(),a=(await Promise.all(t.map(t=>e.tasks.where("run_id").equals(t.id).count()))).reduce((e,t)=>e+t,0);return{runs:t.length,tasks:a,relatedEntities:t.length+a}}case"runs":{const t=await e.tasks.where("run_id").equals(s).count();return{tasks:t,relatedEntities:t}}case"variable_lists":{const t=await e.variable_lists.get(s),a=t?.values?.length||0,r=(await e.designs.toArray()).filter(e=>e.variable_list_refs&&Object.values(e.variable_list_refs).includes(s)).length;return{items:a,referencingDesigns:r,relatedEntities:a+r}}default:throw new Error(`Unknown entity type: ${t}`)}}catch(a){return console.error("Failed to get relationship summary:",a),{relatedEntities:0}}}async validateIntegrity(){const t=[];try{const s=await e.runs.toArray(),a=await e.designs.toArray(),r=new Set(a.map(e=>e.id)),n=s.filter(e=>!r.has(e.design_id));n.length>0&&t.push({type:"orphaned_runs",count:n.length,ids:n.map(e=>e.id)});const i=await e.tasks.toArray(),l=new Set(s.map(e=>e.id)),d=i.filter(e=>!l.has(e.run_id));return d.length>0&&t.push({type:"orphaned_tasks",count:d.length,ids:d.map(e=>e.id)}),{valid:0===t.length,issues:t}}catch(s){return{valid:!1,error:s instanceof Error?s.message:String(s)}}}async cleanupOrphans(){const s=await this.validateIntegrity();if(s.valid)return{success:!0,cleaned:0};let a=0;try{for(const t of s.issues||[])switch(t.type){case"orphaned_tasks":await e.tasks.where("id").anyOf(t.ids).delete(),a+=t.count;break;case"orphaned_runs":await e.runs.where("id").anyOf(t.ids).delete(),a+=t.count}return await t.logOperation("system",0,"delete",{context:"orphan_cleanup",cleaned_count:a,issues:s.issues?.map(e=>({type:e.type,count:e.count}))}),{success:!0,cleaned:a}}catch(r){return{success:!1,cleaned:a,error:r instanceof Error?r.message:String(r)}}}}const a=new s;export{s as DataManagementService,a as dataManager};
