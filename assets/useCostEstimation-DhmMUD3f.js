var it=Object.defineProperty;var st=(p,t,e)=>t in p?it(p,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):p[t]=e;var O=(p,t,e)=>st(p,typeof t!="symbol"?t+"":t,e);import{e as W,I as q,a1 as nt,a2 as ot,a3 as lt,a4 as j,a as r,s as x,c as y,v as M,o as X,a5 as ut,l as Q,d as f,a6 as F,q as Y,a7 as Z,g as V,a8 as ct,a9 as G,aa as D,ab as dt,ac as ft,p as P,r as k,ad as pt,ae as ht}from"./index-SihudOJq.js";var mt={icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M516 673c0 4.4 3.4 8 7.5 8h185c4.1 0 7.5-3.6 7.5-8v-48c0-4.4-3.4-8-7.5-8h-185c-4.1 0-7.5 3.6-7.5 8v48zm-194.9 6.1l192-161c3.8-3.2 3.8-9.1 0-12.3l-192-160.9A7.95 7.95 0 00308 351v62.7c0 2.4 1 4.6 2.9 6.1L420.7 512l-109.8 92.2a8.1 8.1 0 00-2.9 6.1V673c0 6.8 7.9 10.5 13.1 6.1zM880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z"}}]},name:"code",theme:"outlined"};function B(p){for(var t=1;t<arguments.length;t++){var e=arguments[t]!=null?Object(arguments[t]):{},a=Object.keys(e);typeof Object.getOwnPropertySymbols=="function"&&(a=a.concat(Object.getOwnPropertySymbols(e).filter(function(i){return Object.getOwnPropertyDescriptor(e,i).enumerable}))),a.forEach(function(i){Tt(p,i,e[i])})}return p}function Tt(p,t,e){return t in p?Object.defineProperty(p,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):p[t]=e,p}var J=function(t,e){var a=B({},t,e.attrs);return W(q,B({},a,{icon:mt}),null)};J.displayName="CodeOutlined";J.inheritAttrs=!1;var _t={icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494zM514.1 580.1l-61.8-102.4c-2.2-3.6-6.1-5.8-10.3-5.8h-38.4c-2.3 0-4.5.6-6.4 1.9-5.6 3.5-7.3 10.9-3.7 16.6l82.3 130.4-83.4 132.8a12.04 12.04 0 0010.2 18.4h34.5c4.2 0 8-2.2 10.2-5.7L510 664.8l62.3 101.4c2.2 3.6 6.1 5.7 10.2 5.7H620c2.3 0 4.5-.7 6.5-1.9 5.6-3.6 7.2-11 3.6-16.6l-84-130.4 85.3-132.5a12.04 12.04 0 00-10.1-18.5h-35.7c-4.2 0-8.1 2.2-10.3 5.8l-61.2 102.3z"}}]},name:"file-excel",theme:"outlined"};function z(p){for(var t=1;t<arguments.length;t++){var e=arguments[t]!=null?Object(arguments[t]):{},a=Object.keys(e);typeof Object.getOwnPropertySymbols=="function"&&(a=a.concat(Object.getOwnPropertySymbols(e).filter(function(i){return Object.getOwnPropertyDescriptor(e,i).enumerable}))),a.forEach(function(i){gt(p,i,e[i])})}return p}function gt(p,t,e){return t in p?Object.defineProperty(p,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):p[t]=e,p}var K=function(t,e){var a=z({},t,e.attrs);return W(q,z({},a,{icon:_t}),null)};K.displayName="FileExcelOutlined";K.inheritAttrs=!1;var tt=function(p){nt(t,p);function t(e,a,i){e===void 0&&(e=1/0),a===void 0&&(a=1/0),i===void 0&&(i=ot);var s=p.call(this)||this;return s._bufferSize=e,s._windowTime=a,s._timestampProvider=i,s._buffer=[],s._infiniteTimeWindow=!0,s._infiniteTimeWindow=a===1/0,s._bufferSize=Math.max(1,e),s._windowTime=Math.max(1,a),s}return t.prototype.next=function(e){var a=this,i=a.isStopped,s=a._buffer,l=a._infiniteTimeWindow,m=a._timestampProvider,_=a._windowTime;i||(s.push(e),!l&&s.push(m.now()+_)),this._trimBuffer(),p.prototype.next.call(this,e)},t.prototype._subscribe=function(e){this._throwIfClosed(),this._trimBuffer();for(var a=this._innerSubscribe(e),i=this,s=i._infiniteTimeWindow,l=i._buffer,m=l.slice(),_=0;_<m.length&&!e.closed;_+=s?1:2)e.next(m[_]);return this._checkFinalizedStatuses(e),a},t.prototype._trimBuffer=function(){var e=this,a=e._bufferSize,i=e._timestampProvider,s=e._buffer,l=e._infiniteTimeWindow,m=(l?1:2)*a;if(a<1/0&&m<s.length&&s.splice(0,s.length-m),!l){for(var _=i.now(),T=0,h=1;h<s.length&&s[h]<=_;h+=2)T=h;T&&s.splice(0,T+1)}},t}(lt);function Et(p,t,e){var a,i,s,l,m=!1;return p&&typeof p=="object"?(a=p.bufferSize,l=a===void 0?1/0:a,i=p.windowTime,t=i===void 0?1/0:i,s=p.refCount,m=s===void 0?!1:s,e=p.scheduler):l=p??1/0,j({connector:function(){return new tt(l,t,e)},resetOnError:!0,resetOnComplete:!1,resetOnRefCountZero:m})}function wt(){const p=performance.now();r.info(`V4_TRIAL_SWITCH: useV4Trials() composable ENTRY at ${p}`);const t=x([]),e=x(!0),a=x(null);let i=null;const s=y(()=>t.value),l=()=>{const g=performance.now();r.info(`V4_TRIAL_SWITCH: setupLiveQuery() ENTRY at ${g}`),i&&(i.unsubscribe(),i=null);const u=Q(async()=>{try{return(await f.trials.orderBy("created").reverse().toArray()).filter(I=>!F(I)).map(I=>Object.freeze({...I,created:I.created instanceof Date?I.created:new Date(I.created),started:I.started?I.started instanceof Date?I.started:new Date(I.started):void 0,completed:I.completed?I.completed instanceof Date?I.completed:new Date(I.completed):void 0}))}catch(d){throw r.error("V4_TRIALS: Failed to load trials:",d),d}});i=Y(u).subscribe({next:d=>{t.value=d,e.value=!1,a.value=null,r.info(`V4_TRIALS_DB: Loaded ${d.length} trials from database`)},error:d=>{r.error("V4_TRIALS: Query error:",d),a.value=d instanceof Error?d:new Error("Failed to load trials"),e.value=!1}})},m=y(()=>s.value.filter(g=>g.status==="running")),_=y(()=>s.value.filter(g=>g.status==="draft")),T=y(()=>s.value.filter(g=>g.status==="completed")),h=y(()=>s.value.filter(g=>g.status==="paused")),o=y(()=>s.value.filter(g=>g.status==="failed")),n=y(()=>s.value.length),c=y(()=>{const g={total:s.value.length,byStatus:{draft:0,pending:0,running:0,paused:0,completed:0,cancelled:0,failed:0},totalApiCalls:0,completedApiCalls:0,failedApiCalls:0,averageCompletionRate:0};for(const u of s.value)g.byStatus[u.status]++,u.progress&&(g.totalApiCalls+=u.progress.total,g.completedApiCalls+=u.progress.completed,g.failedApiCalls+=u.progress.failed);return g.totalApiCalls>0&&(g.averageCompletionRate=g.completedApiCalls/g.totalApiCalls*100),g}),b=async()=>{e.value=!0,a.value=null;try{const d=(await f.trials.orderBy("created").reverse().toArray()).filter(E=>!F(E)).map(E=>Object.freeze({...E,created:E.created instanceof Date?E.created:new Date(E.created),started:E.started?E.started instanceof Date?E.started:new Date(E.started):void 0,completed:E.completed?E.completed instanceof Date?E.completed:new Date(E.completed):void 0}));t.value=d,e.value=!1,r.info(`V4_TRIALS: Manual refresh loaded ${d.length} trials`)}catch(g){r.error("V4_TRIALS: Refresh failed:",g),a.value=g instanceof Error?g:new Error("Failed to refresh trials"),e.value=!1}};return M(()=>{const g=performance.now();r.info(`V4_TRIAL_SWITCH: useV4Trials onMounted() ENTRY at ${g}`),r.info("V4_TRIALS: Mounting trials query composable");const u=performance.now();r.info(`V4_TRIAL_SWITCH: useV4Trials calling setupLiveQuery() at ${(u-g).toFixed(1)}ms`),l();const d=performance.now();r.info(`V4_TRIAL_SWITCH: useV4Trials setupLiveQuery() completed in ${(d-u).toFixed(1)}ms`)}),X(()=>{r.info("V4_TRIALS: Unmounting trials query composable"),i&&(i.unsubscribe(),i=null)}),{trials:s,loading:e,error:a,runningTrials:m,draftTrials:_,completedTrials:T,pausedTrials:h,failedTrials:o,totalTrials:n,statistics:c,refresh:b}}function St(p){const t=x(null),e=x(!0),a=x(null);let i=null,s=null;const l=y(()=>(typeof p=="object"&&p!==null?p.value:p)?t.value:null),m=T=>{const h=performance.now();if(r.info(`V4_TRIAL_SWITCH: Single trial query setup for ${T}`),i&&(i.unsubscribe(),i=null),!T){t.value=null,e.value=!1,r.info("V4_TRIAL_SWITCH: Single trial query cleared (no ID)");return}const o=Q(async()=>{const n=performance.now();r.info(`V4_TRIAL_SWITCH: Single trial DB query starting at ${(n-h).toFixed(1)}ms`);const c=await f.trials.get(T),b=performance.now();return r.info(`V4_TRIAL_SWITCH: Single trial DB query completed in ${(b-n).toFixed(1)}ms`),c?Object.freeze({...c,created:c.created instanceof Date?c.created:new Date(c.created),started:c.started?c.started instanceof Date?c.started:new Date(c.started):void 0,completed:c.completed?c.completed instanceof Date?c.completed:new Date(c.completed):void 0}):null});i=Y(o).subscribe({next:n=>{const c=performance.now();t.value=n,e.value=!1,a.value=null,n&&r.info(`V4_TRIAL_SWITCH: Trial ${n.id} loaded from database in ${(c-h).toFixed(1)}ms`)},error:n=>{r.error("V4_TRIALS: Single trial query error:",n),a.value=n instanceof Error?n:new Error("Failed to load trial"),e.value=!1}})},_=async()=>{const T=typeof p=="object"&&p!==null?p.value:p;if(!T){t.value=null,e.value=!1;return}e.value=!0,a.value=null;try{const h=await f.trials.get(T);h?t.value=Object.freeze({...h,created:h.created instanceof Date?h.created:new Date(h.created),started:h.started?h.started instanceof Date?h.started:new Date(h.started):void 0,completed:h.completed?h.completed instanceof Date?h.completed:new Date(h.completed):void 0}):t.value=null,e.value=!1}catch(h){r.error("V4_TRIALS: Refresh single trial failed:",h),a.value=h instanceof Error?h:new Error("Failed to refresh trial"),e.value=!1}};return typeof p=="object"&&p!==null?M(()=>{r.info("V4_TRIALS: Mounting single trial query with reactive ID"),s=ut(()=>{const T=p.value;r.info("V4_TRIALS: Trial ID changed to:",T),m(T)})}):M(()=>{r.info("V4_TRIALS: Mounting single trial query for static ID:",p),m(p)}),X(()=>{r.info("V4_TRIALS: Unmounting single trial query"),i&&(i.unsubscribe(),i=null),s&&(s(),s=null)}),{trial:l,loading:e,error:a,refresh:_}}class vt{constructor(){O(this,"state",Z({status:"idle",trialId:null,orchestratorType:null,startedAt:null,pausedAt:null,completedAt:null,tabId:null}));O(this,"currentState",y(()=>({...this.state})));O(this,"status",y(()=>this.state.status));O(this,"trialId",y(()=>this.state.trialId));O(this,"orchestratorType",y(()=>this.state.orchestratorType));O(this,"isExecuting",y(()=>["starting","running","pausing"].includes(this.state.status)));O(this,"isPaused",y(()=>this.state.status==="paused"));O(this,"isIdle",y(()=>this.state.status==="idle"))}async hydrate(){r.info("STATE_MACHINE: Hydrating state from database...");const t=await f.trials.where("status").equals("running").toArray();if(t.length>0){r.info(`STATE_MACHINE: Found ${t.length} running trials, marking as paused (page refreshed)`);for(const e of t)await f.trials.update(e.id,{status:"paused"}),r.info(`STATE_MACHINE: Paused trial ${e.id} (was running, page refreshed)`)}r.info("STATE_MACHINE: State machine starting idle - use resume to continue paused trials")}async startExecution(t,e,a){if(r.info(`STATE_MACHINE: Starting execution - trial=${t}, orchestrator=${e}, tab=${a}`),this.state.status!=="idle"&&this.state.status!=="paused")return{ok:!1,error:new Error(`Cannot start: current status is ${this.state.status}`)};try{return this.state.status="starting",this.state.trialId=t,this.state.orchestratorType=e,this.state.tabId=a,this.state.startedAt=new Date,this.state.pausedAt=null,this.state.completedAt=null,await f.trials.update(t,{status:"running",started:this.state.startedAt}),this.state.status="running",r.info(`STATE_MACHINE: Successfully started execution for trial ${t}`),{ok:!0,value:void 0}}catch(i){return this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,{ok:!1,error:i instanceof Error?i:new Error("Failed to start execution")}}}async pauseExecution(){if(r.info(`STATE_MACHINE: Pausing execution - current status=${this.state.status}`),this.state.status!=="running")return{ok:!1,error:new Error(`Cannot pause: current status is ${this.state.status}`)};if(!this.state.trialId)return{ok:!1,error:new Error("Cannot pause: no active trial")};try{return this.state.status="pausing",this.state.pausedAt=new Date,await f.trials.update(this.state.trialId,{status:"paused"}),this.state.status="paused",r.info(`STATE_MACHINE: Successfully paused execution for trial ${this.state.trialId}`),{ok:!0,value:void 0}}catch(t){return this.state.status="running",this.state.pausedAt=null,{ok:!1,error:t instanceof Error?t:new Error("Failed to pause execution")}}}async resumeExecution(t,e){if(r.info(`STATE_MACHINE: Resuming trial ${t} - current status=${this.state.status}, tab=${e}`),!["idle","paused"].includes(this.state.status))return{ok:!1,error:new Error(`Cannot resume: current status is ${this.state.status}`)};try{const a=await f.trials.get(t);if(!a)return{ok:!1,error:new Error(`Trial ${t} not found`)};if(a.status!=="paused")return{ok:!1,error:new Error(`Cannot resume: trial status is ${a.status}, expected paused`)};const i=a.type==="playground"?"streaming":"regular";return this.state.status="running",this.state.trialId=t,this.state.orchestratorType=i,this.state.tabId=e,this.state.startedAt=a.started||new Date,this.state.pausedAt=null,this.state.completedAt=null,await f.trials.update(t,{status:"running"}),r.info(`STATE_MACHINE: Successfully resumed execution for trial ${t}`),{ok:!0,value:void 0}}catch(a){return this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,this.state.pausedAt=null,{ok:!1,error:a instanceof Error?a:new Error("Failed to resume execution")}}}async cancelExecution(){if(r.info(`STATE_MACHINE: Cancelling execution - current status=${this.state.status}`),!["running","paused","starting"].includes(this.state.status))return{ok:!1,error:new Error(`Cannot cancel: current status is ${this.state.status}`)};if(!this.state.trialId)return{ok:!1,error:new Error("Cannot cancel: no active trial")};try{const t=this.state.trialId;return this.state.status="cancelling",this.state.completedAt=new Date,await f.trials.update(t,{status:"cancelled",completed:this.state.completedAt}),this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,this.state.pausedAt=null,r.info(`STATE_MACHINE: Successfully cancelled execution for trial ${t}`),{ok:!0,value:void 0}}catch(t){return this.state.status=this.state.pausedAt?"paused":"running",this.state.completedAt=null,{ok:!1,error:t instanceof Error?t:new Error("Failed to cancel execution")}}}async completeExecution(){if(r.info(`STATE_MACHINE: Completing execution - current status=${this.state.status}`),this.state.status!=="running")return{ok:!1,error:new Error(`Cannot complete: current status is ${this.state.status}`)};if(!this.state.trialId)return{ok:!1,error:new Error("Cannot complete: no active trial")};try{const t=this.state.trialId;return this.state.status="completed",this.state.completedAt=new Date,await f.trials.update(t,{status:"completed",completed:this.state.completedAt}),this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,this.state.pausedAt=null,r.info(`STATE_MACHINE: Successfully completed execution for trial ${t}`),{ok:!0,value:void 0}}catch(t){return this.state.status="running",this.state.completedAt=null,{ok:!1,error:t instanceof Error?t:new Error("Failed to complete execution")}}}canStart(){return this.state.status==="idle"||this.state.status==="paused"}canPause(){return this.state.status==="running"}canResume(){return this.state.status==="paused"&&this.state.orchestratorType!==null}canCancel(){return["running","paused","starting"].includes(this.state.status)}isOwnedByTab(t){return this.state.tabId===t}}const C=new vt;class It{constructor(){O(this,"state",Z({tabId:V("tab"),role:"observer",isInitialized:!1,lastHeartbeat:new Date}));O(this,"broadcastChannel",null);O(this,"lockReleaseFunction",null);O(this,"heartbeatInterval",null);O(this,"tabId",y(()=>this.state.tabId));O(this,"role",y(()=>this.state.role));O(this,"isLeader",y(()=>this.state.role==="leader"));O(this,"isObserver",y(()=>this.state.role==="observer"));O(this,"isInitialized",y(()=>this.state.isInitialized))}async initialize(){if(this.state.isInitialized){r.info(`COORDINATION: Tab ${this.state.tabId} already initialized as ${this.state.role}`);return}r.info(`COORDINATION: Initializing tab ${this.state.tabId}`);try{this.broadcastChannel=new BroadcastChannel("auditomatic-coordination"),this.broadcastChannel.onmessage=t=>{this.handleCoordinationMessage(t.data)},await this.attemptLeadershipAcquisition(),this.startHeartbeat(),this.state.isInitialized=!0,r.info(`COORDINATION: Tab ${this.state.tabId} initialized as ${this.state.role}`)}catch(t){throw r.error(`COORDINATION: Failed to initialize tab ${this.state.tabId}:`,t),t}}async attemptLeadershipAcquisition(){if(!("locks"in navigator)){r.info(`COORDINATION: Web Locks not available, tab ${this.state.tabId} becomes leader`),this.state.role="leader";return}try{r.info(`COORDINATION: Tab ${this.state.tabId} attempting to acquire leadership lock`),navigator.locks.request("auditomatic-leader",{mode:"exclusive",ifAvailable:!0},t=>{if(t)return r.info(`COORDINATION: Tab ${this.state.tabId} acquired leadership lock`),this.state.role="leader",new Promise(e=>{this.lockReleaseFunction=e});r.info(`COORDINATION: Tab ${this.state.tabId} could not acquire lock - observer mode`),this.state.role="observer"}),await new Promise(t=>setTimeout(t,50))}catch(t){r.error(`COORDINATION: Leadership acquisition failed for tab ${this.state.tabId}:`,t),this.state.role="observer"}}startHeartbeat(){this.heartbeatInterval=setInterval(()=>{this.state.lastHeartbeat=new Date,this.broadcast({type:"heartbeat",tabId:this.state.tabId,timestamp:this.state.lastHeartbeat})},1e4)}broadcast(t){this.broadcastChannel&&(r.info(`COORDINATION: Broadcasting ${t.type} from tab ${this.state.tabId}`),this.broadcastChannel.postMessage(t))}handleCoordinationMessage(t){if(t.tabId!==this.state.tabId)switch(r.info(`COORDINATION: Tab ${this.state.tabId} received ${t.type} from ${t.tabId}`),t.type){case"execution:started":this.state.role==="observer"&&t.trialId&&r.info(`COORDINATION: Observer tab syncing to started execution: ${t.trialId}`);break;case"execution:paused":this.state.role==="observer"&&t.trialId&&r.info(`COORDINATION: Observer tab syncing to paused execution: ${t.trialId}`);break;case"execution:resumed":this.state.role==="observer"&&t.trialId&&r.info(`COORDINATION: Observer tab syncing to resumed execution: ${t.trialId}`);break;case"execution:cancelled":case"execution:completed":this.state.role==="observer"&&t.trialId&&r.info(`COORDINATION: Observer tab syncing to ended execution: ${t.trialId}`);break;case"heartbeat":r.info(`COORDINATION: Heartbeat from ${t.tabId}`);break}}canExecuteActions(){return this.state.role==="leader"}validateLeadership(t){return this.state.role!=="leader"?{ok:!1,error:new Error(`Cannot ${t}: only leader tab can execute actions`)}:{ok:!0,value:void 0}}async startExecution(t,e){const a=this.validateLeadership("start execution");if(!a.ok)return a;r.info(`COORDINATION: Leader starting execution - trial=${t}, orchestrator=${e}`);const i=await C.startExecution(t,e,this.state.tabId);return i.ok&&this.broadcast({type:"execution:started",tabId:this.state.tabId,timestamp:new Date,trialId:t,orchestratorType:e}),i}async pauseExecution(){const t=this.validateLeadership("pause execution");if(!t.ok)return t;r.info("COORDINATION: Leader pausing execution");const e=await C.pauseExecution();return e.ok&&this.broadcast({type:"execution:paused",tabId:this.state.tabId,timestamp:new Date,trialId:C.trialId.value||void 0}),e}async resumeExecution(t){const e=this.validateLeadership("resume execution");if(!e.ok)return e;r.info(`COORDINATION: Leader resuming execution for trial ${t}`);const a=await C.resumeExecution(t,this.state.tabId);return a.ok&&this.broadcast({type:"execution:resumed",tabId:this.state.tabId,timestamp:new Date,trialId:t}),a}async cancelExecution(){const t=this.validateLeadership("cancel execution");if(!t.ok)return t;r.info("COORDINATION: Leader cancelling execution");const e=C.trialId.value,a=await C.cancelExecution();return a.ok&&this.broadcast({type:"execution:cancelled",tabId:this.state.tabId,timestamp:new Date,trialId:e||void 0}),a}async completeExecution(){const t=this.validateLeadership("complete execution");if(!t.ok)return t;r.info("COORDINATION: Leader completing execution");const e=C.trialId.value,a=await C.completeExecution();return a.ok&&this.broadcast({type:"execution:completed",tabId:this.state.tabId,timestamp:new Date,trialId:e||void 0}),a}destroy(){r.info(`COORDINATION: Destroying tab ${this.state.tabId}`),this.heartbeatInterval&&(clearInterval(this.heartbeatInterval),this.heartbeatInterval=null),this.lockReleaseFunction&&(this.lockReleaseFunction(),this.lockReleaseFunction=null),this.broadcastChannel&&(this.broadcastChannel.close(),this.broadcastChannel=null),this.state.isInitialized=!1,r.info(`COORDINATION: Tab ${this.state.tabId} cleanup complete`)}}const R=new It;class Ct{async updateTrial(t){r.info(`ATOMIC_OPS: Updating trial ${t.trialId} - status=${t.status}`);try{const e={};return t.status!==void 0&&(e.status=t.status),t.started!==void 0&&(e.started=t.started),t.completed!==void 0&&(e.completed=t.completed),t.progress!==void 0&&(e.progress=t.progress),await f.trials.update(t.trialId,e),r.info(`ATOMIC_OPS: Successfully updated trial ${t.trialId}`),{ok:!0,value:void 0}}catch(e){return r.error(`ATOMIC_OPS: Failed to update trial ${t.trialId}:`,e),{ok:!1,error:e instanceof Error?e:new Error("Failed to update trial")}}}async resetRunningCallsToPending(t){r.info(`ATOMIC_OPS: Resetting running calls to pending for trial ${t}`);try{const e=await f.apiCalls.where("trialId").equals(t).and(a=>a.status==="running").toArray();return e.length===0?r.info(`ATOMIC_OPS: No running calls found for trial ${t}`):(await f.transaction("rw",f.apiCalls,async()=>{for(const a of e)await f.apiCalls.update(a.id,{status:"pending",started:void 0,response:void 0,result:void 0})}),r.info(`ATOMIC_OPS: Reset ${e.length} running calls to pending for trial ${t}`)),r.info("V4_TRIAL_DEBUG_PAUSE: Recalculating trial progress after call status changes"),await this.recalculateTrialProgress(t),{ok:!0,value:e.length}}catch(e){return r.error(`ATOMIC_OPS: Failed to reset running calls for trial ${t}:`,e),{ok:!1,error:e instanceof Error?e:new Error("Failed to reset running calls")}}}async getTrialCallCounts(t){r.info(`ATOMIC_OPS: Getting call counts for trial ${t}`);try{const e=await f.transaction("r",f.apiCalls,async()=>{const a=await f.apiCalls.where("trialId").equals(t).toArray();return{total:a.length,completed:a.filter(i=>i.status==="completed").length,failed:a.filter(i=>i.status==="failed").length,cancelled:a.filter(i=>i.status==="cancelled").length,pending:a.filter(i=>i.status==="pending").length,running:a.filter(i=>i.status==="running").length}});return r.info(`TRANSACTION_FIX: Trial ${t} call counts (consistent snapshot):`,e),{ok:!0,value:e}}catch(e){return r.error(`ATOMIC_OPS: Failed to get call counts for trial ${t}:`,e),{ok:!1,error:e instanceof Error?e:new Error("Failed to get call counts")}}}async updateApiCallsBatch(t){if(t.length===0)return{ok:!0,value:void 0};r.info(`ATOMIC_OPS: Updating batch of ${t.length} API calls`);try{return await f.transaction("rw",f.apiCalls,async()=>{for(const e of t){const a={status:e.status};e.started!==void 0&&(a.started=e.started),e.completed!==void 0&&(a.completed=e.completed),e.response!==void 0&&(a.response=e.response),e.error!==void 0&&(a.error=e.error),await f.apiCalls.update(e.callId,a)}}),r.info(`ATOMIC_OPS: Successfully updated batch of ${t.length} API calls`),{ok:!0,value:void 0}}catch(e){return r.error("ATOMIC_OPS: Failed to update API calls batch:",e),{ok:!1,error:e instanceof Error?e:new Error("Failed to update API calls batch")}}}async reconcileTrialState(t){r.info(`ATOMIC_OPS: Reconciling state for trial ${t}`);try{const e=await f.trials.get(t);if(!e)return{ok:!1,error:new Error(`Trial ${t} not found`)};const a=await this.getTrialCallCounts(t);if(!a.ok)return a;const i=a.value;let s=e.status;if(i.running>0?s="running":i.pending>0?s="paused":i.completed===i.total&&i.total>0||i.failed>0&&i.completed+i.failed===i.total?s="completed":i.cancelled>0&&(s="cancelled"),s!==e.status){r.info(`ATOMIC_OPS: Reconciling trial ${t} status: ${e.status} → ${s}`);const l=await this.updateTrial({trialId:t,status:s,progress:i,...s==="completed"&&{completed:new Date}});if(!l.ok)return l}else r.info(`ATOMIC_OPS: Trial ${t} status is consistent: ${s}`);return{ok:!0,value:s}}catch(e){return r.error(`ATOMIC_OPS: Failed to reconcile trial ${t} state:`,e),{ok:!1,error:e instanceof Error?e:new Error("Failed to reconcile trial state")}}}async performCleanupOperations(t){r.info(`ATOMIC_OPS: Performing cleanup operations for trial ${t}`);try{const e=await this.resetRunningCallsToPending(t);if(!e.ok)return e;const a=await this.reconcileTrialState(t);if(!a.ok)return a;const i={resetCount:e.value,reconciledStatus:a.value};return r.info(`ATOMIC_OPS: Cleanup complete for trial ${t}:`,i),{ok:!0,value:i}}catch(e){return r.error(`ATOMIC_OPS: Failed cleanup operations for trial ${t}:`,e),{ok:!1,error:e instanceof Error?e:new Error("Failed cleanup operations")}}}async recalculateTrialProgress(t){var e;try{const a=await f.trials.get(t);if(!a){r.info(`V4_TRIAL_DEBUG_PAUSE: Trial ${t} not found, cannot recalculate progress`);return}const i=await f.apiCalls.where("trialId").equals(t).toArray();let s=0,l=0,m=0,_=0,T=0;for(const n of i)switch(n.status){case"completed":s++;break;case"failed":l++,((e=n.result)==null?void 0:e.errorType)==="network_error_no_response"&&T++;break;case"cancelled":m++;break;case"running":_++;break}const h=a.progress.total-s-l-m-_,o={total:a.progress.total,completed:s,failed:l,cancelled:m,pending:h,running:_,networkErrors:T};r.info(`V4_TRIAL_DEBUG_PAUSE: Recalculated progress for trial ${t} - completed: ${s}, failed: ${l}, running: ${_}, pending: ${h}`),await f.trials.update(t,{progress:o}),r.info("V4_TRIAL_DEBUG_PAUSE: Trial progress updated successfully")}catch(a){r.error(`V4_TRIAL_DEBUG_PAUSE: Failed to recalculate progress for trial ${t}:`,a)}}async performSystemCleanup(){r.info("ATOMIC_OPS: Performing system-wide cleanup");try{let t=0,e=0;const a=await f.trials.where("status").equals("running").toArray();r.info(`ATOMIC_OPS: Found ${a.length} active trials for cleanup`);for(const s of a){const l=await this.performCleanupOperations(s.id);if(l.ok)t+=l.value.resetCount,e++;else{const m=l;r.warn(`ATOMIC_OPS: Failed to cleanup trial ${s.id}:`,m.error.message)}}const i={trialsProcessed:e,callsReset:t};return r.info("ATOMIC_OPS: System cleanup complete:",i),{ok:!0,value:i}}catch(t){return r.error("ATOMIC_OPS: System cleanup failed:",t),{ok:!1,error:t instanceof Error?t:new Error("System cleanup failed")}}}}const bt=new Ct;class Ot{constructor(){O(this,"playgroundService",null);O(this,"initialized",!1);O(this,"orchestrators",new Map);O(this,"activeStreams",new Map);O(this,"execution",y(()=>{const t=C.status.value;let e="idle";return t==="running"||t==="starting"||t==="pausing"?e="executing":t==="paused"?e="paused":e="idle",{status:e,currentTrialId:C.trialId.value,startedAt:C.currentState.value.startedAt}}));O(this,"progress",y(()=>({trials:new Map,activeApiCall:null,lastUpdated:new Date})));O(this,"queue",y(()=>({global:{pending:0,executing:0,capacity:0,utilization:0},providers:new Map})));O(this,"tabRole",y(()=>R.role.value));O(this,"isLeader",y(()=>R.isLeader.value));O(this,"canExecute",y(()=>R.isLeader.value&&C.canStart()))}async initialize(){const t=performance.now();if(r.info(`V4_TRIAL_SWITCH: V4ExecutionControl initialize() ENTRY at ${t}`),r.info(`V4_SINGLETON_DEBUG: Current initialized flag: ${this.initialized}`),r.info(`V4_SINGLETON_DEBUG: Active streams count: ${this.activeStreams.size}`),this.initialized){r.info("V4_SINGLETON_DEBUG: V4ExecutionControl already initialized, returning early - singleton working correctly!");return}try{r.info("V4_EXECUTION_CONTROL: Initializing with V4 coordination + V3 execution bridge");const e=performance.now();r.info(`V4_TRIAL_SWITCH: Starting multiTabCoordinator.initialize() at ${(e-t).toFixed(1)}ms`),await R.initialize();const a=performance.now();r.info(`V4_TRIAL_SWITCH: multiTabCoordinator.initialize() completed in ${(a-e).toFixed(1)}ms`),r.info("V4_EXECUTION_CONTROL: Performing system cleanup with V4 atomic operations");const i=performance.now();r.info(`V4_TRIAL_SWITCH: Starting atomicOperations.performSystemCleanup() at ${(i-t).toFixed(1)}ms`);const s=await bt.performSystemCleanup(),l=performance.now();if(r.info(`V4_TRIAL_SWITCH: atomicOperations.performSystemCleanup() completed in ${(l-i).toFixed(1)}ms`),s.ok)r.info("V4_EXECUTION_CONTROL: System cleanup completed:",s.value);else{const h=s;r.warn("V4_EXECUTION_CONTROL: System cleanup failed:",h.error)}const m=performance.now();r.info(`V4_TRIAL_SWITCH: Creating PlaygroundExecutionService at ${(m-t).toFixed(1)}ms`),this.playgroundService=new ct(async h=>{const o=await this.startTrialWithStreaming(h);return o.ok?{ok:!0,value:o.value.progress$}:o});const _=performance.now();r.info(`V4_TRIAL_SWITCH: PlaygroundExecutionService created in ${(_-m).toFixed(1)}ms`),this.initialized=!0;const T=performance.now();r.info(`V4_TRIAL_SWITCH: V4ExecutionControl initialization TOTAL: ${(T-t).toFixed(1)}ms`),r.info("V4_EXECUTION_CONTROL: Initialization complete")}catch(e){const a=performance.now();throw r.error(`V4_TRIAL_SWITCH: V4ExecutionControl initialization FAILED in ${(a-t).toFixed(1)}ms:`,e),e}}cleanup(){r.info("V4_SINGLETON_DEBUG: cleanup() called - this will reset initialized flag and destroy singleton!"),r.info(`V4_SINGLETON_DEBUG: Current active streams: ${this.activeStreams.size}`),r.info(`V4_SINGLETON_DEBUG: Current orchestrators: ${this.orchestrators.size}`);try{this.activeStreams.forEach((t,e)=>{r.info(`V4_SINGLETON_DEBUG: Cleaning up streams for trial ${e}`),t.subscription.unsubscribe()}),this.activeStreams.clear(),this.orchestrators.forEach((t,e)=>{r.info(`V4_SINGLETON_DEBUG: Cleaning up orchestrator for trial ${e}`)}),this.orchestrators.clear(),R.destroy(),this.playgroundService=null,this.initialized=!1,r.info("V4_SINGLETON_DEBUG: Cleanup complete - singleton destroyed, will reinitialize on next call")}catch(t){r.error("V4_EXECUTION_CONTROL: Cleanup error:",t)}}async startTrial(t){var e;this.initialized||await this.initialize(),r.info(`V4_EXECUTION_CONTROL: Starting trial ${t} with V4+V3 bridge`);try{if(G(t)){const m=await(((e=this.playgroundService)==null?void 0:e.executePlaygroundCall("",{}))||Promise.resolve({ok:!1,error:new Error("Playground service not available")}));return m.ok?{ok:!0,value:void 0}:{ok:!1,error:m.error}}let i=this.orchestrators.get(t);i||(r.info("V4_EXECUTION_CONTROL: Creating fresh V3 orchestrator for trial:",t),i=D(),this.orchestrators.set(t,i));const l=await i.startTrialAtomic(t);return l.ok?(r.info(`V4_EXECUTION_CONTROL: Successfully started trial ${t} via bridge`),{ok:!0,value:void 0}):{ok:!1,error:l.error}}catch(a){return r.error(`V4_EXECUTION_CONTROL: Failed to start trial ${t}:`,a),{ok:!1,error:a instanceof Error?a:new Error("Failed to start trial")}}}async startTrialWithStreaming(t){this.initialized||await this.initialize(),r.info(`V4_EXECUTION_CONTROL: Starting streaming trial ${t}`),this.cleanupStreams(t);try{if(G(t))return r.info("V4_EXECUTION_CONTROL: Playground trial detected, using specialized handling"),{ok:!1,error:new Error("Playground streaming not yet implemented in V4")};if(!this.canExecute.value)return r.info("V4_EXECUTION_CONTROL: Cannot start - not leader or invalid state"),{ok:!1,error:new Error("Cannot start trial - not leader or invalid state")};r.info("V4_EXECUTION_CONTROL: Updating state machine to running");const a=R.tabId.value,i=await C.startExecution(t,"streaming",a);if(!i.ok)return r.info("V4_EXECUTION_CONTROL: State machine update failed:",i.error),{ok:!1,error:i.error};let s=this.orchestrators.get(t);s||(r.info("V4_EXECUTION_CONTROL: Creating fresh V3 orchestrator for trial:",t),s=D(),this.orchestrators.set(t,s)),r.info("V4_EXECUTION_CONTROL: Calling V3 orchestrator startTrialAtomicWithStreaming");const l=await s.startTrialAtomicWithStreaming(t);if(!l.ok)return{ok:!1,error:l.error};r.info("V4_EXECUTION_CONTROL: Creating hot observables without accumulation"),r.info(`V4_EXECUTION_CONTROL: Creating hot observables for trial ${t}`);const m=l.value.progress$.pipe(j(),Et({bufferSize:1,refCount:!0})),_=new dt,T=new tt(1),h=l.value.calls$.pipe(ft(n=>(r.info(`V4_EXECUTION_CONTROL: Batch of ${n.length} calls from pipeline`),n.map(c=>c.call&&c.providerId?c.call:c)))).subscribe({next:n=>{r.info(`V4_EXECUTION_CONTROL: Forwarding ${n.length} calls to subject`),T.next(n)},error:n=>{r.info("V4_TRIAL_ERROR: Error in calls stream:",n),T.error(n)},complete:()=>{r.info(`V4_TRIAL_COMPLETE: Original calls stream completed for trial ${t}`)}});_.add(h);const o=T;return r.info("V4_TRIAL_REF_TEST: callsSubject === sharedCalls$?",T===o),_.add(m.subscribe({next:n=>{r.info(`V4_TRIAL_DEBUG_COMPLETION: Progress update for trial ${t}: ${n.type}`),(n.type==="completed"||n.type==="error")&&(r.info(`V4_TRIAL_DEBUG_COMPLETION: Trial ${t} ${n.type}, scheduling cleanup in 1000ms`),r.info(`V4_TRIAL_DEBUG_COMPLETION: Current execution state: ${C.status.value}`),r.info("V4_TRIAL_DEBUG_COMPLETION: Updating V4 coordination layer to completed/cancelled state"),n.type==="completed"?(r.info("V4_TRIAL_DEBUG_COMPLETION: Calling multiTabCoordinator.completeExecution()"),R.completeExecution().then(c=>{c.ok?(r.info("V4_TRIAL_DEBUG_COMPLETION: Coordination layer updated to completed successfully"),r.info(`V4_TRIAL_DEBUG_COMPLETION: Post-completion execution state: ${C.status.value}`)):r.error("V4_TRIAL_DEBUG_COMPLETION: Coordination layer completion update failed:",c.error)})):(r.info("V4_TRIAL_DEBUG_COMPLETION: Calling multiTabCoordinator.cancelExecution() for error"),R.cancelExecution().then(c=>{c.ok?(r.info("V4_TRIAL_DEBUG_COMPLETION: Coordination layer updated to cancelled successfully"),r.info(`V4_TRIAL_DEBUG_COMPLETION: Post-cancellation execution state: ${C.status.value}`)):r.error("V4_TRIAL_DEBUG_COMPLETION: Coordination layer cancellation update failed:",c.error)})),setTimeout(()=>{r.info(`V4_TRIAL_DEBUG_COMPLETION: Executing delayed cleanup for trial ${t}`),r.info(`V4_TRIAL_DEBUG_COMPLETION: Post-completion execution state: ${C.status.value}`),this.cleanupStreams(t),this.orchestrators.has(t)&&(r.info(`V4_TRIAL_DEBUG_COMPLETION: Removing orchestrator for completed trial ${t}`),this.orchestrators.delete(t))},1e3))},error:n=>{r.error(`V4_TRIAL_DEBUG_COMPLETION: Stream error for trial ${t}:`,n),r.info("V4_TRIAL_DEBUG_COMPLETION: Updating V4 coordination layer to cancelled state due to error"),R.cancelExecution().then(c=>{c.ok?(r.info("V4_TRIAL_DEBUG_COMPLETION: Coordination layer updated to cancelled after error"),r.info(`V4_TRIAL_DEBUG_COMPLETION: Post-error execution state: ${C.status.value}`)):r.error("V4_TRIAL_DEBUG_COMPLETION: Coordination layer error cancellation failed:",c.error)}),this.cleanupStreams(t),this.orchestrators.has(t)&&(r.info(`V4_TRIAL_DEBUG_COMPLETION: Removing orchestrator for errored trial ${t}`),this.orchestrators.delete(t))}})),r.info(`V4_TRIAL_STORE: Storing activeStreams for trial ${t}`),this.activeStreams.set(t,{streams:l.value,subscription:_,sharedProgress$:m,sharedCalls$:o,callsSubject:T}),r.info(`V4_EXECUTION_CONTROL: Successfully created hot observables for trial ${t}`),{ok:!0,value:l.value}}catch(e){return r.error(`V4_EXECUTION_CONTROL: Failed to start streaming trial ${t}:`,e),{ok:!1,error:e instanceof Error?e:new Error("Failed to start streaming trial")}}}async pauseExecution(){this.initialized||await this.initialize();const t=C.trialId.value;if(r.info(`V4_TRIAL_DEBUG_PAUSE: pauseExecution() ENTRY for trial ${t||"NONE"}`),r.info(`V4_TRIAL_DEBUG_PAUSE: Current execution state: ${C.status.value}`),r.info(`V4_TRIAL_DEBUG_PAUSE: Active streams count: ${this.activeStreams.size}`),!t)return r.info("V4_TRIAL_DEBUG_PAUSE: ERROR - No active trial to pause"),{ok:!1,error:new Error("No active trial to pause")};if(!C.canPause())return r.info("V4_TRIAL_DEBUG_PAUSE: Cannot pause - invalid state"),{ok:!1,error:new Error("Cannot pause in current state")};r.info("V4_TRIAL_DEBUG_PAUSE: Calling V3 orchestrator pauseTrial FIRST");const e=this.orchestrators.get(t);e&&(await e.pauseTrial(),r.info("V4_TRIAL_DEBUG_PAUSE: V3 pipeline paused, keeping orchestrator alive for potential hot resume")),r.info("V4_TRIAL_DEBUG_PAUSE: V3 paused, now updating state machine to paused");const a=await C.pauseExecution();return a.ok?(R.pauseExecution(),r.info("V4_TRIAL_DEBUG_PAUSE: Pause successful"),{ok:!0,value:void 0}):(r.info("V4_TRIAL_DEBUG_PAUSE: State machine update failed:",a.error),a)}async resumeExecution(t){this.initialized||await this.initialize();const e=t||C.trialId.value;if(r.info(`V4_TRIAL_DEBUG_RESUME: resumeExecution() ENTRY for trial ${e||"NONE"}`),r.info(`V4_TRIAL_DEBUG_RESUME: Current execution state: ${C.status.value}`),r.info(`V4_TRIAL_DEBUG_RESUME: Active streams count: ${this.activeStreams.size}`),r.info(`V4_TRIAL_DEBUG_RESUME: Provided trialId: ${t||"NONE"}, state trialId: ${C.trialId.value||"NONE"}`),!e)return r.info("V4_TRIAL_DEBUG_RESUME: ERROR - No trial ID provided and no active trial to resume"),{ok:!1,error:new Error("No trial ID provided and no active trial to resume")};if(!C.canResume())return r.info("V4_TRIAL_DEBUG_RESUME: Cannot resume - invalid state"),{ok:!1,error:new Error("Cannot resume in current state")};r.info("V4_TRIAL_DEBUG_RESUME: Updating state machine to running");const a=R.tabId.value,i=await C.resumeExecution(e,a);if(!i.ok)return r.info("V4_TRIAL_DEBUG_RESUME: State machine update failed:",i.error),i;let s=this.orchestrators.get(e);if(s)r.info(`V4_TRIAL_DEBUG_RESUME: HOT RESUME - Found existing orchestrator for trial ${e}`),r.info("V4_TRIAL_DEBUG_RESUME: Calling orchestrator.resumeTrial() to flip pause$ and resume pipeline"),s.resumeTrial();else{r.info(`V4_TRIAL_DEBUG_RESUME: COLD RESUME - No orchestrator found for trial ${e}`),r.info("V4_TRIAL_DEBUG_RESUME: Creating fresh orchestrator and starting with pending calls"),s=D(),this.orchestrators.set(e,s),r.info("V4_TRIAL_DEBUG_RESUME: Calling startTrialAtomicWithStreaming to create new pipeline");const l=await s.startTrialAtomicWithStreaming(e);if(!l.ok)return r.error("V4_TRIAL_DEBUG_RESUME: Failed to start trial for cold resume:",l.error),{ok:!1,error:l.error};r.info("V4_TRIAL_DEBUG_RESUME: Cold resume successful, storing new streams")}return R.resumeExecution(e),r.info("V4_TRIAL_DEBUG_RESUME: Resume successful"),{ok:!0,value:void 0}}async cancelExecution(){this.initialized||await this.initialize(),r.info("V4_EXECUTION_CONTROL: Cancelling execution");const t=C.trialId.value;if(!t)return{ok:!1,error:new Error("No active trial to cancel")};if(!C.canCancel())return r.info("V4_EXECUTION_CONTROL: Cannot cancel - invalid state"),{ok:!1,error:new Error("Cannot cancel in current state")};r.info("V4_EXECUTION_CONTROL: Updating state machine to cancelled");const e=await C.cancelExecution();if(!e.ok)return r.info("V4_EXECUTION_CONTROL: State machine update failed:",e.error),e;r.info("V4_EXECUTION_CONTROL: Calling V3 orchestrator cancelTrial");const a=this.orchestrators.get(t);return a&&(a.cancelTrial(),r.info("V4_EXECUTION_CONTROL: Removing orchestrator after cancel"),this.orchestrators.delete(t)),R.cancelExecution(),this.cleanupStreams(t),r.info("V4_EXECUTION_CONTROL: Cancel successful"),{ok:!0,value:void 0}}async executeSingleCall(t,e,a){return this.initialized||await this.initialize(),this.playgroundService?this.playgroundService.executePlaygroundCall(t,a):{ok:!1,error:new Error("Playground service not initialized")}}getActiveStreams(t){const e=this.activeStreams.get(t);return r.info(`V4_TRIAL_GET: getActiveStreams(${t}) called, found: ${!!e}, has sharedCalls$: ${!!(e!=null&&e.sharedCalls$)}`),e}cleanupStreams(t){r.info(`V4_TRIAL_DEBUG_CLEANUP: cleanupStreams() ENTRY for trial ${t}`),r.info(`V4_TRIAL_DEBUG_CLEANUP: Current execution state: ${C.status.value}`),r.info(`V4_TRIAL_DEBUG_CLEANUP: Current state trialId: ${C.trialId.value}`);const e=this.activeStreams.get(t);e?(r.info(`V4_TRIAL_DEBUG_CLEANUP: Found streams for trial ${t}, unsubscribing`),e.subscription.unsubscribe(),this.activeStreams.delete(t),r.info(`V4_TRIAL_DEBUG_CLEANUP: Cleaned up streams, remaining active streams: ${this.activeStreams.size}`)):r.info(`V4_TRIAL_DEBUG_CLEANUP: No streams found for trial ${t} (already cleaned up?)`)}}let U=null;function Rt(){return U||(U=new Ot),U}class et{async createTrial(t){try{const e=this.validateTrialConfig(t);if(!e.ok)return{ok:!1,error:e.error};const a=await this.createConfigurationSnapshots(t.configurations);let i=t.templateConfig;if(t.type==="template"&&i){const m=await this.createVariableSnapshots(i.variables);i={...i,variables:m,hasSnapshots:!0}}const s={id:V("trial"),name:t.name,description:t.description,type:t.type,status:"draft",configurations:a,progress:{total:0,completed:0,failed:0,cancelled:0,pending:0,running:0,networkErrors:0},created:new Date,...t.repeatCount&&t.repeatCount>1?{repeatConfig:{callsPerPrompt:t.repeatCount}}:{},...t.type==="template"&&i?{templateConfig:i}:{},...t.type==="spreadsheet"&&t.spreadsheetConfig?{spreadsheetConfig:t.spreadsheetConfig}:{}},l=await this.generateApiCalls(s,t.repeatCount||1);return s.progress.total=l.length,s.progress.pending=l.length,await f.transaction("rw",f.trials,f.apiCalls,async()=>{await f.trials.add(s),l.length>0&&await f.apiCalls.bulkAdd(l)}),r.info(`V4_TRIALS: Created trial ${s.id} with ${l.length} API calls`),{ok:!0,value:s.id}}catch(e){return r.error("V4_TRIALS: Failed to create trial:",e),{ok:!1,error:e instanceof Error?e:new Error("Failed to create trial")}}}async updateTrial(t,e){try{return await f.transaction("rw",f.trials,async()=>{const a=await f.trials.get(t);if(!a)throw new Error(`Trial not found: ${t}`);const i={...a,...e,created:a.created};await f.trials.put(i)}),{ok:!0}}catch(a){return r.error("V4_TRIALS: Failed to update trial:",a),{ok:!1,error:a instanceof Error?a:new Error("Failed to update trial")}}}async deleteTrial(t){try{return await f.transaction("rw",f.trials,f.apiCalls,async()=>{const e=await f.trials.get(t);if(!e)throw new Error(`Trial not found: ${t}`);if(e.status==="running")throw new Error("Cannot delete running trial");await f.apiCalls.where("trialId").equals(t).delete(),await f.trials.delete(t)}),r.info(`V4_TRIALS: Deleted trial ${t} and all associated API calls`),{ok:!0}}catch(e){return r.error("V4_TRIALS: Failed to delete trial:",e),{ok:!1,error:e instanceof Error?e:new Error("Failed to delete trial")}}}async duplicateTrial(t){try{const e=await f.trials.get(t);if(!e)return{ok:!1,error:new Error(`Source trial not found: ${t}`)};const a={name:`${e.name} (Copy)`,description:e.description,type:e.type,configurations:e.configurations.map(i=>{var s;return{provider:i.provider,modelId:i.modelId,parameters:i.parameters,name:(s=i.modelSnapshot)==null?void 0:s.displayName}}),repeatCount:e.repeatCount,...e.type==="template"&&e.templateConfig?{templateConfig:e.templateConfig}:{},...e.type==="spreadsheet"&&e.spreadsheetConfig?{spreadsheetConfig:e.spreadsheetConfig}:{}};return this.createTrial(a)}catch(e){return r.error("V4_TRIALS: Failed to duplicate trial:",e),{ok:!1,error:e instanceof Error?e:new Error("Failed to duplicate trial")}}}async updateTrialProgress(t){try{return await f.transaction("rw",f.trials,f.apiCalls,async()=>{var h;const e=await f.trials.get(t);if(!e)throw new Error(`Trial not found: ${t}`);const a=await f.apiCalls.where("trialId").equals(t).toArray();let i=0,s=0,l=0,m=0,_=0;for(const o of a)switch(o.status){case"completed":i++;break;case"failed":s++,((h=o.result)==null?void 0:h.errorType)==="network_error_no_response"&&_++;break;case"cancelled":l++;break;case"running":m++;break}const T=e.progress.total-i-s-l-m;e.progress={total:e.progress.total,completed:i,failed:s,cancelled:l,pending:T,running:m,networkErrors:_},i+s+l>=e.progress.total&&e.status==="running"&&(e.status="completed",e.completed=new Date),await f.trials.put(e)}),{ok:!0}}catch(e){return r.error("V4_TRIALS: Failed to update trial progress:",e),{ok:!1,error:e instanceof Error?e:new Error("Failed to update progress")}}}async generateApiCalls(t,e){return r.info(`V4_TRIALS: Generating REAL API calls for trial ${t.id}, type: ${t.type}`),t.type==="template"&&t.templateConfig?this.generateTemplateApiCalls(t,t.templateConfig,e):t.type==="spreadsheet"&&t.spreadsheetConfig?this.generateSpreadsheetApiCalls(t,t.spreadsheetConfig,e):t.type==="playground"?[]:(r.warn(`V4_TRIALS: Unknown trial type or missing config for trial ${t.id}`),[])}async generateTemplateApiCalls(t,e,a){if(!e)return[];const i=[];let s=0;const l=await this.generateVariableCombinations(e.variables);r.info(`V4_TRIALS: Generated ${l.length} variable combinations`);for(let m=0;m<a;m++)for(let _=0;_<t.configurations.length;_++)for(const T of l){const h=this.substituteVariables(e.template,T.variables),o={id:V("call"),trialId:t.id,configurationIndex:_,order:s++,variables:T.variables,variableAttributes:T.variableAttributes,variableIndices:T.variableIndices,prompt:h,status:"pending",retryCount:0,created:new Date};i.push(o)}return r.info(`V4_TRIALS: Generated ${i.length} REAL API calls for template trial`),i}async generateSpreadsheetApiCalls(t,e,a){var m;if(!e)return[];const i=[];let s=0;const l=await f.variableLists.get(e.datasetId);if(!l||l.category!=="tabular"||!((m=l.tabularData)!=null&&m.rows))return r.warn(`V4_TRIALS: Dataset ${e.datasetId} not found or invalid`),[];for(let _=0;_<a;_++)for(const T of l.tabularData.rows){const h=this.substituteVariables(e.promptPattern,T);for(let o=0;o<t.configurations.length;o++){const n={id:V("call"),trialId:t.id,configurationIndex:o,order:s++,variables:T,prompt:h,status:"pending",retryCount:0,created:new Date};i.push(n)}}return r.info(`V4_TRIALS: Generated ${i.length} REAL API calls for spreadsheet trial`),i}async generateVariableCombinations(t){var m;const e=Object.keys(t).sort();if(e.length===0)return[{variables:{}}];const a={};for(const _ of e){const T=t[_];let h=[];const o=T;if(o.snapshot)h=o.snapshot.items.map(n=>({value:n.value,attributes:n.attributes}));else if(T.type==="value"&&T.values)h=T.values.map(n=>({value:n}));else if(T.type==="list"&&T.listId){const n=await f.variableLists.get(T.listId);n&&(n.category==="simple"&&n.values?h=n.values.map(c=>({value:c})):n.category==="attributed"&&n.items?h=n.items.map(c=>({value:c.value||c.name||String(c),attributes:c.attributes||{}})):n.category==="tabular"&&((m=n.tabularData)!=null&&m.rows)&&(h=n.tabularData.rows.map(c=>({value:c.name||c[Object.keys(c)[0]]||String(c)}))))}a[_]=h}const s=e.map(_=>Math.max(a[_].length,1)).reduce((_,T)=>_*T,1),l=[];for(let _=0;_<s;_++){const T={},h={},o={};let n=_;for(let b=e.length-1;b>=0;b--){const g=e[b],u=a[g];if(u.length>0){const d=n%u.length,E=u[d];T[g]=E.value,o[g]=d,E.attributes&&Object.keys(E.attributes).length>0&&(h[g]={...E.attributes}),n=Math.floor(n/u.length)}else T[g]="",o[g]=0}const c={variables:T};Object.keys(h).length>0&&(c.variableAttributes=h),Object.keys(o).length>0&&(c.variableIndices=o),l.push(c)}return l}substituteVariables(t,e){let a=t;for(const[i,s]of Object.entries(e)){const l=new RegExp(`\\{\\{\\s*${i}\\s*\\}\\}`,"g");a=a.replace(l,s)}return a}validateTrialConfig(t){var e;if(!t.name||t.name.trim().length===0)return{ok:!1,error:new Error("Trial name is required")};if(!t.configurations||t.configurations.length===0)return{ok:!1,error:new Error("At least one model configuration is required")};for(const a of t.configurations){if(!P.getProvider(a.provider))return{ok:!1,error:new Error(`Provider not found: ${a.provider}`)};const s=P.validateParameters(a.provider,a.modelId,a.parameters);if(!s.valid)return{ok:!1,error:new Error(`Invalid parameters: ${((e=s.errors)==null?void 0:e.join(", "))||"Validation failed"}`)}}if(t.type==="template"){if(!t.templateConfig||!t.templateConfig.template)return{ok:!1,error:new Error("Template is required for template trials")}}else if(t.type==="spreadsheet"&&(!t.spreadsheetConfig||!t.spreadsheetConfig.promptPattern))return{ok:!1,error:new Error("Prompt pattern is required for spreadsheet trials")};return{ok:!0}}async createConfigurationSnapshots(t){const e=[];for(const a of t){const i=P.getProvider(a.provider);if(!i)throw new Error(`Provider not found: ${a.provider}`);const l=(await f.models.where("provider").equals(a.provider).toArray()).find(_=>_.modelId===a.modelId),m={provider:a.provider,modelId:a.modelId,parameters:a.parameters,providerSnapshot:i,modelSnapshot:l||{id:`${a.provider}:${a.modelId}`,provider:a.provider,modelId:a.modelId,displayName:a.name||a.modelId,enabled:!0,source:"user"}};e.push(m)}return e}async createVariableSnapshots(t){const e={};for(const[a,i]of Object.entries(t)){const s={...i};if(i.type==="value"&&i.values)s.snapshot={source:{type:"direct",snapshotDate:new Date},items:i.values.map(l=>({value:l}))};else if(i.type==="list"&&i.listId){const l=await f.variableLists.get(i.listId);l&&(s.snapshot=await this.snapshotVariableList(l))}e[a]=s}return e}async snapshotVariableList(t){var a,i,s;const e={source:{type:t.category,listId:t.id,listName:t.name,snapshotDate:new Date},items:[]};switch(t.category){case"simple":case"refusal":e.items=((a=t.values)==null?void 0:a.map(l=>({value:l})))||[];break;case"attributed":e.items=((i=t.items)==null?void 0:i.map(l=>({value:l.value,attributes:{...l.attributes}})))||[],e.attributeKeys=[...t.attributeKeys||[]];break;case"tabular":(s=t.tabularData)!=null&&s.rows&&(e.items=t.tabularData.rows.map(l=>({value:l.name||l[Object.keys(l)[0]]||""})));break}return e}}const N=new et,Lt=Object.freeze(Object.defineProperty({__proto__:null,V4TrialOperations:et,v4TrialOperations:N},Symbol.toStringTag,{value:"Module"}));function xt(){const p=k(!1),t=k(!1),e=k(!1),a=k(!1),i=k(null),s=async u=>{p.value=!0,i.value=null;try{r.info("V4_TRIAL_COMMANDS: Creating trial with config:",u);const d=await N.createTrial(u);return d.ok?r.info("V4_TRIAL_COMMANDS: Trial created successfully:",d.value):(i.value=d.error||new Error("Failed to create trial"),r.error("V4_TRIAL_COMMANDS: Create trial failed:",d.error)),d}finally{p.value=!1}},l=async(u,d,E)=>{try{const v=await f.template_prompts.get(u);if(!v)return{ok:!1,error:new Error(`Template not found: ${u}`)};const I={name:E||`${v.name} - ${new Date().toLocaleString()}`,description:v.description,type:"template",configurations:d,repeatCount:1,templateConfig:{template:v.template,templateId:v.id,templateName:v.name,variables:v.variables||{},outputType:v.outputType,extractPattern:v.extractPattern,refusalWords:v.refusalWords?[...v.refusalWords]:void 0,rejectRefusalWords:v.rejectRefusalWords}};return s(I)}catch(v){return r.error("V4_TRIAL_COMMANDS: Failed to create trial from template:",v),{ok:!1,error:v instanceof Error?v:new Error("Failed to create trial from template")}}},m=async(u,d,E,v)=>{try{const I=await f.variableLists.get(d);if(!I||I.category!=="tabular")return{ok:!1,error:new Error(`Dataset not found or not tabular: ${d}`)};const w={name:v||`Spreadsheet Trial - ${new Date().toLocaleString()}`,type:"spreadsheet",configurations:E,spreadsheetConfig:{promptPattern:u,datasetId:d}};return s(w)}catch(I){return r.error("V4_TRIAL_COMMANDS: Failed to create spreadsheet trial:",I),{ok:!1,error:I instanceof Error?I:new Error("Failed to create spreadsheet trial")}}},_=async(u,d)=>{t.value=!0,i.value=null;try{const E=await N.updateTrial(u,d);return E.ok||(i.value=E.error||new Error("Failed to update trial"),r.error("V4_TRIAL_COMMANDS: Update trial failed:",E.error)),E}finally{t.value=!1}},T=async(u,d)=>_(u,{status:d}),h=async u=>{e.value=!0,i.value=null;try{r.info("V4_TRIAL_COMMANDS: Deleting trial:",u);const d=await N.deleteTrial(u);return d.ok?r.info("V4_TRIAL_COMMANDS: Trial deleted successfully"):(i.value=d.error||new Error("Failed to delete trial"),r.error("V4_TRIAL_COMMANDS: Delete trial failed:",d.error)),d}finally{e.value=!1}},o=async u=>{e.value=!0,i.value=null;try{return r.info("V4_TRIAL_COMMANDS: Deleting multiple trials:",u.length),await f.transaction("rw",f.trials,f.apiCalls,async()=>{for(const d of u){const E=await f.trials.get(d);E&&E.status!=="running"&&(await f.apiCalls.where("trialId").equals(d).delete(),await f.trials.delete(d))}}),r.info("V4_TRIAL_COMMANDS: Multiple trials deleted successfully"),{ok:!0}}catch(d){return r.error("V4_TRIAL_COMMANDS: Failed to delete multiple trials:",d),i.value=d instanceof Error?d:new Error("Failed to delete trials"),{ok:!1,error:i.value}}finally{e.value=!1}},n=async u=>{a.value=!0,i.value=null;try{r.info("V4_TRIAL_COMMANDS: Duplicating trial:",u);const d=await N.duplicateTrial(u);return d.ok?r.info("V4_TRIAL_COMMANDS: Trial duplicated successfully:",d.value):(i.value=d.error||new Error("Failed to duplicate trial"),r.error("V4_TRIAL_COMMANDS: Duplicate trial failed:",d.error)),d}finally{a.value=!1}},c=async u=>{var d,E;try{let v=1;if(u.type==="template"&&u.templateConfig){const w=u.templateConfig.variables;for(const[,S]of Object.entries(w))if(S.type==="value"&&S.values)v*=S.values.length;else if(S.type==="list"&&S.listId){const A=await f.variableLists.get(S.listId);A&&(A.category==="simple"&&A.values?v*=A.values.length:A.category==="attributed"&&A.items?v*=A.items.length:A.category==="tabular"&&((d=A.tabularData)!=null&&d.rows)&&(v*=A.tabularData.rows.length))}}else if(u.type==="spreadsheet"&&u.spreadsheetConfig){const w=await f.variableLists.get(u.spreadsheetConfig.datasetId);w&&w.category==="tabular"&&((E=w.tabularData)!=null&&E.rows)&&(v=w.tabularData.rows.length)}return v*u.configurations.length*(u.repeatCount||1)}catch(v){return r.error("V4_TRIAL_COMMANDS: Failed to calculate API call count:",v),0}};return{createTrial:s,createTrialFromTemplate:l,createTrialFromSpreadsheet:m,updateTrial:_,updateTrialStatus:T,deleteTrial:h,deleteMultipleTrials:o,duplicateTrial:n,generateApiCallCount:c,estimateTrialCost:async u=>{var d,E;try{const v=await c(u);let I=0;for(const w of u.configurations){const A=(await f.models.where("provider").equals(w.provider).toArray()).find(L=>L.modelId===w.modelId);if(A!=null&&A.capabilities){const $=((d=w.parameters)==null?void 0:d.max_tokens)||((E=w.parameters)==null?void 0:E.maxTokens)||256,rt=(A.capabilities.inputCostPerToken||0)*150,at=(A.capabilities.outputCostPerToken||0)*$;I+=(rt+at)*v/u.configurations.length}}return I}catch(v){return r.error("V4_TRIAL_COMMANDS: Failed to estimate cost:",v),0}},validateTrialConfig:u=>!u.name||u.name.trim().length===0?{ok:!1,error:new Error("Trial name is required")}:!u.configurations||u.configurations.length===0?{ok:!1,error:new Error("At least one model configuration is required")}:u.type==="template"&&!u.templateConfig?{ok:!1,error:new Error("Template configuration is required for template trials")}:u.type==="spreadsheet"&&!u.spreadsheetConfig?{ok:!1,error:new Error("Spreadsheet configuration is required for spreadsheet trials")}:{ok:!0},isCreating:p,isUpdating:t,isDeleting:e,isDuplicating:a,lastError:i}}const H=10;function kt(){const p=pt(),t=ht();function e(o,n,c){var v;if(!o)return 0;let b=o;const g=/\{\{?\s*(\w+)\s*\}?\}/g,u=new Set;b=b.replace(g,(I,w)=>(u.add(w),""));const d=t.estimateTokens(b);let E=0;for(const[I,w]of Object.entries(n)){if(!u.has(I))continue;let S=[];if(w.type==="value"&&w.values)S=w.values;else if(w.type==="list"&&w.listId&&c){const A=c.find(L=>L.id===w.listId);A&&(A.category==="simple"?S=A.values||[]:A.category==="attributed"&&(S=((v=A.items)==null?void 0:v.map(L=>L.value))||[]))}if(S.length>0){const A=S.reduce((L,$)=>L+t.estimateTokens($),0);E+=A/S.length}}return Math.ceil(d+E)}function a(o){return o?t.estimateTokens(o):0}function i(o,n,c){const b=p.getOutputTokenLimit(o,n,c);if(!b)return r.warn("No output token limit found for model",{provider:o,modelId:n}),{min:-1,max:-1,expected:-1};const g=["max_tokens","max_completion_tokens","max_output_tokens","num_predict","maxTokens"];let u=0;for(const d of g)if(c[d]!==void 0){u=c[d];break}return u||(u=b),{min:H,max:b,expected:Math.min(u,b)}}function s(o,n,c={}){var v,I;if(!n)return h();const b=i(n.provider,n.modelId,c);if(b.expected===-1)return{tokens:{input:o,output:{min:-1,max:-1,expected:-1}},cost:{input:0,output:{min:-1,max:-1,expected:-1},total:{min:-1,max:-1,expected:-1}},meta:{hasValidCost:!1,isLocalModel:n.provider.includes("ollama")||n.provider==="deterministic",confidence:"low",provider:n.provider,modelId:n.modelId}};const g=((v=n.capabilities)==null?void 0:v.inputCostPerToken)||0,u=((I=n.capabilities)==null?void 0:I.outputCostPerToken)||0,d=o*g;let E="low";return g>0&&u>0&&(b.expected>0?E="high":E="medium"),{tokens:{input:o,output:b},cost:{input:d,output:{min:b.min*u,max:b.max*u,expected:b.expected*u},total:{min:d+b.min*u,max:d+b.max*u,expected:d+b.expected*u}},meta:{hasValidCost:g>0||u>0,isLocalModel:n.provider.includes("ollama")||n.provider==="deterministic",confidence:E,provider:n.provider,modelId:n.modelId}}}function l(o,n="range"){if(o.cost.total.expected===-1)return"Unable to estimate";if(o.meta.isLocalModel)return"Free (local)";if(!o.meta.hasValidCost)return"No pricing data";if(o.cost.total.max===0)return"Free";switch(n){case"compact":return m(o.cost.total.expected);case"range":const c=m(o.cost.total.min),b=m(o.cost.total.max),g=m(o.cost.total.expected);return Math.abs(o.cost.total.max-o.cost.total.min)<1e-4?g:`~${g} (${c}-${b})`;case"detailed":const u=`${o.tokens.input} input`,d=`${o.tokens.output.min}-${o.tokens.output.max} output`,E=`${m(o.cost.total.min)}-${m(o.cost.total.max)}`;return`${u} + ${d} tokens: ${E}`;case"tokens":return`${o.tokens.input} + ${o.tokens.output.min}-${o.tokens.output.max} tokens`}}function m(o){return o===0?"$0":o<1e-4?"<$0.0001":o<.01?`$${o.toFixed(4)}`:o<1?`$${o.toFixed(3)}`:o<10?`$${o.toFixed(2)}`:`$${Math.round(o)}`}function _(o){return o.length===0?h():o.reduce((n,c)=>({tokens:{input:n.tokens.input+c.tokens.input,output:{min:n.tokens.output.min+c.tokens.output.min,max:n.tokens.output.max+c.tokens.output.max,expected:n.tokens.output.expected+c.tokens.output.expected}},cost:{input:n.cost.input+c.cost.input,output:{min:n.cost.output.min+c.cost.output.min,max:n.cost.output.max+c.cost.output.max,expected:n.cost.output.expected+c.cost.output.expected},total:{min:n.cost.total.min+c.cost.total.min,max:n.cost.total.max+c.cost.total.max,expected:n.cost.total.expected+c.cost.total.expected}},meta:{hasValidCost:c.meta.hasValidCost||n.meta.hasValidCost,isLocalModel:c.meta.isLocalModel&&n.meta.isLocalModel,confidence:c.meta.confidence==="low"?"low":n.meta.confidence,provider:"multiple",modelId:"multiple"}}),h())}function T(o,n){return{tokens:{input:o.tokens.input*n,output:{min:o.tokens.output.min*n,max:o.tokens.output.max*n,expected:o.tokens.output.expected*n}},cost:{input:o.cost.input*n,output:{min:o.cost.output.min*n,max:o.cost.output.max*n,expected:o.cost.output.expected*n},total:{min:o.cost.total.min*n,max:o.cost.total.max*n,expected:o.cost.total.expected*n}},meta:o.meta}}function h(){return{tokens:{input:0,output:{min:0,max:0,expected:0}},cost:{input:0,output:{min:0,max:0,expected:0},total:{min:0,max:0,expected:0}},meta:{hasValidCost:!1,isLocalModel:!1,confidence:"low",provider:"",modelId:""}}}return{calculateTemplateTokens:e,calculatePromptTokens:a,getOutputTokenRange:i,estimateCost:s,formatCost:l,formatSingleCost:m,sumEstimates:_,multiplyEstimate:T,createEmptyEstimate:h,MIN_OUTPUT_TOKENS:H}}export{J as C,K as F,xt as a,Rt as b,kt as c,St as d,wt as u,Lt as v};
