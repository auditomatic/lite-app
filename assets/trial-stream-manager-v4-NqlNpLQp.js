var $=Object.defineProperty;var w=(_,t,r)=>t in _?$(_,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):_[t]=r;var u=(_,t,r)=>w(_,typeof t!="symbol"?t+"":t,r);import{a as e,d as V}from"./index-NVW3ASE7.js";import{u as v}from"./execution-control-v4-C_qod2He.js";import{s as C,c as O}from"./vue-vendor-DPw1dQYc.js";class M{constructor(){u(this,"apiCalls",C([]));u(this,"currentTrialId",C(null));u(this,"executionProgress",C(null));u(this,"isStreaming",C(!1));u(this,"activeTab",C("tasks"));u(this,"_progressCache",null);u(this,"_progressDirty",!0);u(this,"_progressLastCount",0)}get progress(){return O(()=>this.calculateProgress())}calculateProgress(){const t=this.apiCalls.value;if(!this._progressDirty&&this._progressLastCount===t.length&&this._progressCache)return this._progressCache;const r=performance.now();if(t.length===0)return this._progressCache={trialId:this.currentTrialId.value||"",total:0,completed:0,failed:0,cancelled:0,pending:0,running:0,lastUpdated:new Date},this._progressDirty=!1,this._progressLastCount=0,this._progressCache;let o=0,a=0,f=0,c=0,n=0;e.info(`V4_STORE_PROGRESS_LAZY: Computing progress from ${t.length} calls (cache was ${this._progressDirty?"dirty":"clean"})`);for(const p of t)switch(p.status){case"completed":o++;break;case"failed":a++;break;case"cancelled":f++;break;case"pending":c++;break;case"running":n++;break}const d=performance.now();return this._progressCache={trialId:this.currentTrialId.value||"",total:t.length,completed:o,failed:a,cancelled:f,pending:c,running:n,lastUpdated:new Date},this._progressDirty=!1,this._progressLastCount=t.length,e.info(`V4_STORE_PROGRESS_LAZY: Computed in ${(d-r).toFixed(1)}ms - ${o}/${t.length} completed, ${n} running, ${c} pending`),this._progressCache}updateApiCalls(t){const r=this.apiCalls.value.length,o=t.length;this._progressDirty=!0,this.apiCalls.value=Object.freeze(t),(Math.abs(o-r)>10||o<100)&&e.info(`V4_STORE_UPDATE: Updated ${t.length} calls (was ${r})`)}updateProgress(t){e.info("STORE_V4: Updating progress:",t.type),this.executionProgress.value=t}setStreaming(t){e.info(`STORE_V4: Set streaming: ${t}`),this.isStreaming.value=t}setCurrentTrial(t){e.info(`STORE_V4: Set current trial: ${t}`),this.currentTrialId.value=t,t||this.clear()}setActiveTab(t){this.activeTab.value!==t&&(e.info(`STORE_V4_TAB: Active tab changed from ${this.activeTab.value} to ${t}`),this.activeTab.value=t)}clear(){e.info("STORE_V4: Clearing store data"),this.apiCalls.value=[],this.executionProgress.value=null,this.isStreaming.value=!1}async refreshFromDatabase(t){e.info(`STORE_V4: Refreshing data from database for trial ${t}`);try{const r=await V.apiCalls.where("trialId").equals(t).toArray();e.info(`STORE_V4: Loaded ${r.length} calls from database`),r.sort((o,a)=>{const f=d=>{switch(d){case"running":return 0;case"completed":return 1;case"failed":return 2;case"pending":return 3;default:return 4}},c=f(o.status),n=f(a.status);return c!==n?c-n:o.order-a.order}),this.updateApiCalls(r),this.setCurrentTrial(t),e.info("STORE_V4: Refresh complete - store updated with fresh data")}catch(r){throw e.error("STORE_V4: Failed to refresh from database:",r),r}}}let R=null;function y(){return R||(R=new M,e.info("STORE_V4: Created singleton store instance")),R}typeof window<"u"&&(window.__trialDataStoreV4=()=>R);class L{constructor(){u(this,"subscription",null);u(this,"progressSubscription",null);u(this,"store",y());u(this,"v4Control",v());u(this,"isActive",!1);u(this,"currentTrialId",null)}async startStreaming(t){const r=performance.now();e.info(`V4_TRIAL_SWITCH: Stream manager starting for trial ${t}`),this.cleanupSubscriptions();const o=performance.now();e.info(`V4_TRIAL_SWITCH: Stream cleanup completed in ${(o-r).toFixed(1)}ms`),this.isActive=!0,e.info(`V4_TRIAL_SWITCH: Set isActive = true to pause reactive queries at ${(o-r).toFixed(1)}ms`),this.currentTrialId=t,this.store.setCurrentTrial(t),this.store.setStreaming(!0);const a=performance.now();e.info(`V4_TRIAL_SWITCH: Store updated in ${(a-o).toFixed(1)}ms`);const f=performance.now();e.info("V4_TRIAL_SWITCH: ALWAYS loading complete historical data first"),await this.loadHistoricalData(t);const c=performance.now();e.info(`V4_TRIAL_SWITCH: Historical data loading completed in ${(c-f).toFixed(1)}ms - store now has complete dataset`);const n=performance.now();e.info("V4_TRIAL_SWITCH: Checking for active streams to overlay updates");const d=this.v4Control.getActiveStreams(t),p=performance.now();if(e.info(`V4_TRIAL_SWITCH: Stream check completed in ${(p-n).toFixed(1)}ms, result: ${d?"FOUND":"NONE"}`),!d){e.info(`V4_TRIAL_SWITCH: No active streams for trial ${t}, using complete historical data only`);const g=await V.trials.get(t);if(g&&g.status==="running"){e.info(`V4_TRIAL_SWITCH: Running trial ${t}, setting up retry for potential streaming`);let s=0;const i=5,l=setInterval(()=>{s++,e.info(`V4_TRIAL_SWITCH: Retry ${s}/${i} checking for active streams`);const T=this.v4Control.getActiveStreams(t);T?(e.info(`V4_TRIAL_SWITCH: Found active streams after ${s} retries - starting live updates`),clearInterval(l),this.connectToTrialStream(t,T)):s>=i&&(e.info(`V4_TRIAL_SWITCH: No streams after ${i} retries - staying with historical data only`),clearInterval(l))},500)}else e.info(`V4_TRIAL_SWITCH: Non-running trial ${g?.status||"NOT_FOUND"} - complete with historical data only`);return}this.connectToTrialStream(t,d)}connectToTrialStream(t,r){e.info(`V4_STREAM_CONNECT: Connecting to streams for trial ${t} with historical foundation`),e.info(`V4_STREAM_CONNECT: Entry point - starting stream connection for trial ${t}`),this.isActive=!0;const o=r.callsSubject||r.sharedCalls$;e.info(`V4_STREAM_CONNECT: Subscribing to calls stream for updates, type: ${o?.constructor?.name}`),e.info(`V4_STREAM_CONNECT: Calls stream available: ${!!o}, type: ${o?.constructor?.name}`),this.subscription=o.subscribe({next:a=>{if(a&&a.length>0){const f=performance.now();e.info(`PAUSE_RESUME_BUG: Stream manager received ${a.length} calls`),a.forEach(s=>e.info(`PAUSE_RESUME_BUG: - ${s.id} status=${s.status}`)),e.info(`V4_STREAM_CONNECT: Processing batch of ${a.length} updates`);const c=this.store.apiCalls.value,n=new Map;for(const s of c)n.set(s.id,s);let d=!1;for(const s of a){const i=n.get(s.id);i&&i.status!==s.status?d=!0:i||(d=!0),n.set(s.id,s)}let p;if(d)e.info(`V4_STREAM_OPTIMIZE: Re-sorting ${n.size} calls due to status changes`),p=Array.from(n.values()).sort((s,i)=>{const l=m=>{switch(m){case"running":return 0;case"completed":return 1;case"failed":return 2;case"pending":return 3;default:return 4}},T=l(s.status),S=l(i.status);if(T!==S)return T-S;if(s.status==="completed"&&i.status==="completed"){const m=s.completed?new Date(s.completed).getTime():0;return(i.completed?new Date(i.completed).getTime():0)-m}if(s.status==="running"&&i.status==="running"){const m=s.started?new Date(s.started).getTime():0;return(i.started?new Date(i.started).getTime():0)-m}return s.order-i.order});else{e.info(`V4_STREAM_OPTIMIZE: Preserving order, updating ${a.length} calls in-place`);const s=[];for(const i of c){const l=n.get(i.id);l?(s.push(l),n.delete(i.id)):s.push(i)}for(const i of n.values())s.push(i);p=s}const g=performance.now()-f;e.info(`V4_STREAM_OPTIMIZE: Batch processed in ${g.toFixed(1)}ms (was cloning ${c.length} calls)`),this.store.updateApiCalls(p)}},error:a=>{e.error("V4_STREAM_CONNECT: Stream error:",a),e.info("V4_STREAM_CONNECT: Calls stream ERROR:",a),this.store.setStreaming(!1),this.isActive=!1},complete:()=>{e.info(`V4_TRIAL_DEBUG_STREAMS_MGR: Stream completed for trial ${t}`),e.info(`V4_TRIAL_DEBUG_STREAMS: Calls stream COMPLETED for trial ${t}`),this.store.setStreaming(!1),this.isActive=!1,this.loadHistoricalData(t)}}),r.sharedProgress$&&(e.info("V4_STREAM_CONNECT: Subscribing to progress stream"),e.info(`V4_STREAM_CONNECT: Progress stream available: ${!!r.sharedProgress$}`),this.progressSubscription=r.sharedProgress$.subscribe({next:a=>{e.info("V4_STREAM_CONNECT: Received progress update:",a.type),e.info(`V4_STREAM_CONNECT: Progress update - ${a.type}`),e.info(`ðŸš¨ COMPLETION_DEBUG: Stream manager received progress event: ${a.type} at ${new Date().toISOString()}`),a.type==="completed"&&(e.info(`V4_TRIAL_DEBUG_STREAMS: Trial ${t} COMPLETED via progress stream`),e.info("ðŸš¨ COMPLETION_DEBUG: âœ… TRIAL COMPLETED EVENT RECEIVED BY STREAM MANAGER!"),e.info(`V4_TRIAL_COMPLETION: Loading final data from database for completed trial ${t}`),this.loadHistoricalData(t).then(()=>{e.info("V4_TRIAL_COMPLETION: Final data loaded - UI should now show accurate completion counts"),e.info("ðŸš¨ COMPLETION_DEBUG: âœ… UI SHOULD BE UPDATED NOW!")}).catch(f=>{e.error("V4_TRIAL_COMPLETION: Failed to load final data:",f)})),this.store.updateProgress(a)},error:a=>{e.error("V4_STREAM_CONNECT: Progress stream error:",a),e.info("V4_STREAM_CONNECT: Progress stream ERROR:",a)}})),e.info("V4_STREAM_CONNECT: Successfully connected to streams with historical foundation"),e.info(`V4_STREAM_CONNECT: Stream subscriptions complete for trial ${t}`)}cleanupSubscriptions(){e.info("STREAM_MGR_V4: Cleaning up existing subscriptions"),this.subscription&&(this.subscription.unsubscribe(),this.subscription=null),this.progressSubscription&&(this.progressSubscription.unsubscribe(),this.progressSubscription=null),this.store.setStreaming(!1)}stopStreaming(){e.info("STREAM_MGR_V4: Stopping streaming"),e.info(`V4_TRIAL_DEBUG_STREAMS: stopStreaming() called for trial ${this.currentTrialId}`),e.info(`V4_TRIAL_DEBUG_STREAMS: Current isActive: ${this.isActive}`),this.cleanupSubscriptions(),this.isActive=!1,e.info("V4_TRIAL_DEBUG_STREAMS: Stopped streaming, isActive set to false")}async loadHistoricalData(t){const r=performance.now();e.info(`V4_TRIAL_SWITCH: loadHistoricalData() ENTRY for trial ${t}`);try{const o=performance.now();e.info(`V4_TRIAL_SWITCH: Checking database availability at ${(o-r).toFixed(1)}ms`);const a=performance.now();e.info(`V4_TRIAL_SWITCH: Preparing database query at ${(a-r).toFixed(1)}ms`);const f=performance.now();e.info(`V4_TRIAL_SWITCH: Starting IndexedDB query at ${(f-r).toFixed(1)}ms`);const c=await V.apiCalls.where("trialId").equals(t).toArray(),n=performance.now();e.info(`V4_TRIAL_SWITCH: IndexedDB query COMPLETED - loaded ${c.length} calls in ${(n-f).toFixed(1)}ms`),e.info(`V4_TRIAL_SWITCH: Total time to query completion: ${(n-r).toFixed(1)}ms`);const d=performance.now();c.sort((l,T)=>{const S=h=>{switch(h){case"running":return 0;case"completed":return 1;case"failed":return 2;case"pending":return 3;default:return 4}},m=S(l.status),E=S(T.status);if(m!==E)return m-E;if(l.status==="completed"&&T.status==="completed"){const h=l.completed?new Date(l.completed).getTime():0;return(T.completed?new Date(T.completed).getTime():0)-h}if(l.status==="running"&&T.status==="running"){const h=l.started?new Date(l.started).getTime():0;return(T.started?new Date(T.started).getTime():0)-h}return l.order-T.order});const p=performance.now();e.info(`V4_TRIAL_SWITCH: Sorting ${c.length} calls took ${(p-d).toFixed(1)}ms`);const g=performance.now();this.store.updateApiCalls(c),this.store.setStreaming(!1);const s=performance.now();e.info(`V4_TRIAL_SWITCH: Store update took ${(s-g).toFixed(1)}ms`),e.info(`V4_TRIAL_SWITCH: loadHistoricalData keeping isActive = ${this.isActive} to maintain reactive query pause`);const i=performance.now();e.info(`V4_TRIAL_SWITCH: loadHistoricalData TOTAL: ${(i-r).toFixed(1)}ms`)}catch(o){e.error("STREAM_MGR_V4: Failed to load historical data:",o),this.store.clear()}}destroy(){e.info("STREAM_MGR_V4: Destroying stream manager"),this.stopStreaming(),this.currentTrialId=null,this.store.clear()}}let A=null;function b(){return A||(A=new L,e.info("STREAM_MGR_V4: Created singleton manager instance")),A}typeof window<"u"&&(window.__trialStreamManagerV4=()=>A);const U=Object.freeze(Object.defineProperty({__proto__:null,useTrialStreamManagerV4:b},Symbol.toStringTag,{value:"Module"}));export{b as a,U as t,y as u};
