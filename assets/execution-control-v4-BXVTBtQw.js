const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/trial-stream-manager-v4-Bs32g0Yg.js","assets/index-BNyV4f0C.js","assets/vue-vendor-DPw1dQYc.js","assets/ui-vendor-IRGmExUJ.js","assets/utils-vendor-B76-F3_P.js","assets/index-DaHEOU6Y.css"])))=>i.map(i=>d[i]);
var R=Object.defineProperty;var S=(T,t,e)=>t in T?R(T,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):T[t]=e;var c=(T,t,e)=>S(T,typeof t!="symbol"?t+"":t,e);import{d as u,a as r,i as w,P as N,m as O,n as A,_ as $}from"./index-BNyV4f0C.js";import{r as b,c as d}from"./vue-vendor-DPw1dQYc.js";import{s as L,a as k,S as U,R as P,m as x}from"./utils-vendor-B76-F3_P.js";class V{constructor(){c(this,"state",b({status:"idle",trialId:null,orchestratorType:null,startedAt:null,pausedAt:null,completedAt:null,tabId:null}));c(this,"currentState",d(()=>({...this.state})));c(this,"status",d(()=>this.state.status));c(this,"trialId",d(()=>this.state.trialId));c(this,"orchestratorType",d(()=>this.state.orchestratorType));c(this,"isExecuting",d(()=>["starting","running","pausing"].includes(this.state.status)));c(this,"isPaused",d(()=>this.state.status==="paused"));c(this,"isIdle",d(()=>this.state.status==="idle"))}async hydrate(){const t=await u.trials.where("status").equals("running").toArray();if(t.length>0){`${t.length}`;for(const e of t)await u.trials.update(e.id,{status:"paused"}),`${e.id}`}}async startExecution(t,e,a){if(this.state.status!=="idle"&&this.state.status!=="paused"){let s="Cannot start trial: ";return this.state.status==="running"?s+=`Another trial is currently running (${this.state.trialId}). Please wait for it to complete or pause it first.`:this.state.status==="starting"?s+="A trial is currently starting. Please wait a moment and try again.":this.state.status==="cancelling"?s+="A trial is currently being cancelled. Please wait for it to finish.":s+=`System is in ${this.state.status} state. Please refresh the page if this persists.`,{ok:!1,error:new Error(s)}}try{return this.state.status="starting",this.state.trialId=t,this.state.orchestratorType=e,this.state.tabId=a,this.state.startedAt=new Date,this.state.pausedAt=null,this.state.completedAt=null,await u.trials.update(t,{status:"running",started:this.state.startedAt}),this.state.status="running",`${t}`,{ok:!0,value:void 0}}catch(s){return this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,{ok:!1,error:s instanceof Error?s:new Error("Failed to start execution")}}}async pauseExecution(){if(`${this.state.status}`,this.state.status!=="running")return{ok:!1,error:new Error(`Cannot pause: current status is ${this.state.status}`)};if(!this.state.trialId)return{ok:!1,error:new Error("Cannot pause: no active trial")};try{return this.state.status="pausing",this.state.pausedAt=new Date,await u.trials.update(this.state.trialId,{status:"paused"}),this.state.status="paused",`${this.state.trialId}`,{ok:!0,value:void 0}}catch(t){return this.state.status="running",this.state.pausedAt=null,{ok:!1,error:t instanceof Error?t:new Error("Failed to pause execution")}}}async resumeExecution(t,e){if(`${t}${this.state.status}${e}`,!["idle","paused"].includes(this.state.status))return{ok:!1,error:new Error(`Cannot resume: current status is ${this.state.status}`)};try{const a=await u.trials.get(t);if(!a)return{ok:!1,error:new Error(`Trial ${t} not found`)};if(a.status!=="paused")return{ok:!1,error:new Error(`Cannot resume: trial status is ${a.status}, expected paused`)};const s=a.type==="playground"?"streaming":"regular";return this.state.status="running",this.state.trialId=t,this.state.orchestratorType=s,this.state.tabId=e,this.state.startedAt=a.started||new Date,this.state.pausedAt=null,this.state.completedAt=null,await u.trials.update(t,{status:"running"}),`${t}`,{ok:!0,value:void 0}}catch(a){return this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,this.state.pausedAt=null,{ok:!1,error:a instanceof Error?a:new Error("Failed to resume execution")}}}async cancelExecution(){if(`${this.state.status}`,!["running","paused","starting"].includes(this.state.status))return{ok:!1,error:new Error(`Cannot cancel: current status is ${this.state.status}`)};if(!this.state.trialId)return{ok:!1,error:new Error("Cannot cancel: no active trial")};try{const t=this.state.trialId;return this.state.status="cancelling",this.state.completedAt=new Date,await u.trials.update(t,{status:"cancelled",completed:this.state.completedAt}),this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,this.state.pausedAt=null,`${t}`,{ok:!0,value:void 0}}catch(t){return this.state.status=this.state.pausedAt?"paused":"running",this.state.completedAt=null,{ok:!1,error:t instanceof Error?t:new Error("Failed to cancel execution")}}}async completeExecution(){if(`${this.state.status}`,!["running","paused"].includes(this.state.status))return{ok:!1,error:new Error(`Cannot complete: current status is ${this.state.status}`)};if(!this.state.trialId)return{ok:!1,error:new Error("Cannot complete: no active trial")};try{const t=this.state.trialId;return this.state.status="completed",this.state.completedAt=new Date,await u.trials.update(t,{status:"completed",completed:this.state.completedAt}),this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,this.state.pausedAt=null,`${t}`,{ok:!0,value:void 0}}catch(t){return this.state.status="running",this.state.completedAt=null,{ok:!1,error:t instanceof Error?t:new Error("Failed to complete execution")}}}canStart(){return this.state.status==="idle"||this.state.status==="paused"}canPause(){return this.state.status==="running"}canResume(){return this.state.status==="paused"&&this.state.orchestratorType!==null}canCancel(){return["running","paused","starting"].includes(this.state.status)}isOwnedByTab(t){return this.state.tabId===t}}const n=new V;class D{constructor(){c(this,"state",b({tabId:w("tab"),role:"observer",isInitialized:!1,lastHeartbeat:new Date}));c(this,"broadcastChannel",null);c(this,"lockReleaseFunction",null);c(this,"heartbeatInterval",null);c(this,"tabId",d(()=>this.state.tabId));c(this,"role",d(()=>this.state.role));c(this,"isLeader",d(()=>this.state.role==="leader"));c(this,"isObserver",d(()=>this.state.role==="observer"));c(this,"isInitialized",d(()=>this.state.isInitialized))}async initialize(){if(this.state.isInitialized){`${this.state.tabId}${this.state.role}`;return}`${this.state.tabId}`;try{this.broadcastChannel=new BroadcastChannel("auditomatic-coordination"),this.broadcastChannel.onmessage=t=>{this.handleCoordinationMessage(t.data)},await this.attemptLeadershipAcquisition(),this.startHeartbeat(),this.state.isInitialized=!0,`${this.state.tabId}${this.state.role}`}catch(t){throw r.error(`COORDINATION: Failed to initialize tab ${this.state.tabId}:`,t),t}}async attemptLeadershipAcquisition(){if(!("locks"in navigator)){`${this.state.tabId}`,this.state.role="leader";return}try{`${this.state.tabId}`,navigator.locks.request("auditomatic-leader",{mode:"exclusive",ifAvailable:!0},t=>{if(t)return`${this.state.tabId}`,this.state.role="leader",new Promise(e=>{this.lockReleaseFunction=e});`${this.state.tabId}`,this.state.role="observer"}),await new Promise(t=>setTimeout(t,50))}catch(t){r.error(`COORDINATION: Leadership acquisition failed for tab ${this.state.tabId}:`,t),this.state.role="observer"}}startHeartbeat(){this.heartbeatInterval=setInterval(()=>{this.state.lastHeartbeat=new Date,this.broadcast({type:"heartbeat",tabId:this.state.tabId,timestamp:this.state.lastHeartbeat})},1e4)}broadcast(t){this.broadcastChannel&&(`${t.type}${this.state.tabId}`,this.broadcastChannel.postMessage(t))}handleCoordinationMessage(t){if(t.tabId!==this.state.tabId)switch(`${this.state.tabId}${t.type}${t.tabId}`,t.type){case"execution:started":this.state.role==="observer"&&t.trialId&&`${t.trialId}`;break;case"execution:paused":this.state.role==="observer"&&t.trialId&&`${t.trialId}`;break;case"execution:resumed":this.state.role==="observer"&&t.trialId&&`${t.trialId}`;break;case"execution:cancelled":case"execution:completed":this.state.role==="observer"&&t.trialId&&`${t.trialId}`;break;case"heartbeat":`${t.tabId}`;break}}canExecuteActions(){return this.state.role==="leader"}validateLeadership(t){return this.state.role!=="leader"?{ok:!1,error:new Error(`Cannot ${t}: only leader tab can execute actions`)}:{ok:!0,value:void 0}}async startExecution(t,e){const a=this.validateLeadership("start execution");if(!a.ok)return a;const s=await n.startExecution(t,e,this.state.tabId);return s.ok&&this.broadcast({type:"execution:started",tabId:this.state.tabId,timestamp:new Date,trialId:t,orchestratorType:e}),s}async pauseExecution(){const t=this.validateLeadership("pause execution");if(!t.ok)return t;const e=await n.pauseExecution();return e.ok&&this.broadcast({type:"execution:paused",tabId:this.state.tabId,timestamp:new Date,trialId:n.trialId.value||void 0}),e}async resumeExecution(t){const e=this.validateLeadership("resume execution");if(!e.ok)return e;const a=await n.resumeExecution(t,this.state.tabId);return a.ok&&this.broadcast({type:"execution:resumed",tabId:this.state.tabId,timestamp:new Date,trialId:t}),a}async cancelExecution(){const t=this.validateLeadership("cancel execution");if(!t.ok)return t;const e=n.trialId.value,a=await n.cancelExecution();return a.ok&&this.broadcast({type:"execution:cancelled",tabId:this.state.tabId,timestamp:new Date,trialId:e||void 0}),a}async completeExecution(){const t=this.validateLeadership("complete execution");if(!t.ok)return t;const e=n.trialId.value,a=await n.completeExecution();return a.ok&&this.broadcast({type:"execution:completed",tabId:this.state.tabId,timestamp:new Date,trialId:e||void 0}),a}destroy(){`${this.state.tabId}`,this.heartbeatInterval&&(clearInterval(this.heartbeatInterval),this.heartbeatInterval=null),this.lockReleaseFunction&&(this.lockReleaseFunction(),this.lockReleaseFunction=null),this.broadcastChannel&&(this.broadcastChannel.close(),this.broadcastChannel=null),this.state.isInitialized=!1,`${this.state.tabId}`}}const p=new D;class M{async updateTrial(t){`${t.trialId}${t.status}`;try{const e={};return t.status!==void 0&&(e.status=t.status),t.started!==void 0&&(e.started=t.started),t.completed!==void 0&&(e.completed=t.completed),t.progress!==void 0&&(e.progress=t.progress),await u.trials.update(t.trialId,e),`${t.trialId}`,{ok:!0,value:void 0}}catch(e){return r.error(`ATOMIC_OPS: Failed to update trial ${t.trialId}:`,e),{ok:!1,error:e instanceof Error?e:new Error("Failed to update trial")}}}async resetRunningCallsToPending(t){try{const e=await u.apiCalls.where("trialId").equals(t).and(a=>a.status==="running").toArray();return e.length===0?`${t}`:(await u.transaction("rw",u.apiCalls,async()=>{for(const a of e)await u.apiCalls.update(a.id,{status:"pending",started:void 0,response:void 0,result:void 0})}),`${e.length}${t}`),await this.recalculateTrialProgress(t),{ok:!0,value:e.length}}catch(e){return r.error(`ATOMIC_OPS: Failed to reset running calls for trial ${t}:`,e),{ok:!1,error:e instanceof Error?e:new Error("Failed to reset running calls")}}}async getTrialCallCounts(t){try{const e=await u.transaction("r",u.apiCalls,async()=>{const a=await u.apiCalls.where("trialId").equals(t).toArray();return{total:a.length,completed:a.filter(s=>s.status==="completed").length,failed:a.filter(s=>s.status==="failed").length,cancelled:a.filter(s=>s.status==="cancelled").length,pending:a.filter(s=>s.status==="pending").length,running:a.filter(s=>s.status==="running").length}});return`${t}`,{ok:!0,value:e}}catch(e){return r.error(`ATOMIC_OPS: Failed to get call counts for trial ${t}:`,e),{ok:!1,error:e instanceof Error?e:new Error("Failed to get call counts")}}}async updateApiCallsBatch(t){if(t.length===0)return{ok:!0,value:void 0};`${t.length}`;try{return await u.transaction("rw",u.apiCalls,async()=>{for(const e of t){const a={status:e.status};e.started!==void 0&&(a.started=e.started),e.completed!==void 0&&(a.completed=e.completed),e.response!==void 0&&(a.response=e.response),e.error!==void 0&&(a.error=e.error),await u.apiCalls.update(e.callId,a)}}),`${t.length}`,{ok:!0,value:void 0}}catch(e){return r.error("ATOMIC_OPS: Failed to update API calls batch:",e),{ok:!1,error:e instanceof Error?e:new Error("Failed to update API calls batch")}}}async reconcileTrialState(t){try{const e=await u.trials.get(t);if(!e)return{ok:!1,error:new Error(`Trial ${t} not found`)};const a=await this.getTrialCallCounts(t);if(!a.ok)return a;const s=a.value;let i=e.status;if(s.running>0?i="running":s.pending>0?i="paused":s.completed===s.total&&s.total>0||s.failed>0&&s.completed+s.failed===s.total?i="completed":s.cancelled>0&&(i="cancelled"),i!==e.status){`${t}${e.status}${i}`;const o=await this.updateTrial({trialId:t,status:i,progress:s,...i==="completed"&&{completed:new Date}});if(!o.ok)return o}else`${t}${i}`;return{ok:!0,value:i}}catch(e){return r.error(`ATOMIC_OPS: Failed to reconcile trial ${t} state:`,e),{ok:!1,error:e instanceof Error?e:new Error("Failed to reconcile trial state")}}}async performCleanupOperations(t){try{const e=await this.resetRunningCallsToPending(t);if(!e.ok)return e;const a=await this.reconcileTrialState(t);if(!a.ok)return a;const s={resetCount:e.value,reconciledStatus:a.value};return`${t}`,{ok:!0,value:s}}catch(e){return r.error(`ATOMIC_OPS: Failed cleanup operations for trial ${t}:`,e),{ok:!1,error:e instanceof Error?e:new Error("Failed cleanup operations")}}}async recalculateTrialProgress(t){try{const e=await u.trials.get(t);if(!e){`${t}`;return}const a=await u.apiCalls.where("trialId").equals(t).toArray();let s=0,i=0,o=0,f=0,I=0;for(const C of a)switch(C.status){case"completed":s++;break;case"failed":i++,C.result?.errorType==="network_error_no_response"&&I++;break;case"cancelled":o++;break;case"running":f++;break}const E=e.progress.total-s-i-o-f,_={total:e.progress.total,completed:s,failed:i,cancelled:o,pending:E,running:f,networkErrors:I};`${t}${s}${i}${f}${E}`,await u.trials.update(t,{progress:_})}catch(e){r.error(`V4_TRIAL_DEBUG_PAUSE: Failed to recalculate progress for trial ${t}:`,e)}}async performSystemCleanup(){try{let t=0,e=0;const a=await u.trials.where("status").equals("running").toArray();`${a.length}`;for(const i of a){const o=await this.performCleanupOperations(i.id);if(o.ok)t+=o.value.resetCount,e++;else{const f=o;r.warn(`ATOMIC_OPS: Failed to cleanup trial ${i.id}:`,f.error.message)}}const s={trialsProcessed:e,callsReset:t};return{ok:!0,value:s}}catch(t){return r.error("ATOMIC_OPS: System cleanup failed:",t),{ok:!1,error:t instanceof Error?t:new Error("System cleanup failed")}}}}const y=new M;class G{constructor(){c(this,"playgroundService",null);c(this,"initialized",!1);c(this,"orchestrators",new Map);c(this,"activeStreams",new Map);c(this,"execution",d(()=>{const t=n.status.value;let e="idle";return t==="running"||t==="starting"||t==="pausing"?e="executing":t==="paused"?e="paused":e="idle",{status:e,currentTrialId:n.trialId.value,startedAt:n.currentState.value.startedAt}}));c(this,"progress",d(()=>({trials:new Map,activeApiCall:null,lastUpdated:new Date})));c(this,"queue",d(()=>({global:{pending:0,executing:0,capacity:0,utilization:0},providers:new Map})));c(this,"tabRole",d(()=>p.role.value));c(this,"isLeader",d(()=>p.isLeader.value));c(this,"canExecute",d(()=>p.isLeader.value&&n.canStart()))}async initialize(){const t=performance.now();if(`${this.initialized}`,`${this.activeStreams.size}`,!this.initialized)try{const e=performance.now();`${(e-t).toFixed(1)}`,await p.initialize(),`${(performance.now()-e).toFixed(1)}`;const s=performance.now();`${(s-t).toFixed(1)}`;const i=await y.performSystemCleanup();if(`${(performance.now()-s).toFixed(1)}`,i.ok)i.value;else{const _=i;r.warn("V4_EXECUTION_CONTROL: System cleanup failed:",_.error)}const f=performance.now();`${(f-t).toFixed(1)}`,this.playgroundService=new N(async _=>{const C=await this.startTrialWithStreaming(_);return C.ok?{ok:!0,value:C.value.progress$}:C}),`${(performance.now()-f).toFixed(1)}`,this.initialized=!0,`${(performance.now()-t).toFixed(1)}`}catch(e){const a=performance.now();throw r.error(`V4_TRIAL_SWITCH: V4ExecutionControl initialization FAILED in ${(a-t).toFixed(1)}ms:`,e),e}}cleanup(){`${this.activeStreams.size}`,`${this.orchestrators.size}`;try{this.activeStreams.forEach((t,e)=>{`${e}`,t.subscription.unsubscribe()}),this.activeStreams.clear(),this.orchestrators.forEach((t,e)=>{`${e}`}),this.orchestrators.clear(),p.destroy(),this.playgroundService=null,this.initialized=!1}catch(t){r.error("V4_EXECUTION_CONTROL: Cleanup error:",t)}}async startTrial(t){this.initialized||await this.initialize();try{if(O(t)){const o=await(this.playgroundService?.executePlaygroundCall("",{})||Promise.resolve({ok:!1,error:new Error("Playground service not available")}));return o.ok?{ok:!0,value:void 0}:{ok:!1,error:o.error}}let a=this.orchestrators.get(t);a||(a=A(),this.orchestrators.set(t,a));const i=await a.startTrialAtomic(t);return i.ok?(`${t}`,{ok:!0,value:void 0}):{ok:!1,error:i.error}}catch(e){return r.error(`V4_EXECUTION_CONTROL: Failed to start trial ${t}:`,e),{ok:!1,error:e instanceof Error?e:new Error("Failed to start trial")}}}async startTrialWithStreaming(t){this.initialized||await this.initialize(),this.cleanupStreams(t);try{if(O(t))return{ok:!1,error:new Error("Playground streaming not yet implemented in V4")};if(!this.canExecute.value){let l="Cannot start trial: ";return this.isLeader.value?this.execution.value.status==="executing"?l+="Another trial is currently running. Please wait for it to complete or pause it first.":this.execution.value.status==="paused"?l+="A trial is currently paused. Resume or cancel it before starting a new one.":l+="This tab is in observer mode. Only the controlling tab can start trials.":l+="Another browser tab is currently controlling trial execution. Close other tabs or wait for them to finish.",{ok:!1,error:new Error(l)}}const a=p.tabId.value,s=await n.startExecution(t,"streaming",a);if(!s.ok)return s.error,{ok:!1,error:s.error};for(const[l,h]of this.orchestrators)if(l!==t){const g=O(l),m=O(t);if(g&&m){`${l}${t}`;continue}else if(g&&!m){`${l}${t}`;continue}else if(!g&&m){`${l}${t}`;continue}else`${l}${t}`,h.cancelTrial(),typeof h.resetState=="function"&&h.resetState(),this.orchestrators.delete(l)}let i=this.orchestrators.get(t);i||(i=A(),this.orchestrators.set(t,i));const o=await i.startTrialAtomicWithStreaming(t);if(!o.ok)return{ok:!1,error:o.error};`${t}`;const f=o.value.progress$.pipe(L(),k({bufferSize:1,refCount:!0})),I=new U,E=new P(1),_=o.value.calls$.pipe(x(l=>(`${l.length}`,l.map(h=>h.call&&h.providerId?h.call:h)))).subscribe({next:l=>{`${l.length}`,E.next(l)},error:l=>{E.error(l)},complete:()=>{`${t}`}});I.add(_);const C=E;return I.add(f.subscribe({next:l=>{`${t}${l.type}`,(l.type==="completed"||l.type==="error")&&(`${t}${l.type}`,`${n.status.value}`,l.type==="completed"?p.completeExecution().then(h=>{h.ok?`${n.status.value}`:r.error("V4_TRIAL_DEBUG_COMPLETION: Coordination layer completion update failed:",h.error)}):p.cancelExecution().then(h=>{h.ok?`${n.status.value}`:r.error("V4_TRIAL_DEBUG_COMPLETION: Coordination layer cancellation update failed:",h.error)}),setTimeout(()=>{`${t}`,`${n.status.value}`,this.cleanupStreams(t),this.orchestrators.has(t)&&(`${t}`,this.orchestrators.delete(t))},1e3))},error:l=>{r.error(`V4_TRIAL_DEBUG_COMPLETION: Stream error for trial ${t}:`,l),p.cancelExecution().then(h=>{h.ok?`${n.status.value}`:r.error("V4_TRIAL_DEBUG_COMPLETION: Coordination layer error cancellation failed:",h.error)}),this.cleanupStreams(t),this.orchestrators.has(t)&&(`${t}`,this.orchestrators.delete(t))}})),`${t}`,this.activeStreams.set(t,{streams:o.value,subscription:I,sharedProgress$:f,sharedCalls$:C,callsSubject:E}),`${t}`,{ok:!0,value:o.value}}catch(e){return r.error(`V4_EXECUTION_CONTROL: Failed to start streaming trial ${t}:`,e),{ok:!1,error:e instanceof Error?e:new Error("Failed to start streaming trial")}}}async pauseExecution(){this.initialized||await this.initialize();const t=n.trialId.value;if(`${n.status.value}`,`${this.activeStreams.size}`,`${this.orchestrators.size}${t}${t?this.orchestrators.has(t):!1}`,!t)return{ok:!1,error:new Error("No active trial to pause")};if(!n.canPause())return{ok:!1,error:new Error("Cannot pause in current state")};const e=this.orchestrators.get(t);e&&await e.pauseTrial();const a=await n.pauseExecution();return a.ok?(p.pauseExecution(),{ok:!0,value:void 0}):(a.error,a)}async resumeExecution(t){this.initialized||await this.initialize();const e=t||n.trialId.value;if(`${n.status.value}`,`${this.activeStreams.size}`,`${t||"NONE"}${n.trialId.value||"NONE"}`,!e)return{ok:!1,error:new Error("No trial ID provided and no active trial to resume")};if(!n.canResume())return{ok:!1,error:new Error("Cannot resume in current state")};const a=p.tabId.value,s=await n.resumeExecution(e,a);if(!s.ok)return s.error,s;try{const o=await y.resetRunningCallsToPending(e);if(o.ok&&o.value>0){`${o.value}`;const{useTrialStreamManagerV4:f}=await $(async()=>{const{useTrialStreamManagerV4:E}=await import("./trial-stream-manager-v4-Bs32g0Yg.js").then(_=>_.t);return{useTrialStreamManagerV4:E}},__vite__mapDeps([0,1,2,3,4,5])),I=f();I&&await I.loadHistoricalData(e)}}catch(o){r.warn("V4_TRIAL_DEBUG_RESUME: Failed to reset running calls, continuing anyway:",o)}let i=this.orchestrators.get(e);if(i)typeof i.resetState=="function"&&i.resetState(),i.resumeTrial();else{i=A(),this.orchestrators.set(e,i);const o=await i.startTrialAtomicWithStreaming(e);if(!o.ok)return r.error("V4_TRIAL_DEBUG_RESUME: Failed to start trial for cold resume:",o.error),{ok:!1,error:o.error}}return p.resumeExecution(e),{ok:!0,value:void 0}}async cancelExecution(){this.initialized||await this.initialize();const t=n.trialId.value;if(!t)return{ok:!1,error:new Error("No active trial to cancel")};if(!n.canCancel())return{ok:!1,error:new Error("Cannot cancel in current state")};const e=await n.cancelExecution();if(!e.ok)return e.error,e;const a=this.orchestrators.get(t);return a&&(a.cancelTrial(),this.orchestrators.delete(t)),p.cancelExecution(),this.cleanupStreams(t),{ok:!0,value:void 0}}async executeSingleCall(t,e,a){return this.initialized||await this.initialize(),this.playgroundService?this.playgroundService.executePlaygroundCall(t,a):{ok:!1,error:new Error("Playground service not initialized")}}getActiveStreams(t){const e=this.activeStreams.get(t);return`${t}`,e?.sharedCalls$,e}cleanupStreams(t){`${n.status.value}`,`${n.trialId.value}`;const e=this.activeStreams.get(t);e&&(e.subscription.unsubscribe(),this.activeStreams.delete(t),`${this.activeStreams.size}`)}}let v=null;function X(){return v||(v=new G),v}export{X as u};
