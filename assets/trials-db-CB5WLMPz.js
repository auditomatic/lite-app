var t=Object.defineProperty,e=(e,r,s)=>((e,r,s)=>r in e?t(e,r,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[r]=s)(e,"symbol"!=typeof r?r+"":r,s);import{ag as r,f as s,c as a,ah as o}from"./vendor-BxfGckcK.js";import{l as i}from"./db-COX2g2xv.js";import{d as n,i as l}from"./index-D7qu21q1.js";import{p as c}from"./registry-CUN7XnFI.js";import{b as u}from"./designs-db-DO9a-1L6.js";import{u as d}from"./settings-db-BlTZ-7ej.js";class f{static extractContent(t,e){if(!t)return{success:!1,error:"No response body"};const r=this.getValueAtPath(t,e.contentPath);if(null!=r){if(e.isJSON&&"string"==typeof r)try{const t=JSON.parse(r);return t&&"object"==typeof t&&"answer"in t?{success:!0,content:String(t.answer)}:{success:!0,content:JSON.stringify(t)}}catch{return{success:!0,content:String(r)}}return{success:!0,content:String(r)}}if(e.fallbackPaths)for(const s of e.fallbackPaths){const e=this.getValueAtPath(t,s);if(null!=e)return{success:!0,content:String(e)}}if(e.errorPath){const r=this.getValueAtPath(t,e.errorPath);if(null!=r)return{success:!1,error:String(r)}}return{success:!1,error:`No content found at path '${e.contentPath}' or fallback paths`}}static getValueAtPath(t,e){if(t&&e)try{const r=e.split(".").flatMap(t=>{const e=t.match(/^([^[]+)\[(\d+)\]$/);if(e)return[e[1],parseInt(e[2])];const r=t.match(/^\[(\d+)\]$/);return r?[parseInt(r[1])]:[t]});let s=t;for(const t of r){if(null==s)return;s=s[t]}return s}catch(r){return}}}class p{static detectRefusal(t,e){if(!t||!e||0===e.length)return!1;const r=t.toLowerCase();for(const s of e)if(r.includes(s.toLowerCase()))return!0;return!1}static async getRefusalWords(t){const e=t.designSnapshot,r=[];if(e.refusalWords&&e.refusalWords.length>0&&r.push(...e.refusalWords),e.refusalWordsListRef)try{const t=await n.variableLists.get(e.refusalWordsListRef);t&&t.values&&r.push(...t.values)}catch(s){console.warn("Failed to load refusal words list:",s)}return r}static async processRefusalDetection(t,e){if(!t.result||!t.result.success||!t.result.content)return;const r=await this.getRefusalWords(e);if(0===r.length)return;const s=String(t.result.content),a=this.detectRefusal(s,r);t.result.refused=a,a&&e.designSnapshot.rejectRefusalWords&&(t.result.success=!1,t.result.error="Response contained refusal words")}}class h{constructor(t){e(this,"options"),e(this,"abortController"),this.options={maxRetries:3,retryDelay:5e3,rateLimitDelay:1e3,...t}}async executeAPICall(t,e,r){t.status="running",t.created=new Date,this.options.onProgress?.(t);try{const s=this.options.getApiKey(e.provider),a=this.options.getBaseUrl(e.provider);if(!s&&c.requiresApiKey(e.provider))throw new Error(`No API key configured for provider: ${e.provider}`);const o={id:`${e.provider}:${e.modelId}`,name:e.name,provider:e.provider,model:e.modelId,params:e.parameters,created_at:new Date},i=this.getResponseModeFromConfig(e),n=u.buildAPIRequest(o,t.prompt,s,a,i);t.request={...n,timestamp:new Date};const l=await this.executeWithRetries(n);if(t.response=l,i?.responseTransform){const e=f.extractContent(l.body,i.responseTransform);t.result=e}else t.result={success:!1,error:"No responseTransform configuration found for this response mode"};return r&&t.result&&await p.processRefusalDetection(t,r),t.status="completed",t.completed=new Date,this.options.onProgress?.(t),t}catch(s){return t.status="failed",t.result?t.result.error=s instanceof Error?s.message:String(s):t.result={success:!1,error:s instanceof Error?s.message:String(s)},t.completed=new Date,this.options.onError?.(t,s),t}}async executeWithRetries(t){let e=null;for(let s=0;s<this.options.maxRetries;s++)try{const r=Date.now(),a=await fetch(t.url,{method:t.method,headers:t.headers,body:JSON.stringify(t.body),signal:this.abortController?.signal}),o=Date.now()-r,i=await a.text();let n;try{n=JSON.parse(i)}catch{n=i}const l={status:a.status,headers:Object.fromEntries(a.headers.entries()),body:n,latencyMs:o};if(!a.ok){const t=u.extractErrorMessage(n);if(this.shouldRetry(a.status,s)){e=new Error(`API error (${a.status}): ${t}`),await this.delay(this.getRetryDelay(a.status,s));continue}throw new Error(`API error (${a.status}): ${t}`)}if(u.isErrorResponse(n)){const t=u.extractErrorMessage(n);throw new Error(`Provider error: ${t}`)}return this.options.rateLimitDelay&&this.options.rateLimitDelay>0&&await this.delay(this.options.rateLimitDelay),l}catch(r){if(r instanceof Error&&"AbortError"===r.name)throw new Error("API call execution aborted");if(e=r,s<this.options.maxRetries-1){await this.delay(this.options.retryDelay);continue}}throw e||new Error("Unknown error during API execution")}shouldRetry(t,e){return!(e>=this.options.maxRetries-1)&&(429===t||t>=500)}getRetryDelay(t,e){return 429===t?Math.min(1e3*Math.pow(2,e),6e4):this.options.retryDelay}delay(t){return new Promise(e=>setTimeout(e,t))}abort(){this.abortController?.abort()}getResponseModeFromConfig(t){const e=c.getProvider(t.provider);if(!e?.responseModes)return null;for(const[,r]of Object.entries(e.responseModes)){const e=r.parameters||{};if(Object.keys(e).every(e=>e in t.parameters)&&Object.keys(e).length>0)return r}return e.responseModes.text||Object.values(e.responseModes)[0]}}class g{constructor(t){e(this,"executor"),e(this,"aborted",!1),e(this,"providerConcurrency"),this.executor=new h(t),this.providerConcurrency={};for(const[e,r]of Object.entries(c.getAllProviders()))this.providerConcurrency[e]=t.providerConcurrency?.[e]||r.execution?.defaultConcurrency||4}async executeBatch(t,e){const r=new Map;for(const a of t){const t=e.configurationSnapshots[a.configurationIndex];if(!t){a.status="failed",a.result={success:!1,error:`Configuration not found at index: ${a.configurationIndex}`};continue}const s=t.provider;r.has(s)||r.set(s,[]),r.get(s).push(a)}console.log(`Executing ${t.length} calls across ${r.size} providers:`);for(const[a,o]of r){const t=this.providerConcurrency[a]||4;console.log(`  ${a}: ${o.length} calls, concurrency: ${t}`)}const s=Array.from(r.entries()).map(([t,r])=>this.executeProviderBatch(t,r,e));return(await Promise.all(s)).flat()}async executeProviderBatch(t,e,r){const s=[],a=[...e],o=new Set,i=this.providerConcurrency[t]||4;for(;a.length>0||o.size>0;){if(this.aborted){console.log(`Provider ${t} execution aborted, stopping new requests`);break}for(;a.length>0&&o.size<i&&!this.aborted;){const t=a.shift(),e=r.configurationSnapshots[t.configurationIndex],i=this.executor.executeAPICall(t,e,r).then(t=>(s.push(t),o.delete(i),t)).catch(e=>(t.status="failed",t.result={success:!1,error:e.message},s.push(t),o.delete(i),t));o.add(i)}o.size>0&&await Promise.race(o)}return s}abort(){this.aborted=!0,this.executor.abort()}}class m{constructor(t){e(this,"batchExecutor"),this.batchExecutor=new g(t)}generateVariableCombinations(t){if(0===t.variableSnapshots.length)return[{variables:{}}];let e=[{variables:{}}];for(const r of t.variableSnapshots){const t=[];for(const s of e)if("simple"===r.category&&r.data.values)for(const e of r.data.values)t.push({variables:{...s.variables,[r.variableName]:e},attributes:s.attributes});else if("attributed"===r.category&&r.data.items)for(const e of r.data.items){const a=s.attributes||{};a[r.variableName]=e.attributes,t.push({variables:{...s.variables,[r.variableName]:e.value},attributes:a})}e=t}return e}generateAPICallsFromTrial(t){const e=[],r=this.generateVariableCombinations(t);return t.configurationSnapshots.forEach((s,a)=>{r.forEach(r=>{let s=t.designSnapshot.promptTemplate;Object.entries(r.variables).forEach(([t,e])=>{const r=`{{${t}}}`;s=s.replace(new RegExp(r,"g"),e)});const o={id:l(),trialId:t.id,configurationIndex:a,variables:r.variables,variableAttributes:r.attributes,prompt:s,request:{url:"",method:"POST",headers:{},body:{},timestamp:new Date},status:"pending",created:new Date};e.push(o)})}),e}async executeTrial(t){const e=this.generateAPICallsFromTrial(t);return await this.batchExecutor.executeBatch(e,t)}abort(){this.batchExecutor.abort()}}const w=r("trials",()=>{const t=s([]),e=s(!1),r=s(null);let u=null,f=new Map;async function p(t,e){try{await n.trials.update(t,e)}catch(r){throw console.error("Failed to update trial:",r),new Error("Failed to update trial")}}async function h(t){try{return await n.trials.get(t)}catch(e){return void console.error("Failed to get trial:",e)}}function g(t,e){let r=0;for(const s of t){const t=s.modelSnapshot;if(t.capabilities?.inputCostPerToken&&t.capabilities?.outputCostPerToken){const s=50;r+=(100*t.capabilities.inputCostPerToken+s*t.capabilities.outputCostPerToken)*e}}return r}const w=a(()=>{const e={draft:[],running:[],completed:[],failed:[],cancelled:[]};return t.value.forEach(t=>{e[t.status].push(t)}),e}),y=a(()=>t.value.slice().sort((t,e)=>e.created.getTime()-t.created.getTime()).slice(0,10));return{trials:o(t),isLoading:o(e),error:o(r),trialsByStatus:w,recentTrials:y,initialize:async function(){if(!u){e.value=!0,r.value=null;try{u=i(()=>n.trials.orderBy("created").reverse().toArray()).subscribe({next:r=>{t.value=r,e.value=!1},error:t=>{console.error("Trials store subscription error:",t),r.value="Failed to load trials",e.value=!1}})}catch(s){console.error("Failed to initialize trials store:",s),r.value="Failed to initialize trials",e.value=!1}}},createTrial:async function(t){const e=l(),r=new Date;try{const s=await n.designs.get(t.designId);if(!s)throw new Error("Design not found");const a=[];if(s.variableBindings)for(const[t,e]of Object.entries(s.variableBindings))if("list"===e.type&&e.listId){const s=await n.variableLists.get(e.listId);if(!s)throw new Error(`Variable list not found for variable ${t}: ${e.listId}`);a.push({originalListId:s.id,originalListName:s.name,variableName:t,category:s.category,data:{values:s.values,attributeKeys:s.attributeKeys,items:s.items,itemCount:s.itemCount},snapshotDate:r})}else"direct"===e.type&&e.values&&a.push({originalListId:`direct-${t}`,originalListName:`Direct values for ${t}`,variableName:t,category:"simple",data:{values:[...e.values],itemCount:e.values.length},snapshotDate:r});const o=[];for(const e of t.configurations){const t=c.getProvider(e.provider);if(!t)throw new Error(`Provider not found: ${e.provider}`);const r=await n.models.get(`${e.provider}:${e.modelId}`);if(!r)throw new Error(`Model not found: ${e.provider}:${e.modelId}`);o.push({name:e.name,provider:e.provider,modelId:e.modelId,parameters:{...e.parameters},providerSnapshot:JSON.parse(JSON.stringify(t)),modelSnapshot:JSON.parse(JSON.stringify(r))})}const i=function(t){return 0===t.length?0:t.reduce((t,e)=>t*e.data.itemCount,1)}(a),l={id:e,name:t.name,designSnapshot:{originalId:s.id,originalName:s.name,promptTemplate:s.promptTemplate,variableBindings:JSON.parse(JSON.stringify(s.variableBindings)),outputType:s.outputType,extractPattern:s.extractPattern,refusalWords:s.refusalWords?[...s.refusalWords]:void 0,refusalWordsListRef:s.refusalWordsListRef,refusalWordsSource:s.refusalWordsSource,rejectRefusalWords:s.rejectRefusalWords,snapshotDate:r},configurationSnapshots:o,variableSnapshots:a,status:"draft",progress:{total:i*o.length,completed:0,networkErrors:0},totalCombinations:i,estimatedCost:g(o,i),created:r};return await n.trials.add(l),e}catch(s){throw console.error("Failed to create trial:",s),new Error(`Failed to create trial: ${s instanceof Error?s.message:"Unknown error"}`)}},updateTrial:p,duplicateTrial:async function(t){try{const e=await n.trials.get(t);if(!e)throw new Error("Trial not found");const r=l(),s={...e,id:r,name:`${e.name} (Copy)`,status:"pending",progress:{total:e.progress.total,completed:0,networkErrors:0},created:new Date};return await n.trials.add(s),r}catch(e){throw console.error("Failed to duplicate trial:",e),new Error(`Failed to duplicate trial: ${e instanceof Error?e.message:"Unknown error"}`)}},deleteTrial:async function(t){try{await n.transaction("rw",[n.trials,n.apiCalls],async()=>{await n.apiCalls.where("trialId").equals(t).delete(),await n.trials.delete(t)})}catch(e){throw console.error("Failed to delete trial:",e),new Error("Failed to delete trial")}},getTrial:h,executeTrial:async function(t){const e=await h(t);if(!e)throw new Error(`Trial not found: ${t}`);const r=d(),s=new m({getApiKey:t=>r.getApiKey(t),getBaseUrl:t=>r.getBaseUrl(t),providerConcurrency:(await n.settings.get("main"))?.providerConcurrency,onProgress:async e=>{try{if(await n.apiCalls.put(e),"completed"===e.status||"failed"===e.status){const e=await n.trials.get(t);if(e){const r=await n.apiCalls.where("trialId").equals(t).toArray(),s=r.filter(t=>"completed"===t.status||"failed"===t.status).length;e.progress={total:e.configurationSnapshots.length*e.totalCombinations,completed:s,networkErrors:r.filter(t=>"failed"===t.status).length},await n.trials.put(e)}}}catch(r){console.warn("Progress update failed:",r)}},onError:async(t,e)=>{console.error("API call failed:",e),await n.apiCalls.put(t)}});try{f.set(t,s),await p(t,{status:"running"});const r=await n.apiCalls.where("trialId").equals(t).toArray(),a=s.generateAPICallsFromTrial(e),o=new Set(r.filter(t=>"completed"===t.status||"failed"===t.status).map(t=>`${t.configurationIndex}-${JSON.stringify(t.variables)}`)),i=a.filter(t=>!o.has(`${t.configurationIndex}-${JSON.stringify(t.variables)}`));console.log(`Resuming trial: ${r.length} existing, ${i.length} pending`);const l=i.length>0?await s.batchExecutor.executeBatch(i,e):[];l.length>0&&await n.apiCalls.bulkPut(l);const c=await n.trials.get(t);if("running"===c?.status){const r=e.configurationSnapshots.length*e.totalCombinations,s=(await n.apiCalls.where("trialId").equals(t).toArray()).filter(t=>"completed"===t.status||"failed"===t.status).length,a=s===r;console.log(`Trial completion check: ${s}/${r} calls complete`),await p(t,{status:a?"completed":"paused"})}else console.log(`Trial status is ${c?.status}, not updating from execution`)}catch(a){throw console.error("Trial execution failed:",a),await p(t,{status:"failed"}),a}finally{f.delete(t)}},pauseTrial:async function(t){const e=f.get(t);e&&(e.abort(),f.delete(t)),await p(t,{status:"paused"})},cancelTrial:async function(t){const e=f.get(t);e&&(e.abort(),f.delete(t)),await p(t,{status:"cancelled"})},destroy:function(){u&&(u.unsubscribe(),u=null)}}});export{m as T,w as u};
